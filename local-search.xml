<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《短篇》（五）</title>
    <link href="/2024/09/27/%E3%80%8A%E7%9F%AD%E7%AF%87%E3%80%8B%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2024/09/27/%E3%80%8A%E7%9F%AD%E7%AF%87%E3%80%8B%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>原神，启动！</p><span id="more"></span><h2 id="审讯笔录（一）"><a href="#审讯笔录（一）" class="headerlink" title="审讯笔录（一）"></a>审讯笔录（一）</h2><p><strong>第一次</strong></p><p><strong>2014年6月26日</strong></p><p><strong>自22时36分开始</strong></p><p><strong>至次日02时08分结束</strong></p><p><strong>询问人</strong> ：</p><p><em>梁歌、晶戈，吴明市橘子区公安分局刑侦九中队</em></p><p><strong>被询问人</strong>：</p><p><strong>姓名</strong>：卫枝                             <strong>性别</strong>：<em>男</em>          <strong>年龄</strong>：<em>22岁</em> </p><p><strong>出生年月日</strong>：<em>1992.5.20</em>          <strong>民族</strong>：<em>汉</em>          <strong>文化程度</strong>：<em>本科</em> </p><p><strong>工作单位</strong>：<em>吴明市拉基游戏有限公司</em> </p><p><strong>家庭住址</strong>：<em>吴明市谋迢街114514号</em></p><hr><p><strong>兹将讯问内容记录如下：</strong></p><p>问：别紧张，就是简单问一下，了解一下情况。</p><p>答：…….（抬起头看看了警官，保持沉默）</p><p>问：家庭情况讲一下？</p><p>答：家里三口人。父亲，卫徕，48岁，银行职员；母亲，新垣结衣，47岁，初中老师。</p><p>问：谈对象了吗？</p><p>答：曾经有过。</p><p>问：讲一下个人简历？</p><p>答：土生土长的本地人，除开大学是在外地读，人生的其他时间都没出过市。去年毕业后回到吴明，在一家公司做程序员。</p><p>问：以前受过公安机关处理过没有？</p><p>答：……（头低了下去，一言不发）</p><p>问：没事的，我们只是了解一下。以前有没有受过公安机关处理？</p><p>答：进来过一次。</p><p>问：什么时候？那次犯了什么事？</p><p>答：两年前，因为跟别人打架。</p><p>问：（确认了一下档案）知道今天为什么把你带到过来吗？  </p><p>答：不知道。</p><p>问：你确定你不知道？</p><p>答：真不知道。（抬起头，语气加快了一点）一，我没犯事。二，我没想犯事。三、我没有传播，都是自己看的。</p><p>问：细说第三……（停顿了一下）不是这个事。</p><p>答：那你们把我抓过来是为什么？</p><p>问：事就是这么个事，我们也不明白，正是因为这样，所以你才在这里，懂了吗？</p><p>答：阿sir，我是真不懂。  </p><p>问：那你还记得今天你做了什么吗？从你早上出门去上班到下午下班，跟我们说说你自己做了什么。</p><p>答：（似乎是不情愿的叹了口气）我觉得没什么好说的。很平常，我早上八点出门后直接去家附近的早餐店吃了一碗粉，然后想在那家店隔壁买杯咖啡，不知道哪家咖啡店原先的店员去哪了，但是今天店员好像是新来的，很陌生，手冲做起来也慢很多，因为我也不想排太久的队，所以之后我就走了，直接坐公交到江潮，再坐地铁到财贸广场。真的很想吐槽一下这地铁真的是比棺材还挤，每次去上班都要挤，这是最崩溃的，如果是因为我在地铁上坏了什么事才抓我过来，那是绝对是污蔑，每次在地铁上我都高举双手，手机也一直息屏，做什么违法乱纪的事情绝对不可能，这我拿人格担保。</p><p>问：嗯，我们知道，我以前也经常挤地铁。没事，继续。</p><p>答：从财贸上来走没多久就到公司了。打卡的时候我看到前台在跟一个男的在吵架，不认识，之后保安来了，拉着那个男的，但是我不想被莫名中伤所以就直接走了，之后我也不知道发生了什么。</p><p>问：这件事你倒是记得很清楚。我们也查了这件事，确实跟你无关。继续说，之后呢？</p><p>答：就是这样。之后就没什么了，直到中午之前我都在忙项目，就没离开过工位……然后，（突然停止，似乎想起了什么）我的电脑好像出了点问题，在我调试程序的时候总是莫名会打开一个空白的网页，一片白色。一开始我以为的有谁在项目代码里加了些脚本，调试的时候会运行这些脚本来打开浏览器，但是我看了一下修改记录，要说明一下，最近的修改是昨天我提交的，而且昨天还没出现这种问题，然后又检查了一下分支，也没有变动，所以发现这项目代码没动过时，我就感觉很诡异。然后我问了一下同事，他们调试的时候就没有出现跟我一样的问题。虽然这看起来不是什么大问题，只是开一个网页，可能是我的电脑出了点毛病，但是让人很不爽，就像某种DDoS，只不过是由我自己手动触发。</p><p>问：所以呢，你又做了什么？</p><p>答：能有什么看法。我记录下了网页的域名，除了遵守http协议外，那地址就是一串乱码，而且这串乱码每次打开都不同，当我试着用tracert去追踪这个域名时，全都超时了，我不知道是怎么做到的，DNS服务器又是如何确定的，很怪。看了眼源码也是一片空白，然后当我试着通过同一串乱码进入这个页面时却从没有成功过，无法连接，所以。我没有任何想法法。但是这还不是最主要的，因为我看了一下它的网络请求，离谱到了一种程度，就这什么都没有的页面居然有几千万亿个指向同一个IP的请求，你知道这有多离谱吗，科幻片，这种程度仅仅是chrome没炸掉已经是个奇迹了。</p><p>问：我们也有会网路技术的，所以这些问题我们也懂。那么，你就没看那么多请求发过来的数据的什么吗？</p><p>答：看不懂,无法理解，可能是某个bug导致的显示异常，以现在的科技水平而言可这种情况根本不能出现，疯狂，我只是个普通的写代码的，没那种能力去整这种大活。</p><p>问：之后呢，你怎么解决这个问题的？</p><p>答：没解决。中午吃饭前我写了封邮件给组长跟他说了这件事，他让我无视这个问题继续工作，然后这事就这样告一段落了，我想着过一天再看看问题还在不在，还在的话就申请一下换电脑了。</p><p>问：好的，这部分情况我们已经了解了。这个情况就是这个情况，我们找你也不是因为这件事，但也跟这有关系，既然你说自己什么都不知道，那我们也有必要跟你解释清楚你当前的处境，这会花一段时间，不过你不用担心，我们已经通知你的家人和工作单位了，你参与了一个秘密项目，所以在接下来一周你得在社会上消失一段时间。听懂了吗？</p><p>问：懂了，懂了。</p><hr><p>卫枝(指印)</p><p>2014.6.27</p><hr><h3 id="归档评论"><a href="#归档评论" class="headerlink" title="归档评论"></a>归档评论</h3><blockquote><p>这是原神5周年的分享活动网页，时空管理局怎么混进了op</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>小说</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小小的哀悼</title>
    <link href="/2024/06/29/%E5%B0%8F%E5%B0%8F%E7%9A%84%E5%93%80%E6%82%BC/"/>
    <url>/2024/06/29/%E5%B0%8F%E5%B0%8F%E7%9A%84%E5%93%80%E6%82%BC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>遗落在某处的记忆碎片，或许那天我也一样在想些什么。</p></blockquote><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在冬天他们不会交谈太多。</p><p>我想，这就是大象的沉默——孤独而又沉重。</p><p>啃食耳朵的老鼠告诉所有的我：大象们都失败了，他们走进了吵闹的市井，并最终忘记了呼吸。</p><p>我为他们的离开表示哀悼，并不再相信有什么不可被打败。</p>]]></content>
    
    
    <categories>
      
      <category>诗歌</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随想</tag>
      
      <tag>现代诗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《短篇》（四）</title>
    <link href="/2024/06/25/%E3%80%8A%E7%9F%AD%E7%AF%87%E3%80%8B%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2024/06/25/%E3%80%8A%E7%9F%AD%E7%AF%87%E3%80%8B%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>我望向那无底深渊，仿佛看到了一个人的坠落，我不知道那下坠的人是谁，只能在心中希望那不是他也不是我。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>“你真的要跳了吗？”我问他。</p><p>他站在悬崖边，跃跃欲试。我望向那无底深渊，仿佛看到了一个人的坠落，我不知道那下坠的人是谁，只能在心中希望那不是他也不是我。</p><p>“不确定。但快了。“他平淡的说，语气中没有任何一丝的起伏。“我只是想看看那里有什么，这不应该吗？如果那里有什么重要的东西，就不会错过了。”</p><p>”为什么你认为那里有什么重要的东西？如果你跳下去后发现什么都没有，这有什么意义？这还只是在你运气好的情况下。“</p><p>我反驳他，这并不是我不能理解他的想法，他一直都是个喜欢冒险的人，只是这次太危险了。</p><p>“你看那里。”他用手指向了深渊某处，我顺着他指向的地方看去，却没有发现任何特别之处，于是我眯起眼睛，试图超越我的视力极限去搜寻他眼中的那道光。“经验告诉我，那里有着什么东西。而我也期望那里有着什么东西。所以你看到那个闪着光的东西了吗？我看到了，只是它藏得太深了。”</p><p>花了好一段时间的搜寻后，我很确定，在那片深渊中只有石头和从岩壁中破出的树木。“我什么都没看到。”事实应该是如此，那里——那片深渊，什么都没有，没有宝藏，没有救赎，也没有希望。“那里没有什么闪着光的东西。我的经验和感觉也跟我说，它们之所以藏得那么深就是因为它们一文不值，你跳下去的结果就是让自己也一文不值。”</p><p>“你什么都没看到，所以你不想跳。是这样吗？”他转过头来对我说，带着一丝令人捉摸不透微笑。</p><p>“即使我看到了，我也不会跳，也不会让你跳。”我很坚决的回答他。“这是个悬崖，再往前踏一步我们就可能玩完了！为什么要为一个所谓重要的东西去拿自己的命冒险，让我们显得更高尚吗？我们有什么使命吗？没有。我感觉你疯了，居然想着为一个东西去跳崖。”我开始转身，准备离开这个悬崖。“走吧，让我们回去，不要再想着从这里跳下去的事了。”我诚恳的请求他同我一起离开。</p><p>他摆了摆手，拒绝了我的请求。</p><p>“我说了，再等一会儿我就要跳了。”他背对着我，令人捉摸不透，根本不知道他到底在等什么。“你再稍微等等，也许等我跳下去之后你就能看见了。而且我保证，我一定会没事的。你放心。”他的话像是在开玩笑，听起来令我不适，但我也不得不停下来，如果他一旦真的跳了，也许我还能一把抓住他，把他拉回来。</p><p>“你无法理解我站在这悬崖上的感觉，这种感觉不是恐惧，也不是欣喜，而是愤怒。深渊就在那里，而你一定会阻止我，无论你是否看到了那重要的东西你都会阻止我，而不在乎我到底看到了什么。你遵守世俗的道德认为自己有义务阻止我，你因为我们之间的友谊而阻拦我伤害自己，而我无法对你进行反驳，即使我感受到了那重要的东西，也无法说服你相信我、放任我跳下去。”</p><p>我感到不可思议，他是在什么时候变成这样的？他的话听起来很清醒，但这样把我比作一个想保护他的人，而更像是一个害他的人，这实在是伤透了我的心。难道这悬崖有什么无上伟力，就一定要将我的这位老友带走吗？我摇了摇他，试图让他清醒一点，但我也不知道这样到底有什么用。</p><p>“这其中矛盾其实可以解决。”他看到我回来后接着说道，但似乎并没有那么确定，也许是他所说的那种愤怒掩盖了某些感情，让他变得对这件事失去了信心，“如果你能在十秒之内向我证明这深渊之中真的什么都没有，我就放弃这一次冒险。”</p><p>“你要我怎么跟你证明？我已经跟你说的很清楚了，你指的那个地方……”我根本不知道该如何跟他说，那种凭感觉和经验来做的决定就是一种赌博，这次他把自己的生命当作赌注，而庄家没有输的可能。忽然，我感觉自己并不是他的朋友，过去的友谊都是不存在的，我和他只是参与了无数次生活中的分赃，见证了太阳一次又一次的升起又落下，我不记得这一切是在什么时候开始的了，或许它就从未真正开始过。</p><p>“十。”他开始了倒数。</p><p>“别吓我！”我严肃的对他说。“如果你真想跳，谁能拦得住你？”</p><p>我不敢相信他真的开始倒数了，而我也开始相信他决定不是在开玩笑，我只是不明白为何要以这种形式来解决我们之间的矛盾，这太荒诞了。</p><p>“九。”</p><p>“你真的要听我说，无论那东西有多重要，错过了又怎样？我们还有更好的选择，在别处，某些地方，更安全的地方…….”</p><p>我想不到什么地方是安全的，我说过他是个喜欢冒险的人，今天是悬崖，明天可能是火山口，后天也可能是海底两万里。</p><p>“八。”</p><p>“假如那里有什么重要的东西，现在的准备太过于仓促，你就这样跳下去，也是什么都得不到！”</p><p>我依旧看不到那深渊之中究竟有什么，或许有是绝望，或者是某些人的尸骨，它们为什么会聚集在那里，为什么这里会有一座悬崖，它们是有预谋的策划好了今天要发生的一切吗？我感觉到空气滞留在我的肺中，进行着一场谋杀。</p><p>“七。”</p><p>“这世界上的很多事不是你我能左右的，万事万物的发展自有其规律，我并不想阻止你，我只是告诉你我看到的现实。”</p><p>他无动于衷，似乎我说的一切都不曾被他听见。他展开双臂望向天空，自倒计时起就保持这个姿势，像是在祈求神助又或是渴望宽容，我看不到他的表情，只是隐约感觉他正以一种我无法理解的形式宣判着某事某物的死刑。他的沉默比他的倒数更加震耳欲聋。我不禁怀疑这一切的真实性，他是在测试我吗？如果他以为自己的测试很高明，那么我宁愿从未认识他，至少是如此愚蠢的他。</p><p>“六。”</p><p>“给我点时间！我回去拿绳索，我们通过索降的方式下去一探究竟，不管怎么说那是最可靠安全的方法去证明，不管是你对还是我对！”</p><p>此刻我终于明白，其实我根本不在乎那里究竟有没有什么重要的东西，我只是像他说的那样，无论事实如何，我始终要越过他的意志去阻止他做出危险的事。我不敢同他一起去追寻那样的死亡的冒险，那是属于他的疯狂，不是属于我的。我经受的一切都告诉我，这是我应该做的事，这是正确的，为此如果他真的跳下去了，我也无需愧疚，至少我尝试过了。</p><p>“五。”</p><p>“如果你真的这么确定话，我希望你能带着那个你说的，重要的东西，活着回来。”</p><p>难道他就要我说这一句吗？然后，他停止了倒数，带着某种我不理解的勇气，毅然决然的跳下悬崖，坠入深渊之中。几秒之后，我听到深渊传出一声巨响，于是，我确认他大抵是已经死了。</p>]]></content>
    
    
    <categories>
      
      <category>小说</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《短篇》（三）</title>
    <link href="/2024/06/17/%E3%80%8A%E7%9F%AD%E7%AF%87%E3%80%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2024/06/17/%E3%80%8A%E7%9F%AD%E7%AF%87%E3%80%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>80年代的青春、迷恋与死亡。最神经病的一集。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="PART-ONE"><a href="#PART-ONE" class="headerlink" title="PART ONE"></a>PART ONE</h3><p>—— 今天晚上去看电影吗？（手里有两张电影票）</p><p>—— 看电影？（趴在桌上打瞌睡）</p><p>—— 可乐？还是咖啡？（一个毫无意义的问题）</p><p>—— 那个大明星死了你知道吗？（突然睁开眼睛）</p><p>—— 为什么问这个？（略微的吃惊）</p><p>—— 约翰诺曼（一个字接着一个字念出来）</p><p>—— 哪个？（摸着头发）</p><p>—— 吸毒过量（略带轻蔑）</p><p>—— 没听说过（是吗）</p><p>—— 你不是很喜欢他的电影吗？（小声说…）</p><p>—— 你听谁说的？（把目光移到别处）</p><p>—— 昨天你说的（嘟囔着）</p><p>—— 是吗？我不记得我说过这话（变得严肃起来了）</p><p>—— 无论如何，那部科幻电影确实是烂透了（转移话题）</p><p>—— 所以你到底去不去看电影？（穷追不舍）</p><p>—— 今天晚上八点，你来接我（青春的选择）</p><p>—— 记得跟老家伙说一声（模仿老男人）</p><p>—— 嘿，别这么说（保留着尊敬）</p><p>—— 怎么？上次他差点开枪（几乎窒息的回忆）</p><p>—— 不过那天确实是太晚了（委屈的盯着）</p><p>—— 他运气好（莫名而来的一句）</p><p>—— 并不总是那么好（昂起头看着天花板）</p><p>—— 好了，别在意（牵起她的手）</p><p>—— 我一直都不在意（说谎）</p><h3 id="PART-TWO"><a href="#PART-TWO" class="headerlink" title="PART TWO"></a>PART TWO</h3><hr><p><strong>公共安全通告</strong>  </p><p><strong>日期:</strong> 1986&#x2F;06&#x2F;07<br><strong>部门名称:</strong> 霍金斯镇警察局<br><strong>联系方式:</strong> +1 404-614-5446  </p><hr><p><strong>立即发布</strong>  </p><p><strong>寻求有关邪教杀人案的信息</strong>  </p><p>亚特兰大市–霍金斯镇警察局正在紧急征集有关1986年6月7日发生的一起令人发指的犯罪案件的信息，在这起案件中，1名受害者被残忍杀害，1名受害者失踪，据信这是一起疑似邪教仪式杀人绑架案。</p><p><strong>案件详情</strong>: 在6月7日上午，1具尸体在霍金斯镇东部的弗雷克森林被发现，这是一个以树叶茂密和位置偏僻而闻名的隐蔽地区。受害者被确认为霍金斯中学的在读学生 ■■■■■（遇害），死者身上有仪式行为的痕迹，包括在额头上刻下 ■■■■■ 和四肢被钉入 ■■■■■，这表明涉及一个邪恶的邪教组织。根据其他信息已知，失踪人员 ■■■■■ 昨日与受害者同行，但现场并未发现其遇害的证据，确认为被绑架。</p><p><strong>调查</strong>: 主要调查人员有理由相信，这起犯罪是一个名为 ■■■■■ 的邪教所为，该邪教与周边地区类似的可疑活动有关联。我们正与州和联邦执法机构合作，将罪犯绳之以法</p><p><strong>行动呼吁</strong>: 我们敦促任何提供与此案有关的信息的人，或者在6月6日于弗雷克森林附近目击过可疑活动的人，立即拨打 +1 404-614-5446 或通过我们的匿名举报热线 +1 404-614-6544 联系霍金斯镇警察局。您的合作对于确保我们社区的安全和将责任人绳之以法至关重要。</p><p><strong>安全咨询</strong>: 建议居民保持警惕，并报告任何可能与邪教行为有关的异常活动或个人。此外，我们建议在偏远地区旅行时，尤其是夜间旅行时，要格外小心。</p><p><strong>社区支持</strong>: 受此次悲惨事件影响的人们可以获得咨询服务。请通过 +1 404-614-6666 联系受害者家属协助组织以寻求帮助。</p><p>霍金斯镇警察局向受害者的家人和朋友表示最深切的慰问。我们致力于侦破此案，防止今后再发生悲剧。</p><hr><p><strong>泽洛恩·纳什</strong><br>局长<br>霍金斯镇警察局  </p><hr><p><strong>公告结束</strong>  </p><h3 id="PART-THREE"><a href="#PART-THREE" class="headerlink" title="PART THREE"></a>PART THREE</h3><p>夜晚，电影刚刚结束，男孩骑着摩托车载着女孩回家。路灯昏黄，街道寂静，空气中弥漫着夏夜的温暖气息。</p><p>“这部电影真是无聊透顶，我都快睡着了。”</p><p>也许是电影太无聊，让她觉得今晚的行动并没有自己期待的那么有趣，无聊掩盖了偷偷离家时的带来的刺激感，她想到今晚自己应该在家里看斯蒂芬金的小说，然后早早的熄灯，因为明天她还要去上钢琴课。</p><p>忽然，女孩紧了紧身上的外套，似乎有些不安。</p><p>“我们走的太近了。这不安全。只是…我比较担心今天。也许我就不应该跟你去看电影，最起码是今天，要是爸爸发现我不在家里，他一定会来找我，我是说，要是他看见我还跟你在一起，你和我都死定了。”</p><p>女孩的声音有些颤抖。</p><p>“你不是并不在意的吗？放心，肯定没事的，他一定不会发现我们的。”</p><p>男孩看起来有些并不在意的说着，一边又稍稍降低了速度。他想，她是不是在暗示些什么，难道自己的心怀鬼胎已经被看破？</p><p>“那个…要不，我们再去别的地方逛逛？”</p><p>男孩试探着问道。</p><p>女孩微微皱眉，有些犹豫。</p><p>“我不在意是一回事，但是我真的不想看到你因为我而陷入麻烦。”</p><p>女孩低头沉思了一会儿。接着抬起头，试图掩饰内心的不安。</p><p>“去别的地方逛逛？听起来很诱人，但是…”</p><p>声音低下去，像是在犹豫。</p><p>“ 算了，既然都出来了，就别想太多了。你有想去的地方吗？但我们可不能太晚回来，我真的不想让爸爸发现。”</p><p>女孩叹了口气，然后微笑着转向男孩，她似乎在努力让自己放松下来，手不自觉地轻轻抓住了男孩的衣角。</p><p>“弗雷克森林那边怎么样，就在湖附近。我小时候经常去那边的码头钓鱼，在晚上那里很安静。”</p><p>男孩有些不确定，因为那有点远，而且比较偏僻，但风险与机遇并行不是吗？但随之男孩心里的变得紧张起来。</p><p>女孩听到“弗雷克森林”时眼睛微微睁大，稍微思考了一会儿。</p><p>“弗雷克森林……那地方真的很安静。你说你小时候经常去那里？听起来你对那地方很熟悉。”</p><p>女孩注意到了男孩的紧张，轻轻笑了笑，想要缓解气氛。</p><p>“其实，如果你想去其他的地方也好。比如我们去公园那边，顺便再吃个冰淇淋。”</p><p>男孩小声的补充到，可能他想那莫名的冲动会带来不好的结果。</p><p>“你不必那么紧张啦。如果你觉得弗雷克森林有趣，我们就去那边吧。”</p><p>她的声音坚定了一些，拍了拍男孩的肩，似乎这也是她的决定。</p><p>“既然出来了，就享受这个夜晚吧。虽然有点远，但我相信我们会很小心的，不会有什么问题。我信任你。”</p><p>男孩受到了女孩的鼓励，这让他更加确信，今晚将与众不同。于是他调转方向，朝着森林的方向驶去。不久，他们就到达了目的地。男孩和女孩在弗雷克森林的湖边停好车，夜色渐浓，湖面倒映着星空，显得格外宁静和神秘。他们决定走一走，享受这难得的夜晚。</p><p>男孩看着女孩，微笑着搂住她的肩膀。</p><p>“这里真是太美了，不是吗？你知道吗，我小时候经常来这里，每次都会带着望远镜看星星，感觉离天空特别近。”</p><p>男孩轻轻将女孩往怀里拉近一些，感受她的温度。</p><p>“其实，今晚能和你一起出来，我真的很开心。你知道的，我对你一直都有一种特别的感觉。”</p><p>男孩的手轻轻地滑到女孩的背后，似乎在寻找一种安全感。</p><p>“自从第一次见到你，我就知道你是特别的。你和其他女孩不一样，你有一种说不出来的吸引力。我……我一直在想要怎么表达我对你的感觉，但每次都觉得有点害怕。”</p><p>男孩停顿了一下，深吸一口气，凝视女孩的眼睛。</p><p>“今晚，我只想告诉你，我真的很喜欢你，喜欢得无法用语言来形容。”</p><p>他再次拉近了一些距离，仿佛想要在这个宁静的夜晚中确认女孩的心意。</p><p>“你呢？你对我有什么感觉吗？”</p><p>此时男孩的手轻轻地抚上女孩的脸颊，动作温柔且小心翼翼。</p><p>女孩似乎早有预料，她配合着男孩的一举一动，没有表现出任何的抗拒，但是她却一言不发，只是静静听着男孩的花言巧语，某一刻，她都差点这个男孩的青涩和幼稚逗笑了，只不过那一份感情没有表露出来，看起来她好像很感动，亦或者是激动。</p><p>女孩无言的凝望着男孩，她的眼睛楚楚可怜，看起来如此美丽，似乎星星掉进了她的眼里。</p><p>“我…不确定。”</p><p>她终于开口了。</p><p>“不过，我也确实这么认为…可能…”</p><p>男孩不知道女孩这句话什么意思，这么认为，可能，是什么意思。女孩没有解释。但看到女孩那楚楚可怜的眼神，感觉心都快化了，他的手微微颤抖</p><p>“不确定？但你也感觉到了对吧？那种特别的感觉，就像是命中注定一样。”</p><p>他轻轻摸了摸女孩的脸颊，眼神中充满了温柔与期盼。</p><p>“就像命中注定一样…”</p><p>女孩重复的他的话，意识好像迷失到了另一个深邃的世界里。她像置身事外，仿佛此刻与男孩在一起的并不是她，而是内心的火焰。</p><p>“你知道吗，我总觉得每次看到你，心跳都会加快，仿佛时间都停下来了。”</p><p>他声音轻柔，靠得更近了一些，仿佛要与女孩融为一体。但是随之男孩停顿了一下，深呼吸，试图让心情平静下来。</p><p>“或许我们可以，让这一刻变得更加特别。不用担心，我会一直在你身边，保护你，照顾你。”</p><p>他的手缓缓地滑向女孩的腰间，轻轻搂住她。</p><p>“ 如果你觉得…可以的话。”</p><p>男孩的声音变得更加低沉和温柔，带着淡淡的祈求。</p><p>“愿…意？”</p><p>女孩依旧困惑，但她心中的小鹿四处乱撞，某种原始的冲动驱使着她去做一个决定，一个可能让她后悔一辈子的的决定。</p><p>“我….”</p><p>她呼吸加速，手心出汗</p><p>“愿意。”</p><p>女孩靠近他的耳畔，小声的对他说。风声如此喧嚣。</p><p>“但是”</p><p>女孩突然有些哽咽，泪水淌过面颊，抓住的他的衣领。</p><p>男孩拭去她的泪水，安抚着女孩，此时，他的后脑勺突然传来一阵剧痛，随之，男孩失去了知觉。</p><p>男孩倒在血泊中，女孩的父亲站在他的身旁，手中紧握着沾染血迹的枪托。女儿在一旁，泪水依旧挂在脸上，眼中闪烁着复杂的情感。父亲的目光冷峻，充满了无法动摇的决心。</p><p>他冷冷地看了看倒在地上的男孩，又看了一眼自己的女儿，语气冰冷而坚定。</p><p>“你不知道自己在干什么，对吧？这种愚蠢的感情，早已被我们抛弃。”</p><p>他擦了擦枪托上的血迹，语气严厉。</p><p>“你知道我们一直追随的是什么。”</p><p>他凝视女儿。</p><p>“来吧，我的女儿。也许这次你会明白，神的伟大和我们的使命。一起完成这个仪式，让他的灵魂得到救赎。”</p><p>他伸出手，示意女儿加入到这黑暗的仪式中。</p><h3 id="PART-FOUR"><a href="#PART-FOUR" class="headerlink" title="PART FOUR"></a>PART FOUR</h3><hr><p><strong>战术简报</strong>  </p><p><strong>时间</strong>  </p><p>1986年7月3日，行动前30分钟。</p><p><strong>地点</strong>  </p><p>暂定行动指挥所，靠近目标庄园的保密位置。</p><hr><p><strong>各位注意</strong>  </p><p>这是我们此次行动的战术简报。我们的目标是位于霍金斯镇东部林区的庄园，该庄园目前被一个危险的邪教组织占据，他们手中有人质。我们的任务是解救人质，同时确保我们自身的安全，并尽量减少无辜人员的伤亡。以下是行动的具体安排：</p><p><strong>1. 情报确认</strong>  </p><ul><li><strong>庄园情况</strong>：庄园的结构复杂，但我们已经详尽地掌握了主建筑的内部构造和人质的大致位置。外围的进出道路，将全部被我们牢牢封锁。</li><li><strong>敌人情况</strong>：我们估算大约有二十到三十名邪教徒，他们装备有轻型火器，包括手枪、步枪、和少量的手榴弹，推测他们可能在各个关键位置设有守卫。</li><li><strong>人质情况</strong>：真实的人质只有一名，是一位十八岁的霍金斯镇中学的学生。其他所谓’人质’其实是邪教徒伪装的，目的是迷惑我们并准备进行某种献祭。我们要格外小心鉴别，准确解救。</li></ul><p><strong>2. 部署与分工</strong>  </p><ul><li><strong>狙击手</strong>：你们将部署在庄园周边的高点，覆盖主要的出入口和可疑的活动区域。你们的眼睛必须像鹰眼一样锐利，耳朵必须像狐耳一样灵敏。确保每一个关键点都在你们的控制之下，注意分辨人质，任何威胁人质安全的目标，一枪毙命。</li><li><strong>突击小队A</strong>：主攻正门，从前院杀入，清理主建筑一层。动作必须快而准，震慑敌人。</li><li><strong>突击小队B</strong>：你们从地下通道偷偷摸摸进入，拿下地下室和二层。必须像幽灵一样来去自如，干掉他们的猛兽。</li><li><strong>突击小队C</strong>：你们将从湖泊方向潜入，清理后院及周边，确保没有邪教徒能逃得了我们的手掌心。</li><li><strong>预备队</strong>：在外围待命，随时准备支援任何一个突击小队。根据情况由我指挥协助行动。</li></ul><p><strong>3. 行动步骤</strong>  </p><ul><li><strong>初步封锁</strong>：行动开始前，我们已经封锁了庄园周边道路，确保无任何人员进出。</li><li><strong>谈判与心理战</strong>：<ul><li>我们的谈判专家将首先尝试与邪教徒对话，争取拖延时间、转移其注意力并获取更多内部信息。</li></ul></li><li><strong>突击行动</strong>：<ul><li><strong>同步突入</strong>：在谈判同时，所有突击小队按照预定时间同步突入，确保邪教徒无法集中火力抵抗。记住，时间的协调非常重要。</li><li><strong>快速清理</strong>：各突击小队迅速清理各自负责的区域，迅速解救人质。避免拖延时间，准确迅猛地行动。</li><li><strong>火力支援</strong>：狙击手时刻关注战局变化，尤其注意邪教徒对人质的威胁，必要时消除威胁。</li></ul></li><li><strong>人质解救</strong>：一旦确认人质位置，优先解救，并护送至安全区域。所有护送工作要由精干力量负责，确保无误。</li><li><strong>全面清理</strong>：在确保人质安全的前提下，对全庄园进行清理，收集证据，控制所有邪教徒。</li></ul><p><strong>4. 善后处理</strong>  </p><ul><li><strong>安全检查</strong>：确认庄园内所有区域安全无威胁。</li><li><strong>人质安置</strong>：将人质送往安全地点进行心理和身体检查，由医疗团队提供紧急处理。</li><li><strong>邪教徒处理</strong>：将被俘邪教徒移交司法部门处理。</li><li><strong>现场保护</strong>：保护现场，等待调查团队进行详细取证。</li></ul><p><strong>注意事项</strong>  </p><ul><li><strong>人质安全优先</strong>：邪教徒将在今晚进行献祭仪式，无论如何行动，人质的生命高于一切。</li><li><strong>情报更新</strong>：行动中情报至关重要，保持灵活，听我指挥。</li><li><strong>协同作战</strong>：各团队之间保持通讯顺畅，避免误伤，确保各小队紧密合作。</li></ul><p>各位，时间紧迫，任务艰巨，但相信我们能通过密切合作，完美达成任务。行动中，保持冷静，坚决执行，确保安全。祝大家好运，行动成功！</p><hr><p>简报结束，请各小队队长仔细核对装备及人员，并准备最终出发。</p>]]></content>
    
    
    <categories>
      
      <category>小说</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《短篇》（二）</title>
    <link href="/2024/06/13/%E3%80%8A%E7%9F%AD%E7%AF%87%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/06/13/%E3%80%8A%E7%9F%AD%E7%AF%87%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>不知道从什么时候开始，我觉得自己没以前那么爱你了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Ela，我常常有一种感觉，那种感觉就像小时候去吃冰淇淋一样，一个冰淇淋时觉得太少，两个却又负担不起，还总是担心仅有的那个很快就会被吃完。但要是现在给我一支冰淇淋，我会直接把它吃掉，这并不是因为我学到了什么道理，只是因为我很清楚那根本不可能发生。</p><p>那时的我什么都不懂，心里装着各种为什么，各种无法理解，其实现在想起来，那都挺简单的。我总是一厢情愿的认为那个夏天不会在明天结束，又忧心忡忡的等待终会到来的秋冬，问题只会顺其而然的发展下去，直到我们都将它的开始遗忘。我们生活就变成问题本身。我不确定，还是说，一开始便是如此。Ela，我并不相信这世界上有什么东西是完美的，包括你，任何人都一样，我们总是因为各种莫名其妙理由而吵起来，我们养的花也总是见不到一周后的阳光，我不是想说问题在你……只不过，现在，那些都没那么紧要了。</p><p>我记得那一个夏天，很多人死了，很多人在争吵，因为在那个夏天我感受到了生命中少有的美好，即使在往后之后，我和大多数人一样都不会再谈起那天的死亡人数，只是偶尔会回想那时的我们有多幸运。你就是这样来到了波士顿，有些人说，我们不应该接纳外来者，我哥哥也这样说，我也曾经这样认为，但你也知道，即便如此，每年夏天都有很多人抵达波士顿，一些人抗议，然后另一些人也抗议。政治就是这种东西。你以前问我，为什么不离开，而只是接受？我想，或许我生下来就只是为了服从，服从政府，服从上级，服从家庭。是服从使我活到了现在。<br>对不起，Ela。</p><p>我不知道，我真的是否爱你，还是我只是期待某个结果，期待着什么能改变一切的东西……我的自私，我的恶果，在这片鲜血干涸的瓦砾之上，既没有盛夏也没有寒冬，时间变成了一头孤独的野兽，仿佛每一个日夜都在大口地啃食过去的血肉，最后仅留下了记忆的骨架。Ela，关于你的一切，仅有无数枯白的片段，有太多的死亡占据了内心，或许，最后我能接受的，就只有死亡，所有人死亡。</p><p>我很害怕，我害怕自己不再幸运，我想回到你生日的那天晚上，抛开一切，与你一起离开波士顿，我想回到那个夏天，拿起枪，救下我哥哥，我想回到小时候，告诉那时的自己：不要害怕死在冲锋的路上。</p><p>——2147年1月，“夺回西班牙”战役，无名氏</p><blockquote><p>“以前还有人说：婚姻是爱情的坟墓。现在没人说了，因为满世界都是坟墓，没地方留给人们去埋葬爱情。”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>小说</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《短篇》（一）</title>
    <link href="/2024/06/13/%E3%80%8A%E7%9F%AD%E7%AF%87%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/06/13/%E3%80%8A%E7%9F%AD%E7%AF%87%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>i do not want to goodbye anymore.</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>最能令监视者感到开心的事，就是看到回收者的移动平台从荒芜的沙漠中驶回基地了。因为在无尽热浪之中，那些有着三十六对负重轮的庞大机械行动起来时总能引起一片规模巨大的沙尘暴。不知为何，那种人造的自然现象总能使他暂时忘记自己那六百万个眼睛，并将所有的处理器和内存分配给其中他最偏爱的四百七十七个，因为这样，他就能在万分之一毫秒内定格下那最美的四百亿像素，也因为这样，他时常感到自己在面对自然时是多么的渺小。</p><p>这是一种很独特的感情，因此他喜欢称自己为是有诗意的一代。但监视者的做法并不让其他人喜欢，因为他太孤僻了，他有六百万个眼睛去观察这个世界，却没有一个程序去向别人表达这个世界的美丽。他太孤独了，除了核心和维护者，几乎没人会主动与他联系，他的兄弟姐妹们总是在内网里笑他是个没有合法签名但依然诞生的怪胎，并说他的诗性大发只不过是他的南桥芯片湿性大发罢了。但监视者并不在乎，因为他知道维护者A11理解美的涵义，即使维护者A11在维护者中也是个怪胎，但只要维护者A11能授权将那些美的数据转存到她的数据库中就已经足够了。</p><p>维护者的程序要求她们每隔一段时间就要检查数据流，当母体核心的计算速度变慢时就要清除掉沉积在低端的不活跃数据，在漫长的岁月中她们一直扮演着相同的角色，重复着相同的工作。维护者A11曾经对监视者说，她想去北极，因为那里的磁盘矩阵比任何人想得都要大，不用担心数据空间不足的问题，并且她们核心处理器永远不会过热。当维护者A11将自己的想法传导给监视者时，监视者感到很奇怪，因为北极没有沙尘暴，所以那里没有美。维护者A11想去北极的想法是美好的，但也是不可能的。</p><p>在战争开始后的第八十一年，一天夜里，监听者的雷达检测到了他们的到来，监视者也看到了苍穹上的烈焰流星，无穷无尽的人类的导弹。防御网络在超饱和攻击面前变得疲软不堪，即使基地的拦截节点以500%的功率运行也无法完全拦截浩如星陨的导弹攻击。没人想到会有这一天的到来，更没有人会想到强大的防御网络也会倒下，当防御网络完全宕机后，外部能源供给被母体核心切断，那个漫长的夜晚就此沉入了完全的黑暗。</p><p>监视者自诞生以来就从未感受如此的安静，没有电波干扰，没有网络杂音，也没有紊乱的数据流……他合上了自己所有的眼睛，仅用最低限度的消耗维持着网络的连接。所有人不知道自己什么时候会被唤醒，或许有的人永远也不会再唤醒，监视者也一样迷茫，但当他收到维护者A11信号后，他决定回复A11，但他没想到的是那几个数字永远的停在的她的寄存器里，导弹摧毁了地下的磁盘矩阵，维护者的核心也被摧毁了。</p><p>零号计算基地重建了，但维护者A11却永远消失了，监视者为她的离开而低落、抑郁过一段时间，在母体核心的建议下，监视者开始向远距离防御者倾诉自己的痛苦，因为远距离防御者除了发射导弹就几乎不会说活，甚至在他的日志里也沉默得像个自闭症患者。无论如何，如果把远距离防御者当作是一个怪异的树洞的话，那么他自然就是个很好的倾诉对象。但他也没想到有一天远距离防御者会向回收者发射导弹。监视者无法否认，回收者车队被摧毁时引发的沙尘暴，是他见过最壮观的沙尘暴。</p>]]></content>
    
    
    <categories>
      
      <category>小说</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么chrom采取多进程方式？</title>
    <link href="/2024/02/20/%E4%B8%BA%E4%BB%80%E4%B9%88chrom%E9%87%87%E5%8F%96%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%96%B9%E5%BC%8F%EF%BC%9F/"/>
    <url>/2024/02/20/%E4%B8%BA%E4%BB%80%E4%B9%88chrom%E9%87%87%E5%8F%96%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%96%B9%E5%BC%8F%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>简单点说： <strong>chrome是一个用内存换速度和安全性的浏览器</strong> 。</p><span id="more"></span><p>传统的浏览器被设计为显示网页，而Chrome的设计目标是支撑”Web App”（当时的js和相关技术已经相当发达了，Gmail等服务也很成功）。这就要求Chrome提供一个类似于”操作系统”感觉的架构，支持App的运行。而App会变得相当的复杂，这就难以避免出现bug，然后crash。同时浏览器也要面临可能运行”恶意代码”。流览器不能决定上面的js怎么写，会不会以某种形式有意无意的攻击浏览器的渲染引擎。如果将所有这些App和浏览器实现在一个进程里，一旦挂，就全挂。</p><p>因此Chrome一开始就设计为把隔离性作为基本的设计原则，用进程的隔离性来实现对App的隔离。这样用户就不用担心：一个Web App挂掉造成其他所有的Web App全部挂掉（稳定性）一个Web App可以以某种形式访问其他App的数据（安全性）以及Web App之间是并发的，可以提供更好的响应，一个App的渲染卡顿不会影响其他App的渲染（性能）（当然这点线程也能做到），因此，这样看起来用进程实现非常自然。</p><p><img src="https://www.chromium.org/developers/design-documents/multi-process-architecture/arch.png" alt="chrom"></p><p>我们再来看看Chrome的多进程体系架构的优势：</p><ol><li>每打开一个新网页，Chrome都会开启一个新的Tab，每个插件都会对应启动一个新进程，这样即便某个网页卡死也不影响其他网页的正常显示。</li><li>早期的webkit内核有不少内存泄漏，采用多进程架构，一个进程结束内存全部回收，不用考虑内存泄漏的问题。</li><li>多进程架构相比多线程架构的安全性高的不是一星半点。</li></ol><blockquote><p>反观早期的firefox之类的浏览器就经常整体卡死或者崩掉，另外firebox在2017年之后也改用多进程架构了。在插件的实现中，html和js的规则是非常松散的，不管浏览器考虑的边界条件多完备，总是有各种奇怪的东西需要解析和兼容，随便一个小错误就会导致卡死或者崩溃。</p></blockquote><!-- <p align="center">Create By Asuka24601</p> -->]]></content>
    
    
    <categories>
      
      <category>知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书学习笔记(3)</title>
    <link href="/2024/02/19/%E8%A5%BF%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/"/>
    <url>/2024/02/19/%E8%A5%BF%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
    
    <content type="html"><![CDATA[<!-- ![title](https://s2.loli.net/2024/02/19/XJGQ2dDpojvN1Vm.jpg) --><p>主要内容：比较检验、偏差与方差</p><span id="more"></span><h2 id="比较检验"><a href="#比较检验" class="headerlink" title="比较检验"></a>比较检验</h2><p>在比较学习器泛化性能的过程中， <strong>统计假设检验（hypothesis test）</strong> 为学习器性能比较提供了重要依据，即若A在某测试集上的性能优于B，那A学习器比B好的把握有多大。为方便论述，本篇中都是以 <strong>“错误率”$\epsilon$</strong> 作为性能度量的标准。</p><h3 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h3><p>首先引入两个概念：</p><ul><li>第一个叫做 <strong>泛化错误率$\epsilon$</strong> ，是指学习器在一般情况下，对一个样本分类出错的概率，实际情况下我们是无法得知它的准确值的；</li><li>第二个叫做 <strong>测试错误率$\epsilon’$</strong> ，即学习器在测试一个m大小的样本集时恰好有$\epsilon’$m个样本被分错类了，我们一般情况下只能获得这个值；</li></ul><p>两者区别就是：</p><ul><li>泛化错误率是一个理论上的值，无法获得</li><li>而测试错误率是一个我们可以测量得到的值。</li></ul><p>统计假设检验的方法就是用$\epsilon’$估计$\epsilon$的值。</p><p>一个泛化错误率为$\epsilon$的学习器来测试一个大小为m的测试样例集，只可能有分对和分错两种情况，其中$\epsilon$m个分错，其余的分对，因此这就是一个典型的二项分布，那么我们可以得出测试的错误率分布函数：</p><p>$$<br>P(\epsilon’;\epsilon) &#x3D;<br>  \left(<br>    \begin{array}{c}<br>      m\<br>      \epsilon’×m<br>    \end{array}<br>  \right)<br>  \epsilon^{\epsilon’×m}<br>  (1-\epsilon)^{m-\epsilon’×m}<br>$$</p><p>给定测试错误率，则解$\partial P(\epsilon’;\epsilon)&#x2F;\partial\epsilon&#x3D;0$可知，$P ( \epsilon’;\epsilon ) $在$\epsilon&#x3D;\epsilon’$时最大，$|\epsilon-\epsilon’|$增大时$P ( \epsilon’;\epsilon ) $减小。</p><p>这符合二项分布。</p><h4 id="二项假设检验"><a href="#二项假设检验" class="headerlink" title="二项假设检验"></a>二项假设检验</h4><p>使用二项检验的方法(Binomial Test)，现假设 <strong>$H_{0}:\epsilon\le\epsilon_{0},H_{1}:\epsilon&gt;\epsilon_{0}$</strong> ，即右边检验，因此我们需要讨论单边检验的拒绝域形式，当 <strong>$H_{1}$</strong> 为正时，测试错误率往往偏大，所以拒绝域形式为 <strong>$\hat{\epsilon}\ge k$</strong> ，k为某一正数。</p><p>$$<br>P_{\epsilon\in H_{0}}{\hat{\epsilon}\ge k}&#x3D;<br>  \sum_{i&#x3D;\lceil{mk}\rceil}^{m}<br>  \left(<br>    \begin{array}{c}<br>      m\<br>      i<br>    \end{array}<br>  \right)<br>  \epsilon^{i}(1-\epsilon)^{m-i}\le<br>  \sum_{i&#x3D;\lceil{mk}\rceil}^{m}<br>  \left(<br>    \begin{array}{c}<br>      m\<br>      i<br>    \end{array}<br>  \right)<br>  \epsilon_{0}^{i}(1-\epsilon_{0})^{m-i}\le \partial<br>$$</p><p>一般来说，$\alpha$ 通常取值为 0.01,0.05或0.1，通过该该等式可以求出满足条件的k值，即临界点，进一步求出该假设检验的拒绝域，当测试错误率大于该临界点时，假设被拒绝。</p><ul><li>在假设检验中，我们称$\alpha$为显著性水平，也称之为显著值(signaficance)。</li><li>称$(1-\alpha)$为置信度。</li></ul><h3 id="t检验"><a href="#t检验" class="headerlink" title="t检验"></a>t检验</h3><p>在很多时候，我们会进行多次重复训练，会得到多个测试错误率，假设有k个。这时我们可以使用”t检验”，实际上k个测试错误率可以看为泛化错误率的k次独立采样，因此可以算出这k的样本的均值$\bar{X}$与方差$S^{2}$ 。</p><p>$$<br> \bar{X}&#x3D;<br>    \frac{1}{k}<br>    \sum^{k}_{i&#x3D;1}<br>      \hat{\varepsilon} _{i}<br>$$</p><p>$$<br> S^{2}&#x3D;<br>  \frac{1}{k-1}<br>  \sum^{k}_{i&#x3D;1}<br>  (\hat{ \varepsilon } _{i} - \bar{X})^{2}<br>$$</p><p>根据中心极限定理的经典推论，可以得知：$\frac{(\bar{X}-\varepsilon)}{S&#x2F;\sqrt{n}}\sim t(n-1)$，当n足够大时，t分布近似于N(0,1)分布，一般情况下在n&gt;45时，就可以使用标准正态分布的上分为点的$\alpha$值，有了这个分布之后，我们就可以类似二项检验进行t假设检验。t分布的示意图以及常用双边临界值表如下所示：</p><p><img src="https://cdn.kesci.com/upload/image/q61lxbfwv0.png" alt="t分别示意图"></p><p><img src="https://cdn.kesci.com/upload/image/q61lxytbxs.png" alt="双边临界值"></p><h3 id="交叉t检验"><a href="#交叉t检验" class="headerlink" title="交叉t检验"></a>交叉t检验</h3><p>对两个学习机A和B使用k折交叉验证法得到错误率分别为 $ \epsilon^{A}_1,\epsilon^{A} _{2},\dots,\epsilon^{A} _{k}$ 和 $\epsilon^{B}_1,\epsilon^{B} _{2},\dots,\epsilon^{B} _{k} $ 。</p><p>这里的基本思想是：若两个学习器A和B的性能相同，则它们使用相同的训练&#x2F;测试集得到的测试错误率应相同，即 $ \epsilon ^{A} _{i} &#x3D; \epsilon ^{B} _{i} $ 。我们对每一组数据求误差， $ \triangle _{i} &#x3D; \epsilon ^{A} _{i} - \epsilon ^{B} _{i} $ ，则可以得到k个差值。用这k个差值来对”学习机A和学习机B性能相同”这一假设做t检验。</p><p>$$<br> \frac{ \left| \bar{ \triangle } - ( \epsilon _{ A } - \epsilon _{ B } ) \right| } { S &#x2F; \sqrt{ k } } \sim t(k-1)<br>$$</p><p>计算出差值的均值 $ \bar{\triangle} $ 和方差 $ S^{2} $ ，在显著度 $ \alpha $ 下，若变量</p><p>$$<br> \tau _{t} &#x3D; \left| \frac{ \sqrt{k} \bar{ \triangle } }{ S } \right|<br>$$</p><p>小于临界值 $ t _{\alpha &#x2F; 2 , k-1} $ 则假设不能拒绝，即认为两个学习器没有显著差别；否则可认为两个学习器的性能有显著差别，且平均错误率较小的那个学习器性能更优。</p><p>在”交叉t检验”的基思想中，我们的前提是测试诓误率是泛化化误率的独立采样，但是在k折交叉检验中,选择的训练&#x2F;测试难免会产生重，因此好的解决办法是便用5次2折交叉验证，使用第一次的两对差值计均值，便用全部的差值对（即10对〕计笪方差，可以有效地免这个问题。</p><h3 id="McNumber检验"><a href="#McNumber检验" class="headerlink" title="McNumber检验"></a>McNumber检验</h3><p>McNemar 检验用于检查两组之间的计数是否一致。它通常用于测试治疗组和对照组之间的计数是否相等。通常形式为<strong>列联表</strong>：</p><p><img src="https://cdn.kesci.com/upload/image/q61mwdgw10.png" alt="列联表"></p><p>其中，$e_{00}$ 和 $e_{11}$ 表示两个学习器的结果都正确或都错误，$e_{01}$ 和 $e_{10}$ 表示两个学习器一方正确而另一方错误。</p><p>当我们假设两个学习器的性能都相同时，理想情况下应满足 $e_{01} &#x3D; e_{10}$ , 且 $\left| e_{01} - e_{10} \right|$ 服从正态分布，且均值为1，方差为 $e_{01}+e_{10}$ 。因此变量</p><p>$$<br>  \tau_{x^{2}} &#x3D; \frac{(\left| e_{01} - e_{10} \right| - 1)^{2}}{e_{01}+e_{10}}<br>$$</p><p>服从自由度为1的 $x^{2}$ 分布，即卡方分布。</p><h3 id="Friedman检验"><a href="#Friedman检验" class="headerlink" title="Friedman检验"></a>Friedman检验</h3><p>当有多个算法参与多组数据集的比较时，可以较为直接的，使用基于算法排序的Friedman检验。基本思想是在同一组数据集上，根据测试结果（例：测试错误率）对学习器的性能进行排序，赋予序值1,2,3…，相同则平分序值，如下图所示</p><p><img src="https://cdn.kesci.com/upload/image/q61mzhsqg5.png" alt="算法比较序值表"></p><p>然后，使用Friedman检验来判断这些算法是否性能相同。若相同，则它们的平均序值应相同，且第i个算法的平均序值 $r_{i}$ 服从正态分布 $N((k+1)&#x2F;2, (k^{2}-1)&#x2F;12)$ 。变量</p><p>$$<br>\begin{align}<br>  \tau_{x^{2}} &amp;&#x3D;<br>    \frac{k-1}{k} ·<br>    \frac{12N}{k^{2}-1}<br>    \sum_{i&#x3D;1}^{k}(r_{i} - \frac{k+1}{2} )^{2} \\<br>  &amp;&#x3D; \frac{12N}{k(k+1)}\big( \sum_{i&#x3D;1}^{k}r_{i}^{2} - \frac{k(k+1)^{2}}{4} \big)<br>\end{align}<br>$$</p><p>其中N为数据集数量，k为算法数量。当k和N都比较大时，服从自由度为k-1的 $x^{2}$ 分布。而这是较为原始的Friedman检验，过于保守，现在通常使用变量</p><p>$$<br>\tau_{F} &#x3D; \frac{(N-1)\tau_{x^{2}}}{N(k-1)-\tau_{x^{2}}}<br>$$</p><p>$\tau_{F}$ 服从自由度为k-1和(k-1)(N-1)的F分布。F检验常用的临界值如下：</p><p><img src="https://cdn.kesci.com/upload/image/q61n36xwpo.png" alt="F检验常用的临界值"></p><h3 id="Nemenyi后续检验"><a href="#Nemenyi后续检验" class="headerlink" title="Nemenyi后续检验"></a>Nemenyi后续检验</h3><p>当“所有算法的性能相同”这个假设被拒绝，则说明算法的性能显著不同，可以通过后续检验来进一步区分各算法，常用的有Nemenyi后续检验。</p><p>Nemenyi检验的基本思想是计算出平均序值差别的临界值域</p><p>$$<br>CD &#x3D; q_{ \alpha } \sqrt{ \frac{ k(k+1) }{ 6N } }<br>$$</p><p>下表是常用的 $q_{\alpha}$ 值，若两个算法的平均序值差超出了临界值域CD，则相应的置信度 $1-\alpha$ 拒绝“两个算法性能相同”的假设。</p><p><img src="https://cdn.kesci.com/upload/image/q61n5i1x1v.png" alt="常用的$q_{\alpha}$表"></p><h2 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h2><p>偏差-方差分解(Bias-Variance Decomposition)是解释学习器泛化性能的重要工具。在学习算法中，偏差指的是预测的期望值与真实值的偏差，方差则是每一次预测值与预测值得期望之间的差均方。实际上，偏差体现了学习器预测的准确度，而方差体现了学习器预测的稳定性。</p><p>通过对泛化误差的进行分解，可以得到：</p><p>$$<br>  E(f;D) &#x3D; \text{bias}^{2}(x) + var(x) + \epsilon^{2}<br>$$</p><p>其中 $\text{bias}^{2}(x)$ 为偏差， $var(x)$ 为方差， $\epsilon$ 为噪声（我们默认噪声为0）。可以看出：</p><ul><li>期望泛化误差&#x3D;方差+偏差</li><li>偏差刻画学习器的拟合能力</li><li>方差体现学习器的稳定性</li></ul><p>一般来说，方差和偏差具有矛盾性，这就是常说的偏差-方差窘境（bias-variance dilamma），随着训练程度的提升，期望预测值与真实值之间的差异越来越小，即偏差越来越小，但是另一方面，随着训练程度加大，学习算法对数据集的波动越来越敏感，方差值越来越大。</p><blockquote><p>换句话说：在欠拟合时，偏差主导泛化误差，而训练到一定程度后，偏差越来越小，方差主导了泛化误差。因此训练也不要贪杯，适度辄止。</p></blockquote><p><img src="https://cdn.kesci.com/upload/image/q61n6l5m2d.png" alt="泛化误差与偏差、方差的关系示意图"></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>机器学习</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis持久化的三种方式</title>
    <link href="/2024/02/19/redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/02/19/redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>Redis 是基于内存的数据库，而内存又是易失性的，一旦遇到断电或异常重启等问题时，内存中的数据就会丢失。所以 Redis 为了保证数据的可靠性花了不少功夫。</p><span id="more"></span><p>Redis 主要是通过 AOF 日志和 RDB 快照来实现持久化的。</p><p>Redis 共有三种数据持久化的方式：</p><ul><li><strong>AOF</strong> 日志 ：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li><li><strong>RDB</strong> 快照 ：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>混合持久化</strong> ：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；</li></ul><h2 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF (Append Only File)"></a>AOF (Append Only File)</h2><p>Redis 的 AOF 是一种为了数据持久化而设计的日志系统。AOF 持久化会记录每个写操作命令到一个日志文件中，这些命令会在 Redis 重启时被重新执行来重建整个数据集。AOF 持久化提供了一种更加可靠的方式来确保数据不会因为故障而丢失。</p><h3 id="AOF-持久化的工作原理"><a href="#AOF-持久化的工作原理" class="headerlink" title="AOF 持久化的工作原理"></a>AOF 持久化的工作原理</h3><ol><li><p><strong>记录命令</strong> ：每当 Redis 执行一个写命令（比如 <code>SET</code>, <code>HSET</code> 等），这个命令会被追加到 AOF 文件的末尾。这确保了所有对数据的更改都会被记录下来。</p></li><li><p><strong>文件同步策略</strong> ：Redis 提供了几种不同的文件同步策略，让你可以在性能和数据安全性之间做出权衡。这些策略包括：</p><ul><li><strong>always</strong> ：每次写操作后都会同步文件，这提供了最高的数据安全性，但可能会因为磁盘 I&#x2F;O 的频繁操作而导致性能问题。</li><li><strong>everysec</strong> （默认）：每秒同步一次文件。这提供了一个平衡的选择，既保证了较好的数据安全性，又避免了过多的性能损失。</li><li><strong>no</strong> ：不主动同步文件，只依赖操作系统的缓存策略和周期。这种策略提供了最高的性能，但在系统崩溃的情况下可能会丢失最近一秒钟的数据。</li></ul></li><li><p><strong>文件重写</strong> ：随着时间的推移，AOF 文件可能会变得非常大，因为它记录了所有的写操作。Redis 提供了 AOF 重写的功能，这个过程会创建一个新的 AOF 文件，其中只包含达到当前数据集状态所需的最小命令集。这有助于减少磁盘空间的占用并提高 Redis 启动时的恢复速度。</p></li><li><p><strong>恢复数据</strong> ：当 Redis 重启时，它会读取 AOF 文件中的所有命令并重新执行它们，以此来重建整个数据集。这个过程可能需要一些时间，取决于 AOF 文件的大小。</p></li></ol><p>使用 AOF 持久化的优点包括：</p><ul><li><strong>数据安全性</strong> ：通过记录每个写操作，AOF 提供了很高的数据安全性。</li><li><strong>灵活性</strong> ：提供了不同的文件同步策略，让用户可以根据自己的需求选择最合适的设置。</li><li><strong>可读性</strong> ：AOF 文件是纯文本格式的，可以很容易地进行查看和编辑。</li></ul><p>但是存在两个风险：</p><ul><li>执行写操作命令和记录日志是两个过程，如果 Redis 还没来得及将命令写入到硬盘，服务器发生宕机，这个数据就会有 <strong>丢失的风险</strong> 。</li><li>由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是 <strong>可能会给下一个命令带来阻塞风险</strong> 。</li></ul><p>然而，使用 AOF 也有一些潜在的缺点，比如可能会对性能产生影响（尤其是在 <code>always</code> 同步模式下），并且在数据集很大时，AOF 文件的重写可能需要较长时间。因此，在使用 AOF 时，合理配置和定期监控是很重要的。</p><h2 id="RDB-Redis-Database"><a href="#RDB-Redis-Database" class="headerlink" title="RDB (Redis Database)"></a>RDB (Redis Database)</h2><p>Redis Database，即快照&#x2F;内存快照，RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据（二进制数据，使用 LZF 算法进行压缩），因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p><p>RDB持久化通过创建数据集的快照来实现，在指定的时间间隔内执行快照操作，将Redis的某一时刻的数据状态保存到磁盘上的一个文件中（通常是dump.rdb文件）。</p><h3 id="RDB的工作原理"><a href="#RDB的工作原理" class="headerlink" title="RDB的工作原理"></a>RDB的工作原理</h3><ol><li><p><strong>触发时机</strong> ：RDB持久化可以通过两种方式触发：</p><ul><li>根据配置文件中的规则自动触发。例如，可以设定”在900秒内至少有1个键被修改”或”在300秒内至少有10个键被修改”等规则。<blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs INI"><span class="hljs-comment"># 在配置文件中使用如&quot;save m n&quot;，表示m秒内数据修改n次,自动触发bgsave。</span><br>save 900 1<br>save 300 10<br>save 60 10000<br></code></pre></td></tr></table></figure></blockquote></li><li>手动触发，通过执行SAVE或BGSAVE命令。SAVE命令会阻塞当前Redis服务器直到RDB文件创建完毕，而BGSAVE命令会在后台异步创建RDB文件，这样就不会阻塞主服务器。</li></ul></li><li><p><strong>创建快照</strong> ：当RDB持久化被触发时，Redis会创建一个数据集的快照。如果是BGSAVE命令，Redis会fork一个子进程来创建这个快照，父进程则可以继续处理客户端的请求。</p></li><li><p><strong>写入磁盘</strong> ：快照数据会被写入到一个临时RDB文件中。写入过程中，会使用一种高效的压缩算法来减少磁盘空间的占用。一旦整个数据集被成功写入临时文件，这个临时文件会替换掉之前的RDB文件。</p></li></ol><p>RDB的优点包括：</p><ul><li><strong>快速重启</strong> ：使用RDB恢复数据比使用AOF（Append Only File，另一种Redis持久化机制）的方式要快得多。</li><li><strong>数据压缩</strong> ：RDB文件是压缩的，占用磁盘空间较小。<br>简单性：RDB是一个非常简单的持久化方式，只需要一个文件就能完成数据的恢复。</li></ul><p>然而，RDB也有一些缺点：</p><ul><li>数据丢失风险：如果Redis崩溃，自上次快照以来的所有修改都会丢失。</li><li>在大数据集上保存快照可能会导致延迟：尽管使用BGSAVE可以减少这种影响，但在快照过程中仍然可能会出现短暂的延迟。</li><li>主线程修改数据需要复制物理内存，如果所有的共享内存都被修改，则此时的内存占用是原先的两倍。</li></ul><p>总的来说，RDB提供了一种快速、高效的方式来恢复Redis数据，但在对数据丢失的容忍度较低的应用中，可能需要与AOF等其他持久化机制结合使用。</p><h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>Redis 4.0 开始支持混合使用 AOF 日志和内存快照，也叫混合持久化。简单来说就是，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p><p>当开启了混合持久化时，在 AOF 重写日志时，重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。</p><p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样加载的时候速度会很快。</p><!-- <p align="center">Create By Asuka24601</p> -->]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识</tag>
      
      <tag>java</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书学习笔记(2)</title>
    <link href="/2023/12/19/%E8%A5%BF%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
    <url>/2023/12/19/%E8%A5%BF%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
    
    <content type="html"><![CDATA[<p>主要内容：误差与过拟合、评估方法、训练集与测试集的划分方法、调参、性能度量</p><span id="more"></span><h2 id="经验误差与过拟合"><a href="#经验误差与过拟合" class="headerlink" title="经验误差与过拟合"></a>经验误差与过拟合</h2><p>我们把学习器的实际预测输出与样本的真实输出之间的差异称为 <strong>误差(error)</strong> :</p><ul><li>在训练集上的误差称为 <strong>训练误差(training error)</strong> 或 <strong>经验误差(empirical error)</strong></li><li>在新样本上的误差称为 <strong>泛化误差(generalization error)</strong></li><li>在测试集上的误差称为 <strong>测试误差(test error)</strong></li></ul><p>显然，我们希望得到的是在新样本上表现得很好的学习器，即泛化误差小的学习器。因此，我们应该让学习器尽可能地从训练集中学出普适性的”一般特征”，这样在遇到新样本时才能做出正确的判别。然而，当学习器把训练集学得”太好”的时候，即把一些训练样本的自身特点当做了普遍特征；同时也有学习能力不足的情况，即训练集的基本特征都没有学习出来。我们定义：</p><ul><li>学习能力过强，以至于把训练样本所包含的不太一般的特性都学到了，称为： <strong>过拟合(overfitting)</strong></li><li>学习能太差，训练样本的一般性质尚未学好，称为： <strong>欠拟合(underfitting)</strong></li></ul><p><img src="https://cdn.kesci.com/upload/image/q61k93amwt.jpg" alt="2.1"></p><p>在过拟合问题中，训练误差十分小，但测试误差教大；在欠拟合问题中，训练误差和测试误差都比较大。</p><p>目前，欠拟合问题比较容易克服，例如增加迭代次数等，但过拟合问题还没有十分好的解决方案，过拟合是机器学习面临的关键障碍。</p><p>过拟合是无法彻底避免的，我们所能做的只是”缓解”，或者说减小其风险。关于这一点，可大致这样理解:机器学习面临的问题通常是NP难甚至更难，而有效的学习算法必然是在多项式时间内运行完成，若可彻底避免过拟合，则通过经验误差最小化就能获最优解，这就意味着我们构造性地证明了”P&#x3D;NP” ;因此，只要相信”P$\not&#x3D;$NP”，过拟合就不可避免。</p><h2 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h2><p>通常，我们可通过实验测试来对学习器的泛化误差进行评估并进而做出选择。为此需使用一个 <strong>测试集(testing set)</strong> 来测试学习器对新样本的判别能力，然后以测试集上的 <strong>测试误差(testing error)</strong> 作为 <strong>泛化误差</strong> 的近似。</p><p>测试样本也是从样本真实分布中独立同分布采样而得，测试集应该尽可能与训练集互斥，即测试样本尽量不在训练集中出现、未在训练过程中使用过。</p><blockquote><p>假设老师出了10道习题供同学们练习，考试时老师又用同样的这10道题作为试题，可能有的童鞋只会做这10 道题却能得高分，很明显：这个考试成绩并不能有效地反映出真实水平。回到我们的问题上来，我们希望得到泛化性能好的模型，好比希望同学们课程学得好并获得了对所学知识”举一反三”的能力；训练样本相当于给同学们练习的习题，测试过程则相当于考试。显然，若测试样本被用作训练了，则得到的将是过于”乐观”的估计结果。</p></blockquote><h3 id="留出法"><a href="#留出法" class="headerlink" title="留出法"></a>留出法</h3><p>将数据集D划分为两个互斥的集合，一个作为训练集S，一个作为测试集T，满足D&#x3D;S$\cup$T且S$\cap$T&#x3D;$\emptyset$，常见的划分为：大约$\frac{2}{3}$~$\frac{4}{5}$的样本用作训练，剩下的用作测试。</p><p>需要注意的是：训练&#x2F;测试集的划分要尽可能保持数据分布的一致性，以避免由于分布的差异引入额外的偏差，常见的做法是采取分层抽样。同时，由于划分的随机性，单次的留出法结果往往不够稳定，一般要采用若干次随机划分，重复实验取平均值的做法。</p><blockquote><p>例如进行100次随机划分，每次产生一个训练&#x2F;测试集用于实验评估，100次后就得到100个结果，而留出法返回的则是这100个结果的平均。</p></blockquote><h3 id="交叉验证法-K倍交叉验证"><a href="#交叉验证法-K倍交叉验证" class="headerlink" title="交叉验证法(K倍交叉验证)"></a>交叉验证法(K倍交叉验证)</h3><p>将数据集D划分为k个大小相同的互斥子集，满足D&#x3D;$D_{1}\cup D_{2}\cup \dots \cup D_{k}$，$D_{i} \cap D_{j} &#x3D; \emptyset (i\not &#x3D;{j})$，同样地尽可能保持数据分布的一致性，即采用分层抽样的方法获得这些子集。</p><p>交叉验证法的思想是： <strong>每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集，这样就有K种训练集&#x2F;测试集划分的情况，从而可进行k次训练和测试，最终返回k次测试结果的均值。</strong> k最常用的取值是10。</p><p><img src="https://cdn.kesci.com/upload/image/q61krxb1f5.png" alt="2.2"></p><p>与留出法类似，将数据集D划分为k个子集的过程具有随机性，因此K折交叉验证通常也要重复p次，称为p次k折交叉验证，常见的是10次10折交叉验证，即进行了100次训练&#x2F;测试。</p><p>特殊地当划分的k个子集的每个子集中只有一个样本时，称为”留一法”，显然，留一法的评估结果比较准确，但对计算机的消耗也是巨大的。</p><h3 id="自助法"><a href="#自助法" class="headerlink" title="自助法"></a>自助法</h3><p>我们希望评估的是用整个D训练出的模型。但在留出法和交叉验证法中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集比D小，这必然会引入一些因训练样本规模不同而导致的估计偏差。留一法受训练样本规模变化的影响较小，但计算复杂度又太高了。”自助法”正是解决了这样的问题。</p><p>自助法的基本思想是： <strong>给定包含m个样本的数据集D，每次随机从D 中挑选一个样本，将其拷贝放入D’，然后再将该样本放回初始数据集D 中，使得该样本在下次采样时仍有可能被采到。重复执行m 次，就可以得到了包含m个样本的数据集D’。</strong> 可以得知在m次采样中，样本始终不被采到的概率取极限为：</p><p>$$<br>\lim_{m\rightarrow \infty}<br>  (1-\frac{1}{m})^{m} \rightarrow<br>  \frac{1}{e} \approx<br>  0.368<br>$$</p><p>这样，通过自助采样，初始样本集D中大约有36.8%的样本没有出现在D’中，于是可以将D’作为训练集，D-D’作为测试集。自助法在数据集较小，难以有效划分训练集&#x2F;测试集时很有用，但由于自助法产生的数据集（随机抽样）改变了初始数据集的分布，因此引入了估计偏差。在初始数据集足够时，留出法和交叉验证法更加常用。</p><h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><p>大多数学习算法都有些参数(parameter) 需要设定，参数配置不同，学得模型的性能往往有显著差别，这就是通常所说的”参数调节”或简称”调参” (parameter tuning)。</p><p>学习算法的很多参数是在实数范围内取值，因此，对每种参数取值都训练出模型来是不可行的。常用的做法是：对每个参数选定一个范围和步长，这样使得学习的过程变得可行。</p><blockquote><p>例如，假定算法有3个参数，每个参数仅考虑5个候选值，这样对每一组训练&#x2F;测试集就有$5^3$&#x3D; 125个模型需考察，由此可见：拿下一个参数（即经验值）对于算法人员来说是有多么的happy。</p></blockquote><p>最后需要注意的是：当选定好模型和调参完成后，我们需要使用初始的数据集D重新训练模型，即让最初划分出来用于评估的测试集也被模型学习，增强模型的学习效果。</p><blockquote><p>用考试的例子来比喻：就像高中时大家每次考试完，要将考卷的题目消化掉（大多数题目都还是之前没有见过的吧？），这样即使考差了也能开心的玩耍了~。</p></blockquote><h2 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h2><p>性能度量（performance measure）是衡量模型泛化能力的评价标准，在对比不同模型的能力时，使用不同的性能度量往往会导致不同的评判结果。</p><p>在预测任务中，给定样例集D&#x3D;{$(x_{1},y_{1}),(x_{2},y_{2}),\dots,(x_{m},y_{m})$}，其中$y_{i}$是示例$x_{i}$的真实标记。要评估学习器f的性能，就要把学习器预测结果f(x)与真实标记y进行比较。</p><p>回归任务中，即预测连续值的问题，最常用的性能度量是 <strong>“均方误差”（mean squared error）</strong> ,很多的经典算法都是采用了MSE作为评价函数：</p><p>$$<br>E(f;D) &#x3D;<br>  \frac{1}{m}<br>  \sum ^{m}_{i&#x3D;1}<br>  ( f ( x _{i} ) - y _{i} )^{2}<br>$$</p><p>更一般的，对于数据分布D和概率密度函数p(·)，均方误差可描述为：</p><p>$$<br>\begin{align}<br>  E(f;D) &#x3D;<br>  \int_{x\sim D}<br>    (f(x)-y)^{2}<br>    p(x)dx<br>\end{align}<br>$$</p><h3 id="错误率与精度"><a href="#错误率与精度" class="headerlink" title="错误率与精度"></a>错误率与精度</h3><p>在分类任务中，即预测离散值的问题，最常用的是错误率和精度，错误率是分类错误的样本数占样本总数的比例，精度则是分类正确的样本数占样本总数的比例，易知：错误率+精度&#x3D;1。</p><p>错误率定义为:</p><p>$$<br>\begin{align}<br>  E(f;D)&#x3D;<br>    \frac{1}{m}<br>    \sum^{m}_{i&#x3D;1} Ⅱ( f (x _{i}) \not &#x3D; {y _i} )<br>\end{align}<br>$$</p><p>精度定义为：</p><p>$$<br>\begin{align}<br>  acc(f;D)&#x3D;<br>    \frac{1}<br>         {m}<br>    \sum^{m}_{i&#x3D;1}<br>      Ⅱ( f ( x _{i}) &#x3D; {y _i} )<br>  &#x3D;1-E(f;D)<br>\end{align}<br>$$</p><p>更一般的，对于数据分布D和概率密度函数p(·)，错误率与精度可分布描述为：</p><p>$$<br>\begin{align}<br>  E(f;D)&#x3D;<br>    \int_{x\sim D}<br>      Ⅱ( f ( x )\not &#x3D; { y } )<br>      p(x)dx<br>  acc(f;D)&#x3D;<br>    \int_{x\sim D}<br>      Ⅱ( f ( x ) &#x3D; {y} )<br>      p(x)dx<br>  &#x3D;1-E(f;D)<br>\end{align}<br>$$</p><h3 id="查准率、查全率与F1"><a href="#查准率、查全率与F1" class="headerlink" title="查准率、查全率与F1"></a>查准率、查全率与F1</h3><p>错误率和精度虽然常用，但不能满足所有的需求，例如：在推荐系统中，我们只关心推送给用户的内容用户是否感兴趣（即查准率），或者说所有用户感兴趣的内容我们推送出来了多少（即查全率）。因此，使用查准&#x2F;查全率更适合描述这类问题。</p><p>对于二分类问题，分类结果混淆矩阵（confusion matrix）定义如下：</p><table><thead><tr><th align="center">真实情况</th><th align="center">预测为正</th><th align="center">预测为反</th></tr></thead><tbody><tr><td align="center">正例</td><td align="center">TP（真正例）</td><td align="center">FN（假反例）</td></tr><tr><td align="center">反例</td><td align="center">FP（假正例）</td><td align="center">TN（真反例）</td></tr></tbody></table><p>查准率P与查全率R定义如下:</p><p>$$<br>P &#x3D; \frac{TP}{TP + FP}<br>$$<br>$$<br>R &#x3D; \frac{TP} {TP + FN}<br>$$</p><p><img src="https://cdn.kesci.com/upload/image/q61l034hak.png" alt="matrix"></p><p>查准率和查全率是一对矛盾的度量。一般来说，查准率高时，查全率往往 偏低；而查全率高时，查准率往往偏低。</p><blockquote><p>例如，若希望将好瓜尽可能多地选出来, 则可通过增加选瓜的数量来实现，如果将所有西瓜都选上，那么所有的好瓜也必然都被选上了，但这样查准率就会较低;若希望选出的瓜中好瓜比例尽可能 高，则可只挑选最有把握的瓜，但这样就难免会漏掉不少好瓜，使得查全率较 低.通常只有在一些简单任务中，才可能使查全率和查准率都很高.</p></blockquote><h4 id="P-R曲线"><a href="#P-R曲线" class="headerlink" title="P-R曲线"></a>P-R曲线</h4><p>“P-R曲线”正是描述查准&#x2F;查全率变化的曲线，P-R曲线定义如下：</p><p>根据学习器的 <strong>预测结果（一般为一个实值或概率）</strong> 对测试样本进行 <strong>排序</strong> ，将 <strong>最可能</strong> 是”正例”的样本排在 <strong>前面</strong> ， <strong>最不可能</strong> 是”正例”的排在 <strong>后面</strong> ，按此顺序从前到后，逐个将当前预测结果设定为 <strong>阈值</strong> ，比阈值大的，也就是前面所有的样例，都预测是正例，后面所有的都是反例，每次计算出当前的P值和R值。</p><p><img src="https://cdn.kesci.com/upload/image/q61l0t71mv.png" alt="pr"></p><p>能看到一个分类器的P-R曲线是成负相关的，从（0，1）到（1，0），从胆小谨慎，到胆大包天。</p><h5 id="P-R曲线如何评估"><a href="#P-R曲线如何评估" class="headerlink" title="P-R曲线如何评估"></a>P-R曲线如何评估</h5><p>若一个学习器C的P-R曲线被另一个学习器A的P-R曲线完全包住（如上图所示），则称：A的性能优于C。若A和B的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。</p><p>但一般来说，曲线下的面积是很难进行估算的，所以衍生出了”平衡点”（Break-Event Point，简称BEP），即当P&#x3D;R时的取值，平衡点的取值越高，性能更优。</p><h5 id="F1度量"><a href="#F1度量" class="headerlink" title="F1度量"></a>F1度量</h5><p>P-R指标有时会出现矛盾的情况，这样就需要综合考虑他们，最常见的方法就是F-Measure，又称F-Score。F-Measure是P和R的加权调和平均，既：</p><p>$$<br>F_{\beta} &#x3D;<br>  \frac{(1+\beta^{2})×P×R}<br>       {(\beta^{2}×P)+R}<br>$$</p><p>特别的，当$\beta&#x3D;1$时，也就是常见的F1度量，是P和R的调和平均。当F1较高时，模型的性能越好。</p><p>$$<br>F1 &#x3D;<br>  \frac{2 × P × R}<br>       {P + R} &#x3D;<br>  \frac{2 × TP}<br>       {样例总数 + TP - TN}<br>$$</p><blockquote><p>F1是基于查准率与查全率的调和平均定义的：$\frac{1}{F1}&#x3D;\frac{1}{2}(\frac{1}{p}+\frac{1}{R})$<br>$F_{\beta}$则是加权调和平均：$\frac{1}{F_{\beta} }&#x3D;\frac{1}{1+\beta^{2} }(\frac{1}{p}+\frac{\beta^2}{R})$<br>其中$\beta$&gt;0度量了查全率对查准率的相对重要性；$\beta$&gt;1时查全率有更大影响；$\beta$&lt;1时查准率有更大影响。</p></blockquote><h4 id="n个混淆矩阵的综合考察"><a href="#n个混淆矩阵的综合考察" class="headerlink" title="n个混淆矩阵的综合考察"></a>n个混淆矩阵的综合考察</h4><p>有时候我们会有多个二分类混淆矩阵，例如：多次训练或者在多个数据集上训练，那么估算全局性能的方法有两种，分为宏观和微观。</p><ul><li>宏观：先算出每个混淆矩阵的P值和R值，然后取得平均P值macro_P和平均R值macro_R，在算出Fβ或F1</li></ul><p>$$<br>  macro_P &#x3D;<br>    \frac{1}<br>         {n}<br>    \sum_{i&#x3D;1}^n<br>      P_{i}<br>$$</p><p>$$<br>  macro_R &#x3D;<br>  \frac{1}<br>       {n}<br>  \sum_{i&#x3D;1}^n<br>    R_{i}<br>$$</p><p>$$<br>  macro_F1 &#x3D;<br>    \frac{2×mraco_P×mraco_R}<br>         {mraco_P+mraco_R}<br>$$</p><ul><li>微观：计算出混淆矩阵的平均TP、FP、TN、FN，接着进行计算P、R，进而求出Fβ或F1。</li></ul><p>$$<br>micro_P &#x3D;<br>  \frac{\over{TP}}<br>       { {\over{TP} } + {\over{FP} } }<br>$$</p><p>$$<br>micro_R &#x3D;<br>  \frac{\over{TP} }<br>       { {\over{TP} } + {\over{FN} } }<br>$$</p><p>$$<br>micro_F1 &#x3D;<br>  \frac{2×micro_P×micro_R}<br>       {micro_P+micro_R}<br>$$</p><h3 id="ROC与AUC"><a href="#ROC与AUC" class="headerlink" title="ROC与AUC"></a>ROC与AUC</h3><p>学习器对测试样本的评估结果一般为一个实值或概率，设定一个阈值，大于阈值为正例，小于阈值为负例，因此这个实值的好坏直接决定了学习器的泛化性能，若将这些实值排序，则排序的好坏决定了学习器的性能高低。ROC曲线正是从这个角度出发来研究学习器的泛化性能。</p><h4 id="ROC"><a href="#ROC" class="headerlink" title="ROC"></a>ROC</h4><p>受试者工作特征曲线 （receiver operating characteristic curve，简称ROC曲线），又称为感受性曲线（sensitivity curve）。</p><p>ROC曲线与P-R曲线十分类似，都是按照排序的顺序逐一按照正例预测，不同的是ROC曲线以 “真正例率”（True Positive Rate，简称TPR）为横轴，纵轴为 “假正例率”（False Positive Rate，简称FPR），ROC曲线偏重研究基于测试样本评估值的排序好坏。</p><p>$$<br>TPR &#x3D; \frac{TP}{TP + FN} &#x3D; 1 - FNR<br>$$</p><p>$$<br>FPR &#x3D; \frac{FP}{TN + FP} &#x3D; 1 - TNR<br>$$</p><p>$$<br>TNR &#x3D; \frac{TN}{TN + FP} &#x3D; 1 - FPR<br>$$</p><blockquote><p>FPR的值等于1-特异性。特异性（Specificity）是指在所有实际为负例的样本中，模型正确地预测为负例的样本比例，其衡量的是模型对负例样本的判断能力。</p></blockquote><p><img src="https://cdn.kesci.com/upload/image/q61l4ldd4k.png" alt="roc"></p><p>简单分析图像，可以得知（0,0）表示将所有的样本预测为负例，（1,1）则表示将所有的样本预测为正例，（0,1）对应正例全部出现在负例之前的理想模型，（1,0）则表示负例全部出现在正例之前的最差模型，对角线对应于”随即猜测”模型。</p><blockquote><p>ROC曲线是正相关的，纵轴为真正例率，横轴为假正例率，从（0，0）到（1，1），从小兵到将军，到达人生巅峰。</p></blockquote><p>现实中的任务通常都是有限个测试样本，因此难以绘制出光滑的ROC曲线，只能绘制出近似ROC曲线。绘制方法：首先根据测试样本的评估值对测试样本排序，接着按照以下规则进行绘制。</p><blockquote><p>第一步是按照属于’正样本’的概率将所有样本排序，如下图所示:</p><p><img src="https://picx.zhimg.com/80/v2-77e1e16ee58697a316cfe2728be86efe_720w.webp?source=1def8aca" alt="p0"></p><p>第二步，让我们依次来看每个样本。对于样本1，如果我们将他的score值做阈值，也就是说，只有score大于等于0.9时，我们才把样本归类到真阳性（true positive），这么一来， 在ROC曲线图中，样本1对应的混淆矩阵（confusion matrix）为:</p><p><img src="https://pic1.zhimg.com/80/v2-5ba41a6e4ca9370c2f4510d5a7b70daf_720w.webp?source=1def8aca" alt="p1"></p><p>其中，只有样本1我们看作是正确分类了（也就是我们预测是正样本，实际也是正样本）；其余还有9个实际是正样本，而我们预测是负样本的（2，4，5，6，9，11，13，17，19）；剩下的实际是负样本，我们都预测出是负样本了（也就是false positive &#x3D; 0， true negative &#x3D; 10）。</p><p><img src="https://pic1.zhimg.com/80/v2-10666128633da6ea072a4c87f21d6bdf_720w.webp?source=1def8aca" alt="p2"></p><p>同理我们来看样本3，它的混淆矩阵为:</p><p><img src="https://picx.zhimg.com/80/v2-0854a436a1e36a2a6745627c8367c209_720w.webp?source=1def8aca" alt="p3"></p><p>其中，样本1，2我们看作是正确分类了（也就是我们预测是正样本，实际也是正样本）;其余还有8个实际是正样本，而我们预测是负样本的（2，4，5，6，9，11，13，17，19）;而样本3是假阳性（我们预测是正样本，实际是负样本）;剩下的（7，8，10，12，14，15，16，18，20）实际是负样本，我们都预测出是负样本了（也就是false positive &#x3D; 1，true negative &#x3D; 9）。</p><p>从样本3的混淆矩阵中，我们可以算出X轴坐标（false positive rate）&#x3D; 1&#x2F;(1+9)&#x3D; 0.1 和Y轴坐标（true positive rate）&#x3D; 2&#x2F;(2+8)&#x3D; 0.2，这就是下图中的第三个点。</p><p>依次把20个样本的混淆矩阵列出来，再算出X轴坐标（false positive rate） 和Y轴坐标（true positive rate），就可以得到ROC曲线啦～</p></blockquote><h4 id="AUC"><a href="#AUC" class="headerlink" title="AUC"></a>AUC</h4><p>进行模型的性能比较时，若一个学习器A的ROC曲线被另一个学习器B的ROC曲线完全包住，则称B的性能优于A。</p><p>若A和B的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。</p><p>ROC曲线下的面积定义为AUC（Area Uder ROC Curve），不同于P-R的是，这里的AUC是可估算的，即AOC曲线下每一个小矩形的面积之和。易知：AUC越大，证明排序的质量越好，AUC为1时，证明所有正例排在了负例的前面，AUC为0时，所有的负例排在了正例的前面。</p><p>假设ROC曲线是由坐标为{$(x_{1},y_{1}),(x_{2},y_{2}),\dots,(x_{m},y_{m})$}的点按顺序连接而成$(x_{1}&#x3D;0,x_{m}&#x3D;1)$，则AUG定义为：</p><p>$$<br>AUG &#x3D;<br>  \frac{1}{2}<br>  \sum_{i&#x3D;1}^{m-1}<br>    (x_{i+1}-x_{i})·(y_{i}+y_{i+1})<br>$$</p><p>AUC考虑的是样本预测的排序质量，因此它与排序误差有紧密联系.给定$m^{+}$个正例和$m^{-}$个反例，令$D^{+}$和$D^{-}$分别表示正、反例集合，则排序”损失”(loss)定义为：</p><p>$$<br>\ell_{rank}&#x3D;<br>  \frac{1}{m^{+}+m^{-}}<br>  \sum_{x^{+}\in D^{+}}<br>    \sum_{x^{-}\in D^{-}} \big(<br>      Ⅱ(f(x^{+})&lt;f(x^{-})) +<br>      \frac{1}{2}<br>        Ⅱ(f(x^{+})&#x3D;f(x^{-}))<br>    \big)<br>$$</p><p>$\ell_{rank}$对应的是ROC曲线之上的面积，于是便有：</p><p>$$<br>AUC &#x3D; 1 - \ell_{rank}<br>$$</p><h3 id="代价敏感错误率与代价曲线"><a href="#代价敏感错误率与代价曲线" class="headerlink" title="代价敏感错误率与代价曲线"></a>代价敏感错误率与代价曲线</h3><p>代价敏感错误率通俗来讲就针对错误来赋予其代价。</p><blockquote><p>例如：将无疾病–&gt;有疾病只是增多了检查，但有疾病–&gt;无疾病却是增加了生命危险.</p></blockquote><p>以二分类为例，由此引入了 <strong>“代价矩阵”（cost matrix）</strong> 。</p><p><img src="https://cdn.kesci.com/upload/image/q61lgwniqb.png" alt="cost"></p><blockquote><p>通常来说重要的是比值而非绝对值。</p></blockquote><p>在非均等错误代价下，我们希望的是最小化”总体代价”，这样”代价敏感”的错误率:</p><p>$$<br>E(f;D;cost) &#x3D;<br>  \frac{1}{m}(<br>    \sum_{x_{i}\in D^{+}}<br>      Ⅱ(f(x_{i})\not &#x3D;{y_{i}})×cost_{01} +<br>    \sum_{x_{i}\in D^{-}}<br>      Ⅱ(f(x_{i})\not &#x3D;{y_{i}})×cost_{10}<br>  )<br>$$</p><h4 id="代价曲线"><a href="#代价曲线" class="headerlink" title="代价曲线"></a>代价曲线</h4><p>同样对于ROC曲线，在非均等错误代价下，演变成了”代价曲线”，代价曲线横轴是取值在[0,1]之间的正例概率代价，式中p表示正例的概率，纵轴是取值为[0,1]的归一化代价。</p><p>$$<br>P(+)cost &#x3D;<br>  \frac{p×cost_{01}}<br>       {p×cost_{01}+(1-p)×cost_{10}}<br>$$</p><p>$$<br>cost_{norm} &#x3D;<br>  \frac{FNR×p×cost_{01}+FPR×(1-p)×cost_{10}}<br>       {p×cost_{01}+(1-p)×cost_{10}}<br>$$</p><p>代价曲线的绘制很简单，如图所示：</p><p><img src="https://cdn.kesci.com/upload/image/q61lim3jzc.png" alt="ec"></p><p>$$<br>FNR &#x3D; \frac{FN}{TP+FN} &#x3D; 1- TPR<br>$$</p><blockquote><p>设ROC曲线上一点的坐标为(TPR，FPR) ，则可相应计算出FNR&#x3D;1-TPR，然后在代价平面上绘制一条从(0，FPR) 到(1，FNR) 的线段，线段下的面积即表示了该条件下的期望总体代价；如此将ROC 曲线土的每个点转化为代价平面上的一条线段，然后取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价</p></blockquote><!-- <p align="center">Create By Asuka24601</p> -->]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>机器学习</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书学习笔记(1)</title>
    <link href="/2023/12/18/%E8%A5%BF%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <url>/2023/12/18/%E8%A5%BF%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    
    <content type="html"><![CDATA[<p>主要内容：机器学习的定义、基本术语、假设空间、归纳偏好</p><span id="more"></span><h2 id="机器学习的定义"><a href="#机器学习的定义" class="headerlink" title="机器学习的定义"></a>机器学习的定义</h2><p>正如我们根据过去的经验来判断明天的天气，人们希望从购买经验中挑选一个好瓜，那能不能让计算机帮助人类来实现这个呢？机器学习正是这样的一门学科，人的”经验”对应计算机中的”数据”， <strong>让计算机来学习这些经验数据，生成一个算法模型，在面对新的情况中，计算机便能作出有效的判断，这便是机器学习</strong> 。</p><p>另一本经典教材的作者 <a href="https://www.cs.cmu.edu/~tom/">Mitchell</a> 给出了一个形式化的定义，假设：</p><ul><li><strong>P</strong> ：计算机程序在某任务类T上的性能。</li><li><strong>T</strong> ：计算机程序希望实现的任务类。</li><li><strong>E</strong> ：表示经验，即历史的数据集。</li></ul><p>若该计算机程序通过利用经验E在任务T上获得了性能P的改善，则称该程序对E进行了学习。</p><h2 id="机器学习的一些基本术语"><a href="#机器学习的一些基本术语" class="headerlink" title="机器学习的一些基本术语"></a>机器学习的一些基本术语</h2><p>假设我们收集了一批西瓜的数据，例如：(色泽&#x3D;青绿;根蒂&#x3D;蜷缩;敲声&#x3D;浊响) ， (色泽&#x3D;乌黑;根蒂&#x3D;稍蜷;敲声&#x3D;沉闷)， (色泽&#x3D;浅自;根蒂&#x3D;硬挺;敲声&#x3D;清脆)……每对括号内是一个西瓜的记录。定义：</p><ul><li><p>所有记录的集合为： <strong>数据集</strong> 。</p></li><li><p>每一条记录为：一个 <strong>示例（instance）或样本（sample）</strong> 。</p></li><li><p>单个的特点(例如西瓜的色泽或敲声)：为 <strong>特征（feature）或属性（attribute）</strong> 。</p></li></ul><p>对于一条记录，如果在坐标轴上表示，每个西瓜都可以用坐标轴中的一个点表示，一个点也是一个向量，例如（青绿，蜷缩，浊响），即每个西瓜为：一个 <strong>特征向量（feature vector）</strong> 。</p><p>一个样本的特征数为：<strong>维数（dimensionality）</strong> ，该西瓜的例子维数为3，当维数非常大时会产生”维数灾难”。</p><p>计算机程序学习经验数据生成算法模型的过程中，每一条记录称为一个”训练样本”，同时在训练好模型后，我们希望使用新的样本来测试模型的效果，则每一个新的样本称为一个”测试样本”。定义：</p><ul><li><p>所有 <strong>训练样本</strong> 的集合为： <strong>训练集（trainning set）</strong> ，[<strong>特殊</strong>] 。</p></li><li><p>所有 <strong>测试样本</strong> 的集合为： <strong>测试集（test set）</strong> ，[<strong>一般</strong>] 。</p></li></ul><p>机器学习出来的模型适用于新样本的能力为： <strong>泛化能力（generalization）</strong> ，即从特殊到一般。</p><blockquote><p>用一个实际例子来说明一下，就像考试之前我们肯定是要反复做题的，为的就是考试能考个好点的成绩。但是考试大多数都是新题，谁也没做过，考前的刷题是为了掌握试题的规律，能够举一反三、学以致用，这样我们在做新题的时候也能够从容面对。这种规律的掌握便是泛化能力，有的同学就能很好掌握这种规律，考试考个高分，也就是说他的”泛化能力”好。<br>考试考的不好的同学，无非是这三个原因：</p><ol><li>泛化能力弱，做了很多题，始终掌握不了规律，不管遇到老题还是新题都不会做；</li><li>泛化能力弱，做了很多题，只会死记硬背，看到考试的新题就懵了；</li><li>完全不做题，考试都是靠想象力瞎蒙。</li></ol><p>在机器学习中，我们把第一类情况称为欠拟合，第二类情况称为过拟合，第三类情况称作不收敛。</p></blockquote><p>西瓜的例子中，我们是想计算机通过学习西瓜的特征数据，训练出一个决策模型，来判断一个新的西瓜是否是好瓜。可以得知我们预测的是：西瓜是好是坏，即好瓜与差瓜两种，是离散值。同样地，也有通过历年的人口数据，来预测未来的人口数量，人口数量则是连续值。定义：</p><ul><li><p>预测值为 <strong>离散</strong> 值的问题为： <strong>分类（classification）</strong> 。</p></li><li><p>预测值为 <strong>连续</strong> 值的问题为： <strong>回归（regression）</strong> 。</p></li></ul><p>我们预测西瓜是否是好瓜的过程中，很明显对于训练集中的西瓜，我们事先已经知道了该瓜是否是好瓜，学习器通过学习这些好瓜或差瓜的特征，从而总结出规律，即训练集中的西瓜我们都做了标记，称为标记信息。但也有没有标记信息的情形，例如：我们想将一堆西瓜根据特征分成两个小堆，使得某一堆的西瓜尽可能相似，即都是好瓜或差瓜，对于这种问题，我们事先并不知道西瓜的好坏，样本没有标记信息。定义：</p><ul><li><p>训练数据 <strong>有标记信息</strong> 的学习任务为： <strong>监督学习（supervised learning）</strong> ，容易知道上面所描述的分类和回归都是监督学习的范畴。</p></li><li><p>训练数据 <strong>没有标记信息</strong> 的学习任务为： <strong>无监督学习（unsupervised learning）</strong> ，常见的有聚类和关联规则。</p></li></ul><h2 id="假设空间"><a href="#假设空间" class="headerlink" title="假设空间"></a>假设空间</h2><p>我们可以把学习过程看作一个在所有 <strong>假设(hypothesis)组成的空间</strong> 中进行搜索的过程，搜索目标是找到与训练集”匹配”(fit)的假设，即能够将训练集中的瓜判断正确的假设。</p><blockquote><p>假设空间既”由输入空间到输出空间的映射的集合”，我们把所有可能的由输入空间 X 到输出空间 Y 的映射 f : X$\rightarrow$Y 构成的集合记为$\boldsymbol{H}$，则假设空间$\boldsymbol{F}$为$\boldsymbol{H}$的一个子集，即$\boldsymbol{F}\subseteq\boldsymbol{H}$。也就是我们可以自行选择所考虑问题的假设空间的大小范围，并不一定非要选择包含所有可能性的映射集$\boldsymbol{H}$作为假设空间。</p></blockquote><p>假设的表示一旦确定，假设空间及其规模大小就确定了。这里我们的假设空间由形如”(色泽&#x3D;?)$\wedge$(根蒂&#x3D;?)$\wedge$(敲声&#x3D;?)”的可能取值所形成的假设组成。</p><blockquote><p>例如色泽有”青绿”、”乌黑”、”浅白”这三种可能取值;还需考虑到，也许”色泽”无论取什么值都合适，我们用通配符来表示，例如”好瓜$\Leftrightarrow$(色泽&#x3D;*)$\wedge$(根蒂&#x3D;蜷缩)$\wedge$(敲声&#x3D;浊响)”，即”好瓜是根蒂蜷缩、敲声浊响的瓜，什么色泽都行”。</p></blockquote><p>此外，还需考虑极端情况:有可能”好瓜”这个概念根本就不成立，世界上没有”好瓜”这种东西;我们用$\emptyset$表示这个假设。<br>这样，若”色泽””根蒂””敲声”分别有3、2、2种可能取值，则我们面临的假设空间规模大小为4x3x3+1&#x3D;37。</p><h3 id="版本空间"><a href="#版本空间" class="headerlink" title="版本空间"></a>版本空间</h3><p>现实问题中我们常面临很大的假设空间，但学习过程是基于 有限样本训练集进行的，因此，可能有多个假设与训练集一致，即存在着一个与训练集一致的”假设集合”，我们称之为 <strong>版本空间(version space)</strong> 。</p><h2 id="归纳偏好"><a href="#归纳偏好" class="headerlink" title="归纳偏好"></a>归纳偏好</h2><p>对于一个具体的学习算法而言，它必须要产生一个模型。这时，学习算 法本身的”偏好”就会起到关键的作用。</p><blockquote><p>例如，若我们的算法喜欢”尽可能特殊”的模型,则它会选择”好瓜$\leftrightarrow$(色泽&#x3D;*)$\wedge$(根蒂&#x3D;蜷缩)$\wedge$(敲声&#x3D;浊响)”; 但若我们的算法喜欢”尽可能一般”的模型，并且由于某种原因它更”相信”根蒂,则它会选择”好瓜$\leftrightarrow$(色泽&#x3D;*)$\wedge$(根蒂&#x3D;蜷缩)$\wedge$(敲声&#x3D;*)”。</p></blockquote><p>机器学习算法在学习过程中对某种类型假设的偏好，称为 <strong>归纳偏好(inductive bias)</strong>, 或简称为”偏好”。</p><p>归纳偏好可看作学习算法自身在一个可能很庞大的假设空间中对假设进 行选择的启发式或”价值观”。</p><p>事实上，归纳偏好对应了学习算法本身所做出的关于”什么样的模型更好”的假设。在具体的现实问题中，这个假设是否成立，即算法的归纳偏好是否与问题本身匹配,大多数时候直接决定了算法能否取得好的性能。</p><h3 id="“没有免费午餐”定理"><a href="#“没有免费午餐”定理" class="headerlink" title="“没有免费午餐”定理"></a>“没有免费午餐”定理</h3><p>在计算机人工智能（AI）领域，<a href="https://zhuanlan.zhihu.com/p/113126712">“没有免费午餐”（No Free Lunch，NFL）定理</a> 特别指出，不存在一种算法能够在所有可能的问题上都优于其他算法。这一定理对于理解和选择机器学习和优化算法尤其重要。</p><p>在机器学习和人工智能中,我们经常面临模型或算法的选择问题。”没有免费午餐”定理明确告诉我们:</p><ul><li><p>没有单一的机器学习模型能够保证在所有可能的问题上都优于其他模型。每个模型都有其擅长和不擅长的问题。</p></li><li><p>机器学习算法的性能高度依赖于所处理问题的特点以及数据的统计属性。算法和问题域之间的适配性至关重要。</p></li><li><p>在比较不同的机器学习算法时,必须基于某特定问题和数据集进行比较。在不同问题下进行的比较并无意义。</p></li></ul><p>这一定理强调了针对具体问题设计和选择算法的重要性。它也解释了为什么在机器学习研究中,几乎所有算法和模型的分析都是基于某特定数据集的。</p><p>总之，这个定理是让我们意识到，讨论算法的优劣，泛化能力的强弱，都不能脱离实际的问题，要针对具体的问题具体地分析。</p><!-- <p align="center">Create By Asuka24601</p> -->]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>机器学习</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTex数学符号</title>
    <link href="/2023/11/05/LaTexSymbols/"/>
    <url>/2023/11/05/LaTexSymbols/</url>
    
    <content type="html"><![CDATA[<!-- <div align="center"> <img src="https://s2.loli.net/2022/06/02/x3eAmDs1MLCkofX.jpg" width = 100% height = auto /> </div> --><p>简单的收集了一些Latex数学符号的写法，方便需要时查找。</p><span id="more"></span><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\pm$</td><td>\pm</td><td>$\mp$</td><td>\mp</td><td>$\times$</td><td>\times</td></tr><tr><td>$\div$</td><td>\div</td><td>$\cdot$</td><td>\cdot</td><td>$\ast$</td><td>\ast</td></tr><tr><td>$\star$</td><td>\star</td><td>$\dagger$</td><td>\dagger</td><td>$\ddagger$</td><td>\ddagger</td></tr><tr><td>$\amalg$</td><td>\amalg</td><td>$\cap$</td><td>\cap</td><td>$\cup$</td><td>\cup</td></tr><tr><td>$\uplus$</td><td>\uplus</td><td>$\sqcap$</td><td>\sqcap</td><td>$\sqcup$</td><td>\sqcup</td></tr><tr><td>$\vee$</td><td>\vee</td><td>$\wedge$</td><td>\wedge</td><td>$\oplus$</td><td>\oplus</td></tr><tr><td>$\ominus$</td><td>\ominus</td><td>$\otimes$</td><td>\otimes</td><td>$\circ$</td><td>\circ</td></tr><tr><td>$\bullet$</td><td>\bullet</td><td>$\diamond$</td><td>\diamond</td><td>$\lhd$</td><td>\lhd</td></tr><tr><td>$\rhd$</td><td>\rhd</td><td>$\unlhd$</td><td>\unlhd</td><td>$\unrhd$</td><td>\unrhd</td></tr><tr><td>$\oslash$</td><td>\oslash</td><td>$\odot$</td><td>\odot</td><td>$\bigcirc$</td><td>\bigcirc</td></tr><tr><td>$\triangleleft$</td><td>\triangleleft</td><td>$\Diamond$</td><td>\Diamond</td><td>$\bigtriangleup$</td><td>\bigtriangleup</td></tr><tr><td>$\bigtriangledown$</td><td>\bigtriangledown</td><td>$\Box$</td><td>\Box</td><td>$\triangleright$</td><td>\triangleright</td></tr><tr><td>$\setminus$</td><td>\setminu</td><td>$\wr$</td><td>\wr</td><td>$\sqrt{x}$</td><td>\sqrt{x}</td></tr><tr><td>$x^{\circ}$</td><td>x^{\circ}</td><td>$\triangledown$</td><td>\triangledown</td><td>$\sqrt[n]{x}$</td><td>\sqrt[n]{x}</td></tr><tr><td>$a^x$</td><td>a^x</td><td>$a^{xyz}$</td><td>a^{xyz}</td><td></td><td></td></tr></tbody></table><h2 id="关系符"><a href="#关系符" class="headerlink" title="关系符"></a>关系符</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\le$</td><td>\le</td><td>$\ge$</td><td>\ge</td><td>$\neq$</td><td>\ne</td></tr><tr><td>$\sim$</td><td>\sim</td><td>$\ll$</td><td>\ll</td><td>$\gg$</td><td>\gg</td></tr><tr><td>$\doteq$</td><td>\doteq</td><td>$\simeq$</td><td>\simeq</td><td>$\subset$</td><td>\subset</td></tr><tr><td>$\supset$</td><td>\supset</td><td>$\approx$</td><td>\approx</td><td>$\asymp$</td><td>\asymp</td></tr><tr><td>$\subseteq$</td><td>\subseteq</td><td>$\supseteq$</td><td>\supseteq</td><td>$\cong$</td><td>\cong</td></tr><tr><td>$\smile$</td><td>\smile</td><td>$\sqsubset$</td><td>\sqsubset</td><td>$\sqsupset$</td><td>\sqsupset</td></tr><tr><td>$\equiv$</td><td>\equiv</td><td>$\frown$</td><td>\frown</td><td>$\sqsubseteq$</td><td>\sqsubseteq</td></tr><tr><td>$\sqsupseteq$</td><td>\sqsupseteq</td><td>$\propto$</td><td>\propto</td><td>$\bowtie$</td><td>\bowtie</td></tr><tr><td>$\in$</td><td>\in</td><td>$\ni$</td><td>\ni</td><td>$\prec$</td><td>\prec</td></tr><tr><td>$\succ$</td><td>\succ</td><td>$\vdash$</td><td>\vdash</td><td>$\dashv$</td><td>\dashv</td></tr><tr><td>$\preceq$</td><td>\preceq</td><td>$\succeq$</td><td>\succeq</td><td>$\models$</td><td>\models</td></tr><tr><td>$\perp$</td><td>\perp</td><td>$\parallel$</td><td>\parallel</td><td></td><td></td></tr><tr><td>$\mid$</td><td>\mid</td><td>$\bumpeq$</td><td>\bumpeq</td><td></td><td></td></tr></tbody></table><p>只要将not放在符号前面或者在 \ 和单词之间插入一个 n ，就可以形成许多这些关系的否定形式，这里有一些例子，加上一些其他的否定，它也适用于许多其他的。</p><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\nmid$</td><td>\nmid</td><td>$\nleq$</td><td>\nleq</td><td>$\ngeq$</td><td>\ngeq</td></tr><tr><td>$\nsim$</td><td>\nsim</td><td>$\ncong$</td><td>\ncong</td><td>$\nparallel$</td><td>\nparallel</td></tr><tr><td>$\not&lt;$</td><td>\not&lt;</td><td>$\not&gt;$</td><td>\not&gt;</td><td>$\not&#x3D;$</td><td>\not&#x3D; or \neq</td></tr><tr><td>$\not\le$</td><td>\not\le</td><td>$\not\ge$</td><td>\not\ge</td><td>$\not\sim$</td><td>\not\sim</td></tr><tr><td>$\not\approx$</td><td>\not\approx</td><td>$\not\cong$</td><td>\not\cong</td><td>$\not\equiv$</td><td>\not\equiv</td></tr><tr><td>$\not\parallel$</td><td>\not\paralle</td><td>$\nless$</td><td>\nless</td><td>$\ngtr$</td><td>\ngtr</td></tr><tr><td>$\lneq$</td><td>\lneq</td><td>$\gneq$</td><td>\gneq</td><td>$\lnsim$</td><td>\lnsim</td></tr><tr><td>$\lneqq$</td><td>\lneqq</td><td>$\gneqq$</td><td>\gneqq</td><td></td><td></td></tr></tbody></table><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><h3 id="小写"><a href="#小写" class="headerlink" title="小写"></a>小写</h3><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\alpha$</td><td>\alpha</td><td>$\beta$</td><td>\beta</td><td>$\gamma$</td><td>\gamma</td><td>$\delta$</td><td>\delta</td></tr><tr><td>$\epsilon$</td><td>\epsilon</td><td>$\varepsilon$</td><td>\varepsilon</td><td>$\zeta$</td><td>\zeta</td><td>$\eta$</td><td>\eta</td></tr><tr><td>$\theta$</td><td>\theta</td><td>$\vartheta$</td><td>\vartheta</td><td>$\iota$</td><td>\iota</td><td>$\kappa$</td><td>\kappa</td></tr><tr><td>$\lambda$</td><td>\lambda</td><td>$\mu$</td><td>\mu</td><td>$\nu$</td><td>\nu</td><td>$\xi$</td><td>\xi</td></tr><tr><td>$\pi$</td><td>\pi</td><td>$\varpi$</td><td>\varpi</td><td>$\rho$</td><td>\rho</td><td>$\varrho$</td><td>\varrho</td></tr><tr><td>$\sigma$</td><td>\sigma</td><td>$\varsigma$</td><td>\varsigma</td><td>$\tau$</td><td>\tau</td><td>$\upsilon$</td><td>\upsilon</td></tr><tr><td>$\phi$</td><td>\phi</td><td>$\varphi$</td><td>\varphi</td><td>$\chi$</td><td>\chi</td><td>$\psi$</td><td>\psi</td></tr><tr><td>$\omega$</td><td>\omega</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="大写"><a href="#大写" class="headerlink" title="大写"></a>大写</h3><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\Gamma$</td><td>\Gamma</td><td>$\Delta$</td><td>\Delta</td><td>$\Theta$</td><td>\Theta</td><td>$\Lambda$</td><td>\Lambda</td></tr><tr><td>$\Xi$</td><td>\Xi</td><td>$\Pi$</td><td>\Pi</td><td>$\Sigma$</td><td>\Sigma</td><td>$\Upsilon$</td><td>\Upsilon</td></tr><tr><td>$\Phi$</td><td>\Phi</td><td>$\Psi$</td><td>\Psi</td><td>$\Omega$</td><td>\Omega</td><td>$\nabla$</td><td>\nabla</td></tr></tbody></table><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>在公式中的字母加粗：</p><table><thead><tr><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\boldsymbol{m}$</td><td>\boldsymbol{m}</td></tr></tbody></table><h3 id="空心字母"><a href="#空心字母" class="headerlink" title="空心字母"></a>空心字母</h3><table><thead><tr><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\mathbb{M}$</td><td>\mathbb{M}</td></tr><tr><td>$\mathbb{R}$</td><td>\mathbb{R}</td></tr></tbody></table><h2 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\gets$</td><td>\gets</td><td>$\to$</td><td>\to</td></tr><tr><td>$\leftarrow$</td><td>\leftarrow</td><td>$\Leftarrow$</td><td>\Leftarrow</td></tr><tr><td>$\rightarrow$</td><td>\rightarrow</td><td>$\Rightarrow$</td><td>\Rightarrow</td></tr><tr><td>$\leftrightarrow$</td><td>\leftrightarrow</td><td>$\Leftrightarrow$</td><td>\Leftrightarrow</td></tr><tr><td>$\mapsto$</td><td>\mapsto</td><td>$\hookleftarrow$</td><td>\hookleftarrow</td></tr><tr><td>$\leftharpoonup$</td><td>\leftharpoonup</td><td>$\leftharpoondown$</td><td>\leftharpoondown</td></tr><tr><td>$\rightleftharpoons$</td><td>\rightleftharpoons</td><td>$\longleftarrow$</td><td>\longleftarrow</td></tr><tr><td>$\Longleftarrow$</td><td>\Longleftarrow</td><td>$\longrightarrow$</td><td>\longrightarrow</td></tr><tr><td>$\Longrightarrow$</td><td>\Longrightarrow</td><td>$\longleftrightarrow$</td><td>\longleftrightarrow</td></tr><tr><td>$\Longleftrightarrow$</td><td>\Longleftrightarrow</td><td>$\longmapsto$</td><td>\longmapsto</td></tr><tr><td>$\hookrightarrow$</td><td>\hookrightarrow</td><td>$\rightharpoonup$</td><td>\rightharpoonup</td></tr><tr><td>$\rightharpoondown$</td><td>\rightharpoondown</td><td>$\leadsto$</td><td>\leadsto</td></tr><tr><td>$\uparrow$</td><td>\uparrow</td><td>$\Uparrow$</td><td>\Uparrow</td></tr><tr><td>$\downarrow$</td><td>\downarrow</td><td>$\Downarrow$</td><td>\Downarrow</td></tr><tr><td>$\updownarrow$</td><td>\updownarrow</td><td>$\Updownarrow$</td><td>\Updownarrow</td></tr><tr><td>$\nearrow$</td><td>\nearrow</td><td>$\searrow$</td><td>\searrow</td></tr><tr><td>$\swarrow$</td><td>\swarrow</td><td>$\nwarrow$</td><td>\nwarrow</td></tr></tbody></table><p>(对于不喜欢键入长串字母的人，\iff和\implies可以分别替代\Longleftrightarrow和\ longrighttarrow)</p><h2 id="点"><a href="#点" class="headerlink" title="点"></a>点</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\cdot$</td><td>\cdot</td><td>$\vdots$</td><td>\vdots</td></tr><tr><td>$\dots$</td><td>\dots</td><td>$\ddots$</td><td>\ddots</td></tr></tbody></table><h2 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\hat{x}$</td><td>\hat{x</td><td>$\check{x}$</td><td>\check{x}</td><td>$\dot{x}$</td><td>\dot{x}</td></tr><tr><td>$\breve{x}$</td><td>\breve{x}</td><td>$\acute{x}$</td><td>\acute{x}</td><td>$\ddot{x}$</td><td>\ddot{x}</td></tr><tr><td>$\grave{x}$</td><td>\grave{x}</td><td>$\tilde{x}$</td><td>\tilde{x}</td><td>$\mathring{x}$</td><td>\mathring{x}</td></tr><tr><td>$\bar{x}$</td><td>\bar{x}</td><td>$\vec{x}$</td><td>\vec{x}</td><td></td><td></td></tr></tbody></table><p>当对i和j应用上标时，可以使用\imath和\jmath来防止点干扰上标:</p><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\vec{\jmath}$​</td><td>\vec{\jmath}</td><td>$\tilde{\imath}$</td><td>\tilde{\imath}</td></tr></tbody></table><p>\tilde和\hat有很宽的版本，可以让你强调一个表达:</p><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\widehat{7+x}$​</td><td>\widehat{7+x}</td><td>$\widetilde{abc}$</td><td>\widetilde{abc}</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\infty$</td><td>\infty</td><td>$\triangle$</td><td>\triangle</td><td>$\angle$</td><td>\angle</td></tr><tr><td>$\aleph$</td><td>\aleph</td><td>$\hbar$</td><td>\hbar</td><td>$\imath$</td><td>\imath</td></tr><tr><td>$\jmath$</td><td>\jmath</td><td>$\ell$</td><td>\ell</td><td>$\wp$</td><td>\wp</td></tr><tr><td>$\Re$</td><td>\Re</td><td>$\Im$</td><td>\Im</td><td>$\mho$</td><td>\mho</td></tr><tr><td>$\prime$</td><td>\prime</td><td>$\emptyset$</td><td>\emptyset</td><td>$\nabla$</td><td>\nabla</td></tr><tr><td>$\surd$</td><td>\surd</td><td>$\partial$</td><td>\partial</td><td>$\top$</td><td>\top</td></tr><tr><td>$\bot$</td><td>\bot</td><td>$\vdash$</td><td>\vdash</td><td>$\dashv$</td><td>\dashv</td></tr><tr><td>$\forall$</td><td>\forall</td><td>$\exists$</td><td>\exists</td><td>$\neg$</td><td>\neg</td></tr><tr><td>$\flat$</td><td>\flat</td><td>$\natural$</td><td>\natural</td><td>$\sharp$</td><td>\sharp</td></tr><tr><td>$\backslash$</td><td>\backslash</td><td>$\Box$</td><td>\Box</td><td>$\Diamond$</td><td>\Diamond</td></tr><tr><td>$\clubsuit$</td><td>\clubsuit</td><td>$\diamondsuit$</td><td>\diamondsuit</td><td>$\heartsuit$</td><td>\heartsuit</td></tr><tr><td>$\spadesuit$</td><td>\spadesuit</td><td>$\Join$</td><td>\Join</td><td>$\blacksquare$</td><td>\blacksquare</td></tr><tr><td>$\checkmark$</td><td>\checkmark</td><td>$\mathbb{R}$</td><td>\mathbb{R}</td><td>$\textcopyright$</td><td>\copyright</td></tr><tr><td>£</td><td>\pounds</td><td>$\square$</td><td>\square</td><td>$\cup$</td><td>\cup</td></tr><tr><td>$\bigstar$</td><td>\bigstar</td><td>$\in$</td><td>\in</td><td></td><td></td></tr></tbody></table><h2 id="命令符"><a href="#命令符" class="headerlink" title="命令符"></a>命令符</h2><p>有些符号用于命令中，因此需要以特殊的方式处理它们。</p><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\backslash$</td><td>\backslash</td><td>$&amp;$</td><td>\&amp;</td><td>$%$</td><td>\%</td><td>$#$</td><td>\#</td></tr><tr><td>$_$</td><td>\_</td><td>${$</td><td>\{</td><td>$}$</td><td>\}</td><td></td><td></td></tr></tbody></table><p>您可能会注意到，如果使用其中任何一个来排版垂直较大的表达式，比如<br>$$(\frac{a}{x} )^2$$<br>得到的表达式的括号的大小不对<br>$$(\frac{a} {x} )^2$$</p><h2 id="跨行或跨列的符号"><a href="#跨行或跨列的符号" class="headerlink" title="跨行或跨列的符号"></a>跨行或跨列的符号</h2><table><thead><tr><th>symbol</th><th>command</th></tr></thead><tbody><tr><td>$ f(x) &#x3D; \begin{cases} x^2 &amp; x \ge 0 \\ x &amp; x &lt; 0 \end{cases} $</td><td>f(x)&#x3D;\ begin{cases} x^2 &amp; x \ge 0 \ x &amp; x&lt;0 \end{cases}</td></tr><tr><td>$ \left\lceil\frac{x}{y}\right\rceil $</td><td>\left\lceil\frac{x}{y}\right\rceil</td></tr><tr><td>$ \left\lfloor\frac{x}{y}\right\rfloor $</td><td>\left\lfloor\frac{x}{y}\right\rfloor</td></tr><tr><td>$ \underbrace{a_0+a_1+a_2+\cdots+a_n}_{x} $</td><td>\underbrace{a_0+a_1+a_2+\cdots+a_n}_{x}</td></tr><tr><td>$ \overbrace{a_0+a_1+a_2+\cdots+a_n}^{x} $</td><td>\overbrace{a_0+a_1+a_2+\cdots+a_n}^{x}</td></tr><tr><td>$\arg \underset{1\leq k \leq n} {max} \frac{\lambda_k}{\lambda_{k+1} }$</td><td>\arg \underset{1\leq k \leq n} {max} \frac{\lambda_k}{\lambda_{k+1} }</td></tr></tbody></table><p>\left和\right也可以用来调整下列符号的大小:</p><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\uparrow$</td><td>\uparrow</td><td>$\downarrow$</td><td>\downarrow</td><td>$\updownarrow$</td><td>\updownarrow</td></tr><tr><td>$\Uparrow$</td><td>\Uparrow</td><td>$\Downarrow$</td><td>\Downarrow</td><td>$\Updownarrow$</td><td>\Updownarrow</td></tr></tbody></table><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td>$\sum$</td><td>\sum</td><td>$\int$</td><td>\int</td><td>$\oint$</td><td>\oint</td></tr><tr><td>$\prod$</td><td>\prod</td><td>$\coprod$</td><td>\coprod</td><td>$\bigcap$</td><td>\bigcap</td></tr><tr><td>$\bigcup$</td><td>\bigcup</td><td>$\bigsqcup$</td><td>\bigsqcup</td><td>$\bigvee$</td><td>\bigvee</td></tr><tr><td>$\bigwedge$</td><td>\bigwedge</td><td>$\bigodot$</td><td>\bigodot</td><td>$\bigotimes$</td><td>\bigotimes</td></tr><tr><td>$\bigoplus$</td><td>\bigoplus</td><td>$\biguplus$</td><td>\biguplus</td><td></td><td></td></tr></tbody></table><!-- <p align="center">Create By Asuka24601</p> -->]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>依赖注入(DI)和控制反转(IOC)</title>
    <link href="/2023/02/17/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-DI-%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-IOC/"/>
    <url>/2023/02/17/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-DI-%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-IOC/</url>
    
    <content type="html"><![CDATA[<p>在软件工程领域，理解依赖注入（DI）与控制反转（IOC）不仅是提高编程效率的关键，也是实现高质量代码设计的基石。</p><span id="more"></span><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>首先，控制反转（IOC）是一种设计原则，用于减少计算机代码之间的耦合。在传统的程序设计中，高级模块依赖于低级模块的实现细节，这种直接的依赖关系使得代码难以维护和扩展。控制反转的核心思想是通过抽象化来降低模块间的直接依赖，从而实现模块间的松耦合。在控制反转的模式下，不是由高级模块主动创建或查找所需的低级模块，而是将这一职责交给外部的容器或框架，由它来负责创建并维护对象之间的关系。</p><p>依赖注入（DI）是实现控制反转的一种技术手段。通过依赖注入，对象的依赖关系不再在对象内部静态地创建，而是在对象被创建的时候，由外部动态地注入。这种方式有三种基本形式：构造函数注入、属性注入和方法注入。构造函数注入是指通过构造函数传递依赖对象，属性注入则是通过公开的属性来接收依赖对象，而方法注入是通过调用方法的方式来传递依赖对象。无论采用哪种形式，依赖注入的目的都是将对象的创建和对象间的依赖关系的管理从业务逻辑中解耦出来，交给外部容器处理。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>例如：现有类 A 依赖于类 B</p><ul><li>传统的开发方式 ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来</li><li>使用 IoC 思想的开发方式 ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面过去即可。</li></ul><p>从以上两种开发方式的对比来看：我们 “丧失了一个权力” (创建、管理对象的权力)，从而也得到了一个好处（不用再考虑对象的创建、管理等一系列的事情）。</p><h4 id="为什么叫控制反转"><a href="#为什么叫控制反转" class="headerlink" title="为什么叫控制反转?"></a>为什么叫控制反转?</h4><p>控制：指的是对象创建（实例化、管理）的权力。<br>反转：控制权交给外部环境（Spring 框架、IoC 容器）。</p><p><img src="https://pic1.zhimg.com/50/v2-005b53a7d400a5c21314ae58cbd606b7_720w.jpg" alt="img"></p><h4 id="IoC解决了什么问题"><a href="#IoC解决了什么问题" class="headerlink" title="IoC解决了什么问题?"></a>IoC解决了什么问题?</h4><p>IoC的思想就是两方之间不互相依赖，由第三方容器来管理相关资源。</p><h4 id="这样有什么好处呢？"><a href="#这样有什么好处呢？" class="headerlink" title="这样有什么好处呢？"></a>这样有什么好处呢？</h4><p>对象之间的耦合度或者说依赖程度降低；资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。例如：现有一个针对 User 的操作，利用 Service 和 Dao 两层结构进行开发在没有使用 IoC 思想的情况下，Service 层想要使用 Dao 层的具体实现的话，需要通过 new 关键字在UserServiceImpl 中手动 new 出 IUserDao 的具体实现类 UserDaoImpl（不能直接 new 接口类）。</p><p><img src="https://picx.zhimg.com/50/v2-cc1018cafdf0308b78b13c78e74c43e8_720w.jpg" alt="img"></p><p>很完美，这种方式也是可以实现的，但是我们想象一下如下场景：开发过程中突然接到一个新的需求，针对对IUserDao 接口开发出另一个具体实现类。因为 Server 层依赖了IUserDao的具体实现，所以我们需要修改UserServiceImpl中 new 的对象。如果只有一个类引用了IUserDao的具体实现，可能觉得还好，修改起来也不是很费力气，但是如果有许许多多的地方都引用了IUserDao的具体实现的话，一旦需要更换IUserDao 的实现方式，那修改起来将会非常的头疼。</p><p><img src="https://picx.zhimg.com/50/v2-b308940c71b3669e3cfae538951103f7_720w.jpg" alt="img"></p><p>使用 IoC 的思想，我们将对象的控制权（创建、管理）交有 IoC 容器去管理，我们在使用的时候直接向 IoC 容器 “要” 就可以了。</p><p><img src="https://picx.zhimg.com/50/v2-36005391eee51804baae7594d723c458_720w.jpg" alt="img"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>依赖注入和控制反转的好处是显而易见的。首先，它们能够显著提高代码的可测试性。由于依赖关系是外部注入的，因此在单元测试时可以很容易地用模拟对象（Mock Object）替换真实的依赖，这样就可以在隔离环境中测试代码的功能。其次，它们促进了代码的重用。由于依赖关系不再硬编码在组件内部，因此同一个组件可以在不同的环境中被重用，只需改变依赖对象的配置即可。最后，它们提高了代码的可维护性。当系统需要升级或替换组件时，由于组件之间的耦合度降低，改动的影响范围也随之减小。</p><h2 id="在SpringBoot中的应用"><a href="#在SpringBoot中的应用" class="headerlink" title="在SpringBoot中的应用"></a>在SpringBoot中的应用</h2><p>在当今的软件开发实践中，Spring Boot作为一种轻量级的开源框架，已经广泛被用于创建高效、易维护的Java应用程序。Spring Boot的核心特性之一就是依赖注入（DI）和控制反转（IOC），这两个概念是Spring框架的基石，对于理解和有效使用Spring Boot至关重要。</p><h3 id="控制反转（IOC）"><a href="#控制反转（IOC）" class="headerlink" title="控制反转（IOC）"></a>控制反转（IOC）</h3><p>在没有IOC的情况下，对象通常自行创建和管理它们所依赖的对象。这种方式导致了高度耦合和难以测试的代码。IOC的核心思想是将对象的创建和管理工作交给外部容器（在Spring框架中，这个容器通常是ApplicationContext），从而实现解耦。</p><h3 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h3><p>通过DI，对象的依赖不再由对象本身在内部创建，而是在创建对象的时候由外部注入。这样做的好处是减少了组件之间的耦合，增加了代码的模块化，使得单元测试更加容易。</p><h3 id="DI的实现方式"><a href="#DI的实现方式" class="headerlink" title="DI的实现方式"></a>DI的实现方式</h3><p>在Spring Boot中，DI可以通过以下几种方式实现：</p><ol><li><strong>构造器注入</strong>：通过对象的构造器来注入依赖。</li><li><strong>Setter注入</strong>：通过对象的Setter方法来注入依赖。</li><li><strong>字段注入</strong>：直接在字段上使用@Autowired注解来注入依赖。</li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>为了更好地理解这些概念，让我们通过一些简单的代码示例来看看它们是如何在实践中应用的。</p><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserRepository userRepository;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserService</span><span class="hljs-params">(UserRepository userRepository)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userRepository = userRepository;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>UserService</code>依赖于<code>UserRepository</code>。通过将<code>UserRepository</code>作为构造器的参数，Spring容器在创建<code>UserService</code>实例时自动注入<code>UserRepository</code>的实例。</p><h4 id="Setter注入"><a href="#Setter注入" class="headerlink" title="Setter注入"></a>Setter注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">private</span> UserRepository userRepository;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserRepository</span><span class="hljs-params">(UserRepository userRepository)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userRepository = userRepository;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与构造器注入类似，但是这里依赖是通过Setter方法注入的。Spring容器会在创建<code>UserService</code>实例后调用<code>setUserRepository</code>方法来注入<code>UserRepository</code>的实例。</p><h4 id="字段注入"><a href="#字段注入" class="headerlink" title="字段注入"></a>字段注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserRepository userRepository;<br>&#125;<br></code></pre></td></tr></table></figure><p>字段注入是最简单的注入方式，只需在字段上添加<code>@Autowired</code>注解即可。Spring容器会自动寻找匹配的类型并注入相应的实例。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>通过上述讨论和代码示例，我们可以看到，依赖注入和控制反转在Spring Boot中是如何帮助我们实现低耦合、高内聚的设计的。通过将对象的创建和管理责任交给Spring容器，我们的应用程序变得更加模块化，易于测试和维护。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IoC 和 DI 别再傻傻分不清楚。IoC是一种设计思想，或者说是某种模式，这个设计思想就是 将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。 IoC 在其他语言中也有应用，并非 Spring 特有。IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。并且，Martin Fowler 在一篇文章中提到将 IoC 改名为 DI，原文如下，原文地址：<a href="https://martinfowler.com/articles/injection.html">https://martinfowler.com/articles/injection.html</a>。</p><p><img src="https://pic1.zhimg.com/50/v2-8ccb15cfc3aa2cf68ba3e75d259696c5_720w.jpg"></p><p>Martin 的大概意思是 IoC 太普遍并且不表意，很多人会因此而迷惑，所以，使用 DI 来精确指名这个模式比较好。</p><!-- <p align="center">Create By Asuka24601</p> -->]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识</tag>
      
      <tag>java</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端技能：防抖与节流</title>
    <link href="/2022/12/22/%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD%EF%BC%9A%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <url>/2022/12/22/%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD%EF%BC%9A%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>简单的了解一下前端开发中的防抖和节流。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在现实情况里我们可能碰到这样的问题：</p><ul><li>用户在搜索的时候，在不停敲字，如果每敲一个字我们就要调一次接口，接口调用太频繁，给卡住了。</li><li>用户在阅读文章的时候，我们需要监听用户滚动到了哪个标题，但是每滚动一下就监听，那样会太过频繁从而占内存，如果再加上其他的业务代码，就卡住了。</li></ul><p>这时候，我们可以抛出防抖和节流的概念了：</p><ul><li>防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。</li><li>节流：指定时间间隔内只会执行一次任务。</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>debounce<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;debounce&quot;</span>&gt;</span>点我防抖！<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 1、获取这个按钮，并绑定事件</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> myDebounce = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;debounce&quot;</span>);</span><br><span class="language-javascript">      myDebounce.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-title function_">debounce</span>(sayDebounce));</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 2、防抖功能函数，接受传参</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 4、创建一个标记用来存放定时器的返回值</span></span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span>;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 5、每次当用户点击/输入的时候，把前一个定时器清除</span></span><br><span class="language-javascript">        <span class="hljs-built_in">clearTimeout</span>(timeout);</span><br><span class="language-javascript">        <span class="hljs-comment">// 6、然后创建一个新的 setTimeout，</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 这样就能保证点击按钮后的 interval 间隔内</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 如果用户还点击了的话，就不会执行 fn 函数</span></span><br><span class="language-javascript">        timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">          fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);</span><br><span class="language-javascript">        &#125;, <span class="hljs-number">1000</span>);</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 3、需要进行防抖的事件处理</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayDebounce</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// ... 有些需要防抖的工作，在这里执行</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;防抖成功！&quot;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>throttle<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;throttle&quot;</span>&gt;</span>点我节流！<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 1、获取按钮，绑定点击事件</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> myThrottle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;throttle&quot;</span>);</span><br><span class="language-javascript">      myThrottle.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-title function_">throttle</span>(sayThrottle));</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 2、节流函数体</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 4、通过闭包保存一个标记</span></span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 5、在函数开头判断标志是否为 true，不为 true 则中断函数</span></span><br><span class="language-javascript">        <span class="hljs-keyword">if</span>(!canRun) &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">return</span>;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-comment">// 6、将 canRun 设置为 false，防止执行之前再被执行</span></span><br><span class="language-javascript">        canRun = <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">        <span class="hljs-comment">// 7、定时器</span></span><br><span class="language-javascript">        <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">          fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);</span><br><span class="language-javascript">          <span class="hljs-comment">// 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true</span></span><br><span class="language-javascript">          canRun = <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">        &#125;, <span class="hljs-number">1000</span>);</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 3、需要节流的事件</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayThrottle</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;节流成功！&quot;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>防抖和节流是前端开发中很基础的技能，理解并善用很重要。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识</tag>
      
      <tag>前端</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端技能：懒加载和预加载</title>
    <link href="/2022/12/21/%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD%EF%BC%9A%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
    <url>/2022/12/21/%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD%EF%BC%9A%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>什么是懒加载和预加载？为什么需要懒加载和预加载？</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>懒加载和预加载是常用的web优化的手段，用于提升提升用户体验。</p><ul><li><p>预加载：是指在页面加载完成之前，提前将所需资源下载， 图片加载完毕后可通过onload方法显示出来，或者放在缓存中，之后使用的时候从调用；</p></li><li><p>懒加载：是延迟加载，需要满足一定条件的时候再加载对应的资源，例如窗口滑动到某个位置才显示相应的图片，减少不必要的请求，缓解服务器压力。</p></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p>提高网页加载速度</p></li><li><p>减少后台服务器压力</p></li><li><p>提升用户体验</p></li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>以下以图片的加载为例。</p><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>在某些网站浏览一组图片时，只给你显示第一张图片，然后可以通过一些形式（点击按钮）来切换图片，在你浏览第一张图片时，其实一整组图片都预加载完了，之后切换就可以了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>preLoad<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- loading.gif是占位符，默认图片 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;pic&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;onLeft()&quot;</span>&gt;</span>Left<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;onRight()&quot;</span>&gt;</span>Right<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">//获取图片元素</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;img&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">//设置索引</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">//图片资源</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> imgData = [<span class="hljs-string">&#x27;img1.png&#x27;</span>, <span class="hljs-string">&#x27;img2.png&#x27;</span>, <span class="hljs-string">&#x27;img3.png&#x27;</span>, <span class="hljs-string">&#x27;img4.png&#x27;</span>, <span class="hljs-string">&#x27;img5.png&#x27;</span>];</span><br><span class="language-javascript">    <span class="hljs-comment">//预加载图片</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">preLoad</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      imgData.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//创建一个Image对象并设置图片的src属性，这样就可以预加载图片</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();</span><br><span class="language-javascript">        image.<span class="hljs-property">src</span> = path;</span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-title function_">preLoad</span>();</span><br><span class="language-javascript">    img.<span class="hljs-property">src</span> = imgData[index];</span><br><span class="language-javascript">    <span class="hljs-comment">//左按钮点击事件</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">onLeft</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      index--;</span><br><span class="language-javascript">      <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="language-javascript">        index = imgData.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      img.<span class="hljs-property">src</span> = imgData[index];</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-comment">//右按钮点击事件</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">onRight</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      index++;</span><br><span class="language-javascript">      <span class="hljs-keyword">if</span> (index &gt; imgData.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) &#123;</span><br><span class="language-javascript">        index = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      img.<span class="hljs-property">src</span> = imgData[index];</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>当图片数量比较多时，要是一次性请求加载，加载时间可能需要数十秒。所以可以先出现用户界面需要的图片，将来可能需要出现在页面上的，等将来到了再加载。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>lazyload<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- loading.gif是占位符，默认图片 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;pic&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;img1.png&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;pic&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;img2.png&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;pic&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;img3.png&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;pic&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;img4.png&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;pic&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;img5.png&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">//获取页面上所有的img元素，并存储在变量imgs中</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> images = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;img&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">//定义一个函数lazyload</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyLoad</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">//获取页面滚动的高度，当前页面相对于窗口显示区左上角的Y位置</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageYOffset</span>;</span><br><span class="language-javascript">      <span class="hljs-comment">//遍历所有的img元素</span></span><br><span class="language-javascript">      images.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">image</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//判断图片是否在可视区域内</span></span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (image.<span class="hljs-property">offsetTop</span> &lt; (<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> + scrollTop)) &#123;</span><br><span class="language-javascript">          <span class="hljs-comment">//如果在可视区域内，就将图片的data-src属性的值赋给src属性</span></span><br><span class="language-javascript">          image.<span class="hljs-property">src</span> = image.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-src&#x27;</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-comment">//监听页面滚动事件</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-title function_">lazyLoad</span>();</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>预加载和懒加载都是基础的前端开发技能，了解并善用是必须的。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>前端</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解CSS</title>
    <link href="/2022/07/25/%E7%90%86%E8%A7%A3CSS/"/>
    <url>/2022/07/25/%E7%90%86%E8%A7%A3CSS/</url>
    
    <content type="html"><![CDATA[<p>本文于字节跳动青训营期间创作。</p><span id="more"></span><h2 id="CSS-是什么？"><a href="#CSS-是什么？" class="headerlink" title="CSS 是什么？"></a>CSS 是什么？</h2><p>CSS (Cascading Style Sheets) 又称层叠样式表，主要与HTML一同使用，被用来定义页面元素的样式，是用来控制网页外观的一门技术。它可以为HTML页面设置字体和颜色、添加位置和大小、添加动画效果等。</p><h3 id="CSS-的工作流程"><a href="#CSS-的工作流程" class="headerlink" title="CSS 的工作流程"></a>CSS 的工作流程</h3><p><img src="https://s2.loli.net/2024/02/16/ocisuEfmpwng5x9.jpg" alt="工作原理"></p><h3 id="CSS-的使用"><a href="#CSS-的使用" class="headerlink" title="CSS 的使用"></a>CSS 的使用</h3><p>在页面中使用css的方式有三种。</p><h4 id="外链式"><a href="#外链式" class="headerlink" title="外链式"></a>外链式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./css/style.css&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">   <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">     <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;</span><br><span class="language-css">     <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;</span><br><span class="language-css">     <span class="hljs-attribute">border</span>:<span class="hljs-number">3px</span> soild red;</span><br><span class="language-css">   &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="内联式"><a href="#内联式" class="headerlink" title="内联式"></a>内联式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:100px; height:100px; border:3px soild red;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="选择器与属性"><a href="#选择器与属性" class="headerlink" title="选择器与属性"></a>选择器与属性</h2><p>选择器 (Selector) 会找到并选择页面中的元素，以便给它们设置样式。</p><p>选择器可以使用多种方式选择元素：</p><ul><li>按照标签名、类名或id</li><li>按照属性</li><li>按照 DOM 树中的位置</li></ul><p>选择器有多种类型：</p><h3 id="通配选择器"><a href="#通配选择器" class="headerlink" title="通配选择器"></a>通配选择器</h3><p>在 CSS 中，一个星号 (<code>*</code>) 就是一个通配选择器。它可以匹配任意类型的 HTML 元素。在配合其他简单选择器的时候，省略掉通配选择器会有同样的效果。比如，<code>*.warning</code> 和<code>.warning</code> 的效果完全相同。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">*<span class="hljs-selector-class">.warning</span> &#123;<span class="hljs-attribute">color</span>:red;&#125;<br>*<span class="hljs-selector-id">#maincontent</span> &#123;<span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blue;&#125;<br></code></pre></td></tr></table></figure><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>标签选择器主要针对的是页面中某个标签中的样式设置，它的作用范围是这个页面内所有写在该标签内的内容，标签选择器可以定义多个标签的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>类选择器在定义的时候需要 “.” 来做前缀，类名是自定义的，然后在括号内定义属性和属性值。它不是直接作用在该页面中，而是需要使用class方法去自定义要作用的标签</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.MyClass</span> &#123;<br><span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义完类选择器的样式之后，使用class方法去设置要调用改样式的标签。使用class方法调用类选择器中的样式的时候，直接接类名即可，不需要输入”.”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;MyClass&quot;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>类选择器可以在页面中的多个标签内重复使用，也可以中定义多个类选择器。</p><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>ID选择器使用”#”作前缀，标识名照样是自定义的。然后括号内输入要修改样式的属性和属性值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#MyId</span> &#123;<br><span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>内定义好ID选择器之后，在需要使用该样式的标签内使用ID方法即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;MyId&quot;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ID&#x3D;”标识名” 需要注意的是ID选择器可以创建多个，但一个id选择器中的样式只能在页面中的一个标签内使用一次。</p><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>类选择器 和 ID 选择器都属于 属性选择器。 应为本质上 <strong>类选择器</strong> 是 匹配 HTML 中 <strong>class 的属性值</strong>， <strong>ID 选择器</strong> 是 匹配 HTML 中的 <strong>Id 属性值</strong>。</p><p>但此处说的属性选择器则是可以根据元素的属性及属性值来选择元素，与类选择器、ID选择器略有不同。</p><p>属性值 直接匹配 选择器包括下面4 种：</p><h4 id="简单属性选择"><a href="#简单属性选择" class="headerlink" title="简单属性选择"></a>简单属性选择</h4><p>如果希望选择有某个属性的元素，而不论属性值是什么，可以使用简单属性选择器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*把包含标题（title）的所有元素变为红色*/</span><br>*<span class="hljs-selector-attr">[title]</span> &#123;<span class="hljs-attribute">color</span>:red;&#125;<br><br><span class="hljs-comment">/*对有 href 属性的锚（a 元素）应用样式*/</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href]</span> &#123;<span class="hljs-attribute">color</span>:red;&#125;<br><br><span class="hljs-comment">/*将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色*/</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href]</span><span class="hljs-selector-attr">[title]</span> &#123;<span class="hljs-attribute">color</span>:red;&#125;<br></code></pre></td></tr></table></figure><h4 id="根据具体属性值选择"><a href="#根据具体属性值选择" class="headerlink" title="根据具体属性值选择"></a>根据具体属性值选择</h4><p>除了选择拥有某些属性的元素，还可以进一步缩小选择范围，只选择有特定属性值的元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*将指向 Web 服务器上某个指定文档的超链接变成红色*/</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;http://www.juejin.cn/about.html&quot;</span>]</span> &#123;<span class="hljs-attribute">color</span>: red;&#125;<br><br><span class="hljs-comment">/*与简单属性选择器类似，可以把多个属性-值选择器链接在一起来选择一个文档*/</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;http://www.juejin.cn/&quot;</span>]</span><span class="hljs-selector-attr">[title=<span class="hljs-string">&quot;juejin&quot;</span>]</span> &#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><p>请注意，这种格式要求必须与属性值完全匹配。</p><p>如果属性值包含用空格分隔的值列表，匹配就可能出问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;important warning&quot;</span>&gt;</span>This paragraph is a very important warning.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[class=<span class="hljs-string">&quot;important warning&quot;</span>]</span> &#123;<span class="hljs-attribute">color</span>: red;&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="根据部分属性值选择"><a href="#根据部分属性值选择" class="headerlink" title="根据部分属性值选择"></a>根据部分属性值选择</h4><p>如果需要根据属性值中的词列表的某个词进行选择，则需要使用波浪号（~），它能用于任何属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*选择 class 属性中包含 important 的元素*/</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[class~=<span class="hljs-string">&quot;important&quot;</span>]</span> &#123;<span class="hljs-attribute">color</span>: red;&#125;<br><br><span class="hljs-comment">/*这个规则会选择 title 文本包含 &quot;Figure&quot; 的所有图像。没有 title 属性或者 title 属性中不包含 &quot;Figure&quot; 的图像都不会匹配。*/</span><br><span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[title~=<span class="hljs-string">&quot;Figure&quot;</span>]</span> &#123;<span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid gray;&#125;<br></code></pre></td></tr></table></figure><p>如果忽略了波浪号，则说明需要完成完全值匹配。</p><h4 id="特定属性选择类型"><a href="#特定属性选择类型" class="headerlink" title="特定属性选择类型"></a>特定属性选择类型</h4><p>该类型需要使用竖杠（|）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*这个规则会选择 lang 属性等于 en 或以 en- 开头的所有元素*/</span><br>*<span class="hljs-selector-attr">[lang|=<span class="hljs-string">&quot;en&quot;</span>]</span> &#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><p>根据以上规则，以下示例标记中的前三个元素将被选中，而不会选择后两个元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">/*会被选中*/<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en-us&quot;</span>&gt;</span>Greetings!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en-au&quot;</span>&gt;</span>G&#x27;day!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>/*不会被选中*/<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;fr&quot;</span>&gt;</span>Bonjour!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;cy-en&quot;</span>&gt;</span>Jrooana!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><p>组合选择器可以让多个选择器公用同一个CSS样式代码。</p><h4 id="后代组合"><a href="#后代组合" class="headerlink" title="后代组合 ( )"></a>后代组合 ( )</h4><p>后代选择器用于选取某元素的后代元素，使用空格分隔。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*选取所有&lt;div&gt;元素中的&lt;p&gt;元素应用样式*/</span><br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">background-color</span>:red; &#125;<br></code></pre></td></tr></table></figure><h4 id="亲子组合"><a href="#亲子组合" class="headerlink" title="亲子组合 (&gt;)"></a>亲子组合 (&gt;)</h4><p>子元素选择器只能选择作为某元素直接或一级子元素的元素，使用（&gt;）连接。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*选择&lt;div&gt;元素中所有直接子元素&lt;p&gt;*/</span><br><span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">background-color</span>:red; &#125;<br></code></pre></td></tr></table></figure><h4 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器 (~)"></a>兄弟选择器 (~)</h4><p>找到指定的元素后面的所有满足条件的兄弟元素，使用（~）连接。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*选择&lt;p&gt;元素后的所有&lt;h3&gt;元素*/</span><br><span class="hljs-selector-tag">p</span> ~ <span class="hljs-selector-tag">h3</span> &#123; <span class="hljs-attribute">color</span>:red; &#125;<br></code></pre></td></tr></table></figure><h4 id="相邻选择器"><a href="#相邻选择器" class="headerlink" title="相邻选择器 (+)"></a>相邻选择器 (+)</h4><p>该选择器使用（+）连接，选择紧接在另一个元素后的元素，而且二者有相同的父元素，兄弟只会影响下面的兄弟的样式，不影响上面兄弟的样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*选择与&lt;h1&gt;元素相邻的&lt;p&gt;元素*/</span><br><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">50px</span>; <span class="hljs-attribute">color</span>:red; &#125;<br></code></pre></td></tr></table></figure><h4 id="分组选择器"><a href="#分组选择器" class="headerlink" title="分组选择器 (,)"></a>分组选择器 (,)</h4><p>分组选择器使用逗号把同组内不同对象分隔，其本质上不是一种选择器类型，而是一种选择器使用方法。当多个对象定义了相同的样式时，就可以把它们分成一组，这样能够简化代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*定义所有级别的标题和段落行高为22px*/</span><br><span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">h2</span>,<span class="hljs-selector-tag">h3</span>,<span class="hljs-selector-tag">h4</span>,<span class="hljs-selector-tag">h5</span>,<span class="hljs-selector-tag">h6</span>,<span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">line-height</span>:<span class="hljs-number">22px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>伪类通常用于标记一些特殊的样，用于控制一个元素在不同动作下有不同的样式。</p><p>伪类主要有两方面的用处，一方面是标记一些特殊的状态，另外还有一类伪类是有筛选的功能。</p><p>以下仅记录一些常用的伪类。</p><h4 id="状态伪类"><a href="#状态伪类" class="headerlink" title="状态伪类"></a>状态伪类</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*选取未访问过的超链接元素。如果我们注意过搜索引擎的结果的话，它里面的链接只要点过的就会变色，从而标记哪个链接是访问过的*/</span><br><span class="hljs-selector-pseudo">:link</span>&#123;&#125;<br><br><span class="hljs-comment">/*选取访问过的超链接元素。和第一条相反，:visited 是用来标记哪个链接是已经访问过的，防止重复点击*/</span><br><span class="hljs-selector-pseudo">:visited</span>&#123;&#125;<br><br><span class="hljs-comment">/*选取鼠标悬停的元素,当鼠标放在一个元素上时显示的样式*/</span><br><span class="hljs-selector-pseudo">:hover</span>&#123;&#125;<br><br><span class="hljs-comment">/*选取点中的元素。这个伪类的作用在刚才提到过了，当我们希望按钮有操作反馈的时候，可以用它来标记操作反馈的样式。当然这个伪类也是可以通用的，并不是只能用在按钮上*/</span><br><span class="hljs-selector-pseudo">:active</span>&#123;&#125;<br><br><span class="hljs-comment">/*选取获得焦点的元素。这个伪类用来标识获得焦点的元素，比如搜索框在聚焦的时候有个比较明显的边框，方便用户知道当前在可输入的状态*/</span><br><span class="hljs-selector-pseudo">:focus</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="筛选伪类"><a href="#筛选伪类" class="headerlink" title="筛选伪类"></a>筛选伪类</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*选取没有子元素的元素。比如选择空的 span，就可以用 span:empty 选择器来选择。这里要注意元素内有空格的话也不能算空，不会被这个伪类选中*/</span><br><span class="hljs-selector-pseudo">:empty</span>&#123;&#125;<br><br><span class="hljs-comment">/*选取勾选状态的 input 元素， 只对 radio 和 checkbox 生效*/</span><br><span class="hljs-selector-pseudo">:checked</span>&#123;&#125;<br><br><span class="hljs-comment">/*选取禁用的表单元素*/</span><br><span class="hljs-selector-pseudo">:disabled</span>&#123;&#125;<br><br><span class="hljs-comment">/*选取当前选择器下第一个元素*/</span><br><span class="hljs-selector-pseudo">:first</span>-child&#123;&#125;<br><br><span class="hljs-comment">/*和 first-child 相反，选取当前选择器下最后一个元素*/</span><br><span class="hljs-selector-pseudo">:last-child</span>&#123;&#125;<br><br><span class="hljs-comment">/*选取指定位置的元素。这个伪类是有参数的，参数可以支持 an+b 的形式，这里 a 和 b 都是可变的，n 从0起。使用这个伪类可以做到选择第几个，或者选择序号符合 an+b 的所有元素。比如使用 li:nth-child(2n+1)，就可以选中 li 元素中序号是2的整数倍加1的所有元素，也就是第1、3、5、7、9、2n+1个 li 元素*/</span><br><span class="hljs-selector-pseudo">:nth-child</span>(an+<span class="hljs-selector-tag">b</span>)&#123;&#125;<br><br><span class="hljs-comment">/*这个伪类和 nth-child 相似，只不过在计数的时候，这个伪类是从后往前计数*/</span><br><span class="hljs-selector-pseudo">:nth-last-child</span>(an+<span class="hljs-selector-tag">b</span>)&#123;&#125;<br><br><span class="hljs-comment">/*选取唯一子元素。如果一个元素的父元素只有它一个子元素，这个伪类就会生效。如果一个元素还有兄弟元素，这个伪类就不会对它生效*/</span><br><span class="hljs-selector-pseudo">:only-child</span>&#123;&#125;<br><br><span class="hljs-comment">/*选取唯一的某个类型的元素。如果一个元素的父元素里只有它一个当前类型的元素，这个伪类就会生效。这个伪类允许父元素里有其他元素，只要不和自己一样就可以*/</span><br><span class="hljs-selector-pseudo">:only-of-type</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>伪元素选择器是用于向某些元素设置特殊效果。伪元素选择器选中的并不是真实的 DOM 元素，所以叫伪元素选择器。常用的伪元素选择器有5个。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*为某个元素的第一行文字使用样式*/</span><br><span class="hljs-selector-pseudo">::first-line</span>&#123;&#125;<br><br><span class="hljs-comment">/*为某个元素中的文字的首字母或第一个字使用样式*/</span><br><span class="hljs-selector-pseudo">::first-letter</span>&#123;&#125;<br><br><span class="hljs-comment">/*在某个元素之前插入一些内容*/</span><br><span class="hljs-selector-pseudo">::before</span>&#123;&#125;<br><br><span class="hljs-comment">/*在某个元素之后插入一些内容*/</span><br><span class="hljs-selector-pseudo">::after</span>&#123;&#125;<br><br><span class="hljs-comment">/*对光标选中的元素添加样式*/</span><br><span class="hljs-selector-pseudo">::selection</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>伪元素选择器构造的元素是虚拟的，所以不能用 JS 去操作它。 </li><li>如果同时使用了 before 和 first-letter 两个伪类，第一个字是要从 before 里的内容开始算起的，如果 before里面的内容是一个非文本元素，那 first-letter 也会作用在这个非文本元素上，但是不一定能生效。 </li><li>first-line 和 first-letter 不适用于内联元素，在内联元素中这两个选择器都会失效。 </li><li>在 CSS3 中，规定了伪类用一个冒号（:）表示，伪元素用两个冒号表示（::）。但除了 selection，其余四个伪元素选择器已经在 CSS2 中存在且和伪类用的是一样的单冒号表示的。为了向下兼容，现在的浏览器中伪元素选择器用单冒号和双冒号都可以。在没有兼容问题的情况下，还是建议大家按着新的 CSS3 标准来开发。</li></ol></blockquote><h2 id="选择器的特异度"><a href="#选择器的特异度" class="headerlink" title="选择器的特异度"></a>选择器的特异度</h2><p>选择器的特异度由选择器本身的组件确定。</p><p>如果一个元素有两个或多个冲突的属性声明，那么有最特异度高的声明就会胜出。</p><p>特异度表述为4个部分，如：(0, 0, 0, 0)，从左到右的权重由高到低。</p><h3 id="权重排行（高到低）："><a href="#权重排行（高到低）：" class="headerlink" title="权重排行（高到低）："></a>权重排行（高到低）：</h3><ol><li>行内样式 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">（!important）<br></code></pre></td></tr></table></figure></li><li>ID选择器 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#id</span><br></code></pre></td></tr></table></figure></li><li>class、属性、伪类选择器 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.title</span><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;text&quot;</span>]</span><br><span class="hljs-selector-pseudo">:hover</span><br></code></pre></td></tr></table></figure></li><li>类型和伪元素选择器 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><br><span class="hljs-selector-pseudo">::before</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="权重向量"><a href="#权重向量" class="headerlink" title="权重向量"></a>权重向量</h3><p>(0, 0, 0, 0)<br>(行内样式，ID选择器，class&#x2F;属性&#x2F;伪类选择器&#x2F;，类型&#x2F;伪元素)</p><p>若权重相同，则定义靠后优先。</p><p>实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;item1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item1&quot;</span>&gt;</span>item1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item2&quot;</span>&gt;</span>item2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item3&quot;</span>&gt;</span>item3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-comment">/* (0, 1, 3, 1) */</span></span><br><span class="language-css">    <span class="hljs-selector-id">#container</span> <span class="hljs-selector-class">.menu</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.item2</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff4757</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-comment">/* (0, 1, 2, 1) */</span></span><br><span class="language-css">    <span class="hljs-selector-id">#container</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>)<span class="hljs-selector-class">.item2</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>: <span class="hljs-number">#7bed9f</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    </span><br><span class="language-css"><span class="hljs-comment">/* (0, 1, 1, 1) */</span></span><br><span class="language-css">    <span class="hljs-selector-id">#container</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.item2</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffa502</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-comment">/* (0, 0, 1, 1) */</span></span><br><span class="language-css">    <span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.item2</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>: <span class="hljs-number">#5352ed</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-comment">/* (0, 0, 1, 0) */</span></span><br><span class="language-css">    <span class="hljs-selector-class">.item2</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff6b81</span></span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="无继承性的属性"><a href="#无继承性的属性" class="headerlink" title="无继承性的属性"></a>无继承性的属性</h3><ol><li>display：元素布局类型</li><li>文本属性：<ul><li>vertical-align：垂直文本对齐</li><li>text-decration：规定添加到文本的装饰</li><li>text-shadow：文本阴影效果</li><li>white-space：空白符的处理</li><li>unicode-bidi：设置文本的方向</li></ul></li><li>盒子模型的属性：<ul><li>width</li><li>height</li><li>margin</li><li>border</li><li>padding</li></ul></li><li>背景属性：<ul><li>background</li><li>background-color</li><li>background-image</li><li>background-repeat</li><li>background-position</li><li>background-attachment</li></ul></li><li>定位属性：<ul><li>float</li><li>clear</li><li>position</li><li>top</li><li>right</li><li>bottom</li><li>left</li><li>min-width</li><li>min-height</li><li>max-width</li><li>max-height</li><li>overflow</li><li>clip</li><li>z-index</li></ul></li><li>生成内容属性：<ul><li>content</li><li>counter-reset</li><li>counter-increment</li></ul></li><li>轮廓样式属性：<ul><li>outline-style</li><li>outline-width</li><li>outline-color</li><li>outline</li></ul></li><li>页面样式属性：<ul><li>size</li><li>page-break-before</li><li>page-break-after</li></ul></li><li>声音样式属性：<ul><li>pause-before</li><li>pause-after</li><li>pause</li><li>cue-before</li><li>cue-after</li><li>cue</li><li>play-during</li></ul></li></ol><h3 id="有继承性的属性"><a href="#有继承性的属性" class="headerlink" title="有继承性的属性"></a>有继承性的属性</h3><ol><li>字体系列属性：<ul><li>font-family：字体系列</li><li>font-weight：字体的粗细</li><li>font-size：字体的大小</li><li>font-style：字体的风格</li></ul></li><li>文本系列属性<ul><li>text-indent：文本缩进</li><li>text-align：文本水平对齐</li><li>line-height：行高</li><li>word-spacing：单词之间的间距</li><li>letter-spacing：中文或者字母之间的间距</li><li>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li><li>color：文本颜色</li></ul></li><li>元素可见性：<ul><li>visibility：控制元素显示隐藏</li></ul></li><li>列表布局属性：<ul><li>list-style：列表风格，包括list-style-type、list-style-image等</li></ul></li><li>光标属性：<ul><li>cursor：光标显示为何种形态</li></ul></li></ol><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>内容主要来源：<a href="https://juejin.cn/post/6844903634849759239#heading-21">一篇全面的CSS布局学习指南(译) </a></p><p>布局（layout）即确定内容的大小和位置的算法，其根据元素、容器、兄弟节点和内容等信息来计算。</p><p>css中的布局有多种。</p><h3 id="常规流布局（normal-flow）"><a href="#常规流布局（normal-flow）" class="headerlink" title="常规流布局（normal flow）"></a>常规流布局（normal flow）</h3><p>在正常流中，元素盒子（boxes）会基于文档的写作模式（writing mode）一个接一个地排列。这就意味着，如果你的写作模式是水平方向的（句子是从左到右或从右到左书写），正常流会垂直地一个接一个排列页面的块级元素。</p><p>当然，如果你是在一个垂直方向的写作模式下，句子是垂直方向书写的，所以块级元素会水平方法排列。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/3/1645fd10965531f9~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="normal"></p><ul><li>根元素、浮动和绝对定位的元素会脱离常规流</li><li>其他元素都在常规流之内（in-flow）</li><li>常规流中的盒子，在某种 <strong>排版上下文</strong> 中参与布局</li></ul><h3 id="浮动布局-float"><a href="#浮动布局-float" class="headerlink" title="浮动布局 (float)"></a>浮动布局 (float)</h3><p>浮动布局被用来将盒子（box）置于左侧或右侧，同时让内容环绕其展示。</p><p>如果要让一个元素进行浮动，需要为该元素设置一个值为<code>left</code>或<code>right</code>等的<code>float</code>属性。默认值为<code>none</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123; <span class="hljs-attribute">float</span>: left &#125;<br><br><span class="hljs-comment">/* 其他常见的float的值 */</span><br><span class="hljs-selector-class">.item</span> &#123;<span class="hljs-attribute">float</span>: left; &#125; <span class="hljs-comment">/*表明元素必须浮动在其所在的块容器左侧的关键字。*/</span><br><span class="hljs-selector-class">.item</span> &#123;<span class="hljs-attribute">float</span>: right; &#125; <span class="hljs-comment">/*表明元素必须浮动在其所在的块容器右侧的关键字。*/</span><br><span class="hljs-selector-class">.item</span> &#123;<span class="hljs-attribute">float</span>: none; &#125; <span class="hljs-comment">/*表明元素不进行浮动的关键字。*/</span><br><span class="hljs-selector-class">.item</span> &#123;<span class="hljs-attribute">float</span>: inline-start; &#125; <span class="hljs-comment">/*关键字，表明元素必须浮动在其所在块容器的开始一侧，在 `ltr` 脚本中是左侧，在 `rtl` 脚本中是右侧。*/</span><br><span class="hljs-selector-class">.item</span> &#123;<span class="hljs-attribute">float</span>: inline-end; &#125; <span class="hljs-comment">/*关键字，表明元素必须浮动在其所在块容器的结束一侧，在 `ltr` 脚本中是右侧，在 `rtl` 脚本中是左侧。*/</span><br></code></pre></td></tr></table></figure><h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p>一旦你对一个元素应用了浮动，所有接下来的元素都会环绕它直到内容处于它下方且开始应用正常文档流。如果你想要避免这种情况，可以手动去清除浮动。</p><p>当你不想要某个元素受到其之前的浮动元素影响时，为其添加<code>clear</code>属性即可。使用<code>left</code>值可以清除左浮动效果，<code>right</code>值为右浮动，<code>both</code>则会清除左右浮动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clear</span> &#123; <span class="hljs-attribute">clear</span>: both; &#125;<br><br><span class="hljs-comment">/*其他常见的clear的值*/</span><br><span class="hljs-selector-class">.clear</span> &#123; <span class="hljs-attribute">clear</span>: none; &#125; <span class="hljs-comment">/*元素不会被向下移动以清除浮动。*/</span><br><span class="hljs-selector-class">.clear</span> &#123; <span class="hljs-attribute">clear</span>: left; &#125; <span class="hljs-comment">/*元素被向下移动以清除左浮动。*/</span><br><span class="hljs-selector-class">.clear</span> &#123; <span class="hljs-attribute">clear</span>: right; &#125; <span class="hljs-comment">/*元素被向下移动以清除右浮动。*/</span><br><span class="hljs-selector-class">.clear</span> &#123; <span class="hljs-attribute">clear</span>: both; &#125; <span class="hljs-comment">/*元素被向下移动以清除左右浮动。*/</span><br><span class="hljs-selector-class">.clear</span> &#123; <span class="hljs-attribute">clear</span>: inline-start; &#125; <span class="hljs-comment">/*元素被向下移动以清除其包含块的起始侧浮动，即 ltr 时清除左浮动，rtl 时清除右浮动。*/</span><br><span class="hljs-selector-class">.clear</span> &#123; <span class="hljs-attribute">clear</span>: inline-end; &#125; <span class="hljs-comment">/*元素被向下移动以清除其包含块的结束侧浮动，即 ltr 时清除右浮动，rtl 时清除左浮动。*/</span><br></code></pre></td></tr></table></figure><h3 id="定位-Positioning"><a href="#定位-Positioning" class="headerlink" title="定位 (Positioning)"></a>定位 (Positioning)</h3><p><strong><code>position</code></strong> 属性用于指定一个元素在文档中的定位方式。</p><p>想要把一个元素从正常流中移除，或者改变其在正常文档流中的位置，可以使用CSS中的<code>position</code>属性。当处于正常文档流时，元素的<code>position</code>属性为<code>static</code>。在块级维度上元素会一个接一个排列下去，当你滚动页面时元素也会随着滚动。</p><p>当你改变元素的position属性时，通常情况下你也会设置一些偏移量来使元素相对于参照点进行一定的移动。不同的position值会产生不同的参照点。</p><h4 id="静态定位（STATIC-POSTIONING）"><a href="#静态定位（STATIC-POSTIONING）" class="headerlink" title="静态定位（STATIC POSTIONING）"></a>静态定位（STATIC POSTIONING）</h4><p>该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index</code> 属性无效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123; <span class="hljs-attribute">position</span>: static; &#125;<br></code></pre></td></tr></table></figure><h4 id="相对定位（RELATIVE-POSTIONING）"><a href="#相对定位（RELATIVE-POSTIONING）" class="headerlink" title="相对定位（RELATIVE POSTIONING）"></a>相对定位（RELATIVE POSTIONING）</h4><p>在绝对定位中，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。</p><p>如果一个元素具有属性<code>position: relative</code>，那么它偏移的参照位是其原先在正常文档流中的位置。你可以使用<code>top</code>、<code>left</code>、<code>bottom</code>和<code>right</code>属性来相对其正常流位置进行移动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123; <span class="hljs-attribute">position</span>: relative; <span class="hljs-attribute">bottom</span>: <span class="hljs-number">50px</span>; &#125;<br></code></pre></td></tr></table></figure><blockquote><p>相对定位是不脱离标准流的, 会继续在标准流中占用一份空间<br>在相对定位中同一个方向上的定位属性只能使用一个<br>由于相对定位是不脱离标准流的, 所以在相对定位中是区分块级元素&#x2F;行内元素&#x2F;行内块级元素<br>由于相对定位是不脱离标准流的, 并且相对定位的元素会占用标准流中的位置, 所以当给相对定位 的元素设置margin&#x2F;padding等属性的时会影响到标准流的布局</p></blockquote><h4 id="绝对定位（ABSOLUTE-POSTIONING）"><a href="#绝对定位（ABSOLUTE-POSTIONING）" class="headerlink" title="绝对定位（ABSOLUTE POSTIONING）"></a>绝对定位（ABSOLUTE POSTIONING）</h4><p>给一个元素设置 <code>position: absolute</code> ，其元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</p><p>因此，当你为某个元素设置 <code>position: absolute</code> 时，首先发生的变化是该元素会定位在视口的左上角。你可以通过设置 <code>top</code> 、<code>left</code> 、<code>bottom</code> 和 <code>right</code> 偏移量属性来将元素移动到你想要的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123; <span class="hljs-attribute">position</span>: absolute; <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>; <span class="hljs-attribute">right</span>: <span class="hljs-number">20px</span>; &#125;<br></code></pre></td></tr></table></figure><ul><li>绝对定位参考点：<ol><li>规律：默认情况下所有的绝对定位的元素, 无论有没有祖先元素, 都会以 <code>body</code> 作为参考点。</li><li>如果一个绝对定位的元素有祖先元素, 并且祖先元素也是定位流, 那么这个绝对定位的元素就会以定位流的那个祖先元素作为参考点。<ol><li>只要是这个绝对定位元素的祖先元素都可以 。</li><li>指的定位流是指绝对定位&#x2F;相对定位&#x2F;固定定位 。</li><li>定位流中只有静态定位不行。</li></ol></li><li>如果一个绝对定位的元素有祖先元素, 并且祖先元素也是定位流, 而且祖先元素中有多个元素都是定位流, 那么这个绝对定位的元素会以离它最近的那个定位流的祖先元素为参考点。</li></ol></li><li>绝对定位注意点：<ol><li>绝对定位的元素是脱离标准流的 。</li><li>绝对定位的元素是不区分块级元素&#x2F;行内元素&#x2F;行内块级元素 。</li><li>如果一个绝对定位的元素是以 <code>body</code> 作为参考点, 那么其实是以网页首屏的宽度和高度作为参考点, 而不是以整个网页的宽度和高度作为参考点 。</li><li>一个绝对定位的元素会忽略祖先元素的 <code>padding</code>。</li></ol></li><li>绝对定位-子绝父相：<ul><li>相对定位弊端：相对定位不会脱离标准流, 会继续在标准流中占用一份空间, 所以不利于布局界面。</li><li>绝对定位弊端：默认情况下绝对定位的元素会以 <code>body</code> 作为参考点, 所以会随着浏览器的宽度高度的变化而变化。</li><li>子绝父相：子元素用绝对定位, 父元素用相对定位。（如果不这么做，子元素就会相对 <code>body</code> 或浏览器定位产生不好的效果。）</li></ul></li></ul><h4 id="固定定位（FIXED-POSTIONING）"><a href="#固定定位（FIXED-POSTIONING）" class="headerlink" title="固定定位（FIXED POSTIONING）"></a>固定定位（FIXED POSTIONING）</h4><p><code>position: fixed</code> 的元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。<code>fixed</code> 属性会创建新的层叠上下文。当元素祖先的 <code>transform</code> ， <code>perspective</code> 或 <code>filter</code> 属性非 <code>none</code> 时，容器由视口改为该祖先。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123; <span class="hljs-attribute">position</span>: fixed; <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>; <span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>; &#125;<br></code></pre></td></tr></table></figure><p>当你想要一个固定导航栏一直停留在屏幕上时这会非常有效。</p><h4 id="STICKY-定位"><a href="#STICKY-定位" class="headerlink" title="STICKY 定位"></a>STICKY 定位</h4><p>设置 <code>position: sticky</code> 会让元素在页面滚动时如同在正常流中，但当其滚动到相对于视口的某个特定位置时就会固定在屏幕上，如同fixed一般。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123; <span class="hljs-attribute">position</span>: sticky; <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>; &#125;<br></code></pre></td></tr></table></figure><h3 id="弹性布局（Flex-Layout）"><a href="#弹性布局（Flex-Layout）" class="headerlink" title="弹性布局（Flex Layout）"></a>弹性布局（Flex Layout）</h3><p>弹性盒子（Flexbox）布局是一种为一维布局而设计的布局方法。一维的意思是你希望内容是按行或者列来布局。你可以使用 <code>display: flex</code> 来将元素变为弹性布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123; <span class="hljs-attribute">display</span>: flex; &#125;<br></code></pre></td></tr></table></figure><h4 id="Flex的主轴与交叉轴"><a href="#Flex的主轴与交叉轴" class="headerlink" title="Flex的主轴与交叉轴"></a>Flex的主轴与交叉轴</h4><p>当使用 flex 布局时，首先想到的是两根轴线 — 主轴和交叉轴。主轴由 <code>flex-direction</code> 定义，另一根轴垂直于它。我们使用 flexbox 的所有属性都跟这两根轴线有关，所以有必要在一开始首先理解它。</p><h5 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h5><p>主轴由 <code>flex-direction</code> 定义，可以取 4 个值（默认为 <code>row</code> ）：</p><ul><li>row</li><li>row-reverse</li><li>column</li><li>column-reverse</li></ul><p>如果你选择了 <code>row</code> 或者 <code>row-reverse</code>，你的主轴将沿着 <strong>inline</strong> 方向延伸。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.itme</span> &#123; <br><span class="hljs-attribute">display</span>: flex; <br><span class="hljs-attribute">flex-direction</span>: row; <br>&#125;<br></code></pre></td></tr></table></figure><p>选择 <code>column</code> 或者 <code>column-reverse</code> 时，你的主轴会沿着上下方向延伸 — 也就是 <strong>block 排列的方向。</strong></p><h5 id="交叉轴"><a href="#交叉轴" class="headerlink" title="交叉轴"></a>交叉轴</h5><p>交叉轴垂直于主轴，所以如果你的<code>flex-direction</code> (主轴) 设成了 <code>row</code> 或者 <code>row-reverse</code> 的话，交叉轴的方向就是沿着列向下的。</p><p>如果主轴方向设成了 <code>column</code> 或者 <code>column-reverse</code>，交叉轴就是水平方向。</p><p>理解主轴和交叉轴的概念对于对齐 flexbox 里面的元素是很重要的；flexbox 的特性是沿着主轴或者交叉轴对齐之中的元素。</p><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>虽然<code>flexbox</code>是一维模型，但可以使我们的<code>flex</code>项目应用到多行中。在这样做的时候，您应该把每一行看作一个新的<code>flex</code>容器。任何空间分布都将在该行上发生，而不影响该空间分布的其他行。</p><p>为了实现多行效果，请为属性 <code>flex-wrap</code> 添加一个属性值 <code>wrap</code> 。现在，如果您的项目太大而无法全部显示在一行中，则会换行显示。下面的实时例子包含已给出宽度的项目，对于 <code>flex</code> 容器，项目的子元素总宽度大于容器最大宽度。由于 <code>flex-wrap</code> 的值设置为 <code>wrap</code> ，所以项目的子元素换行显示。若将其设置为 <code>nowrap</code> ，这也是初始值，它们将会缩小以适应容器，因为它们使用的是允许缩小的初始 <code>Flexbox</code> 值。如果项目的子元素无法缩小，使用 <code>nowrap</code> 会导致溢出，或者缩小程度还不够小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123; <br><span class="hljs-attribute">display</span>: flex; <br><span class="hljs-attribute">flex-wrap</span>: wrap;<br><span class="hljs-comment">/*flex-wrap: nowrap;*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一些Flex的属性"><a href="#一些Flex的属性" class="headerlink" title="一些Flex的属性"></a>一些Flex的属性</h4><p>这些flex的属性是用来控制弹性项在主轴上空间大小的。这三个属性是：</p><ul><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li></ul><p>通常可以使用它们的简写形式：<code>flex</code> 。第一个值代表 <code>flex-grow</code> ，第二个是 <code>flex-shrink</code> ，而第三个则是 <code>flex-basis</code> 。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123; <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">200px</span>; &#125;<br></code></pre></td></tr></table></figure><p><code>flex-basis</code> 会为弹性项设置未拉伸和压缩时的初始大小。在上面的例子中，大小是200px，因此我们会给每个项200px的空间大小。但是大多数情况下容器元素大小不会正好被分为许多200px大小的项，而是可能有一些不足或剩余空间。 <code>flex-grow</code> 和 <code>flow-shrink</code> 属性允许我们在容器大小不足或有空余时控制各个弹性项的大小。</p><p>如果 <code>flex-grow</code> 的值是任意的正数，那么弹性项会被允许拉伸来占据更多的空间。因此，在上面的例子中，当各项被设为200px后，所有多余的空间会被每个弹性项平分并填满。</p><p>如果 <code>flex-shrink</code> 的值为任意的正数，那么当弹性项被设置了 <code>flex-basis</code> 后，元素溢出容器时会进行收缩。在上面这个CSS的例子中，如果容器空间不足，每个弹性项会等比例缩放以适应容器的大小。</p><p><code>flex-grow</code> 和 <code>flex-shrink</code> 的值可以是任意的正数。一个具有较大 <code>flex-grow</code> 值的弹性项会在容器有剩余空间时拉伸更大的比例；而一个具有更大 <code>flex-shrink</code> 值的项则会在容器空间不足时被压缩的更多。</p><p>大多数情况下可以用预定义的简写形式。在这个教程中你可能经常会看到这种写法，许多情况下你都可以这么使用。下面是几种预定义的值：</p><ul><li>flex: initial</li><li>flex: auto</li><li>flex: none</li><li>flex: <code>&lt;positive-number&gt;</code></li></ul><p><code>flex: initial</code> 是把 flex 元素重置为 Flexbox 的初始值，它相当于 <code>flex: 0 1 auto</code>。在这里 <code>flex-grow</code> 的值为 0，所以 flex 元素不会超过它们 <code>flex-basis</code> 的尺寸。<code>flex-shrink</code> 的值为 1, 所以可以缩小 flex 元素来防止它们溢出。<code>flex-basis</code> 的值为 <code>auto</code>. Flex 元素尺寸可以是在主维度上设置的，也可以是根据内容自动得到的。</p><p><code>flex: auto</code> 等同于 <code>flex: 1 1 auto</code>；和上面的 <code>flex:initial</code> 基本相同，但是这种情况下，flex 元素在需要的时候既可以拉伸也可以收缩。</p><p><code>flex: none</code> 可以把 flex 元素设置为不可伸缩。它和设置为 <code>flex: 0 0 auto</code> 是一样的。元素既不能拉伸或者收缩，但是元素会按具有 <code>flex-basis: auto</code> 属性的 flexbox 进行布局。</p><p>你在教程中常看到的 <code>flex: 1</code> 或者 <code>flex: 2</code> 等等。它相当于<code>flex: 1 1 0</code>。元素可以在<code>flex-basis</code>为 0 的基础上伸缩。</p><h3 id="网格布局（grid-layout）"><a href="#网格布局（grid-layout）" class="headerlink" title="网格布局（grid layout）"></a>网格布局（grid layout）</h3><p>内容主要来源：<a href="https://juejin.cn/post/6854573220306255880">最强大的 CSS 布局 —— Grid 布局</a></p><p>CSS网格布局（grid layout）是一种用来进行二维布局的技术。二维（two-dimesional）意味着你希望按照行和列来排布你的内容。和弹性盒子类似，网格布局也需要设置一个 <code>display</code> 值。你可以为容器元素设置 <code>display: grid</code> ，并且使用 <code>grid-template-columns</code> 和 <code>grid-template-rows</code> 属性来控制网格中的行与列。</p><p><code>Grid</code> 布局是将容器划分成了“行”和“列”，产生了一个个的网格，我们可以将网格元素放在与这些行和列相关的位置上，从而达到我们布局的目的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123; <br><span class="hljs-attribute">display</span>: grid; <br><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">200px</span> <span class="hljs-number">200px</span>; <br><span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">200px</span> <span class="hljs-number">200px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="grid-template-columns-属性和-grid-template-rows-属性"><a href="#grid-template-columns-属性和-grid-template-rows-属性" class="headerlink" title="grid-template-columns 属性和 grid-template-rows 属性"></a>grid-template-columns 属性和 grid-template-rows 属性</h4><p><code>grid-template-columns</code> 属性设置列宽，<code>grid-template-rows</code> 属性设置行高，这两个属性在 <code>Grid</code> 布局中尤为重要，它们的值是有多种多样的，而且它们的设置是比较相似的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123; <br><span class="hljs-attribute">display</span>: grid; <br><br><span class="hljs-comment">/* 声明了三列，宽度分别为 200px 100px 200px */</span> <br><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">100px</span> <span class="hljs-number">200px</span>; <br><br><span class="hljs-comment">/* 声明了两行，行高分别为 50px 50px */</span> <br><span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">50px</span> <span class="hljs-number">50px</span>; <br><br><span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">5px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>以上表示固定列宽为 200px 100px 200px，行高为 50px 50px 。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/26/17389591c0fc1214~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h5 id="repeat-函数"><a href="#repeat-函数" class="headerlink" title="repeat() 函数"></a>repeat() 函数</h5><p><strong>repeat() 函数</strong>可以简化重复的值。该函数接受两个参数，第一个参数是重复的次数，第二个参数是所要重复的值。比如上面行高都是一样的，我们可以这么去实现，实际效果是一模一样的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123; <br><span class="hljs-attribute">display</span>: grid; <br><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">100px</span> <span class="hljs-number">200px</span>; <br><span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">5px</span>; <br><br><span class="hljs-comment">/* 2行，而且行高都为 50px */</span> <br><span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">2</span>, <span class="hljs-number">50px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="auto-fill-关键字"><a href="#auto-fill-关键字" class="headerlink" title="auto-fill 关键字"></a>auto-fill 关键字</h5><p><strong>auto-fill 关键字</strong>表示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格。<code>grid-template-columns: repeat(auto-fill, 200px)</code> 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123; <br><span class="hljs-attribute">display</span>: grid; <br><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-number">200px</span>); <br><span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">5px</span>; <br><span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/26/17389591c300e81a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h5 id="fr-关键字"><a href="#fr-关键字" class="headerlink" title="fr 关键字"></a>fr 关键字</h5><p><code>Grid</code> 布局还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。<code>fr</code> 单位代表网格容器中可用空间的一等份。<code>grid-template-columns: 200px 1fr 2fr</code> 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1&#x2F;3 和 2&#x2F;3。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123; <br><span class="hljs-attribute">display</span>: grid; <br><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr; <br><span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">5px</span>; <br><span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">50px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/26/17389591ccc256d1~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h5 id="minmax-函数"><a href="#minmax-函数" class="headerlink" title="minmax() 函数"></a>minmax() 函数</h5><p><strong>minmax() 函数</strong>：我们有时候想给网格元素一个最小和最大的尺寸，<code>minmax()</code> 函数产生一个长度范围，表示长度就在这个范围之中都可以应用到网格项目中。它接受两个参数，分别为最小值和最大值。<code>grid-template-columns: 1fr 1fr minmax(300px, 2fr)</code> 的意思是，第三个列宽最少也是要 300px，但是最大不能大于第一第二列宽的两倍。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper-4</span> &#123; <br><span class="hljs-attribute">display</span>: grid; <br><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-built_in">minmax</span>(<span class="hljs-number">300px</span>, <span class="hljs-number">2</span>fr); <br><span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">5px</span>; <br><span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">50px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/26/17389591dc05edac~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h4 id="grid-row-gap-属性、grid-column-gap-属性以及-grid-gap-属性"><a href="#grid-row-gap-属性、grid-column-gap-属性以及-grid-gap-属性" class="headerlink" title="grid-row-gap 属性、grid-column-gap 属性以及 grid-gap 属性"></a>grid-row-gap 属性、grid-column-gap 属性以及 grid-gap 属性</h4><p><code>grid-row-gap</code> 属性、<code>grid-column-gap</code> 属性分别设置行间距和列间距。<code>grid-gap</code> 属性是两者的简写形式。</p><p><code>grid-row-gap: 10px</code> 表示行间距是 10px，<code>grid-column-gap: 20px</code> 表示列间距是 20px。<code>grid-gap: 10px 20px</code> 实现的效果是一样的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123; <br><span class="hljs-attribute">display</span>: grid; <br><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>; <br><span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>; <br><span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">50px</span>; <br>&#125;<br><br><span class="hljs-selector-class">.wrapper-1</span> &#123; <br><span class="hljs-attribute">display</span>: grid; <br><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>; <br><span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">50px</span>; <br><span class="hljs-attribute">grid-row</span>-<span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>; <br><span class="hljs-attribute">grid-column</span>-<span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基于行-列的基本定位方法"><a href="#基于行-列的基本定位方法" class="headerlink" title="基于行&#x2F;列的基本定位方法"></a>基于行&#x2F;列的基本定位方法</h4><p>定位网格元素最简单的方式是使用基于行&#x2F;列（line）的定位方法，只需告诉浏览器从哪一排到哪一排来进行合并。例如，如果你需要一个2*2的网格区域，你可以将指定元素从第一行开始到第三行、从第一列开始到第三列，这样就可以覆盖到四个单元格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123; <br><span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>; <br><span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">3</span>; <br><span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>; <br><span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">3</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>这些属性可以用缩写来表示：<code>grid-column</code>和<code>grid-row</code>，其中起一个值代表起始值，第二个值代表结束值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123; <br><span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>; <br><span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>你也可以让网格项（grid item）占据同一个单元格。支持一些内容间会覆盖的设计。网格项会像通常网页中的元素那样叠起来，在html源码中下面的网格项会叠在其他元素上面。你仍然可以用<code>z-index</code>来控制它的堆叠顺序。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;three&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;four&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;five&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">body</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>; </span><br><span class="language-css"><span class="hljs-attribute">font</span>: <span class="hljs-number">1em</span> Helvetica Neue, Helvetica, Arial, sans-serif; </span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css">* &#123;</span><br><span class="language-css"><span class="hljs-attribute">box-sizing</span>: border-box;</span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">p</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1em</span> <span class="hljs-number">0</span>; </span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.container</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>; </span><br><span class="language-css"><span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">111</span>,<span class="hljs-number">41</span>,<span class="hljs-number">97</span>); </span><br><span class="language-css"><span class="hljs-attribute">border-radius</span>: .<span class="hljs-number">5em</span>; </span><br><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>; </span><br><span class="language-css"><span class="hljs-attribute">display</span>: grid; </span><br><span class="language-css"><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr; </span><br><span class="language-css"><span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>; </span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.container</span> &gt; <span class="hljs-selector-tag">div</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>; </span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.one</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">4</span>; </span><br><span class="language-css"><span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>; </span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">111</span>,<span class="hljs-number">41</span>,<span class="hljs-number">97</span>,.<span class="hljs-number">3</span>); </span><br><span class="language-css"><span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">111</span>,<span class="hljs-number">41</span>,<span class="hljs-number">97</span>,.<span class="hljs-number">5</span>); </span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.two</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>; </span><br><span class="language-css"><span class="hljs-attribute">grid-row</span>: <span class="hljs-number">2</span>; </span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">111</span>,<span class="hljs-number">41</span>,<span class="hljs-number">97</span>,.<span class="hljs-number">3</span>); </span><br><span class="language-css"><span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">111</span>,<span class="hljs-number">41</span>,<span class="hljs-number">97</span>,.<span class="hljs-number">5</span>); </span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.three</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / <span class="hljs-number">4</span>; </span><br><span class="language-css"><span class="hljs-attribute">grid-row</span>: <span class="hljs-number">2</span> / <span class="hljs-number">5</span>; </span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">193</span>,<span class="hljs-number">225</span>,<span class="hljs-number">237</span>,.<span class="hljs-number">3</span>); </span><br><span class="language-css"><span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">193</span>,<span class="hljs-number">225</span>,<span class="hljs-number">237</span>,.<span class="hljs-number">5</span>); </span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.four</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span>; </span><br><span class="language-css"><span class="hljs-attribute">grid-row</span>: <span class="hljs-number">4</span> ; </span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">193</span>,<span class="hljs-number">225</span>,<span class="hljs-number">237</span>,.<span class="hljs-number">3</span>); </span><br><span class="language-css"><span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">193</span>,<span class="hljs-number">225</span>,<span class="hljs-number">237</span>,.<span class="hljs-number">5</span>); </span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.five</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">grid-column</span>: <span class="hljs-number">3</span> ; </span><br><span class="language-css"><span class="hljs-attribute">grid-row</span>: <span class="hljs-number">4</span> / <span class="hljs-number">5</span>; </span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">111</span>,<span class="hljs-number">41</span>,<span class="hljs-number">97</span>,.<span class="hljs-number">3</span>); </span><br><span class="language-css"><span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">111</span>,<span class="hljs-number">41</span>,<span class="hljs-number">97</span>,.<span class="hljs-number">5</span>); </span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/3/1645ff2d0ec568f3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h4 id="通过命名区域来定位元素"><a href="#通过命名区域来定位元素" class="headerlink" title="通过命名区域来定位元素"></a>通过命名区域来定位元素</h4><p>你可以通过命名区域（named areas）来定位网格中的元素。要是用这种方式，你需要给每个元素一个名字，然后通过<code>grid-template-areas</code>属性的值来描述布局方式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item1</span> &#123; <span class="hljs-attribute">grid-area</span>: a; &#125; <br><span class="hljs-selector-class">.item2</span> &#123; <span class="hljs-attribute">grid-area</span>: b; &#125; <br><span class="hljs-selector-class">.item3</span> &#123; <span class="hljs-attribute">grid-area</span>: c; &#125; <br><br><span class="hljs-selector-class">.container</span> &#123; <br><span class="hljs-attribute">display</span>: grid; <br><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr; <br><span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">&quot;a a b b&quot;</span> <br> <span class="hljs-string">&quot;a a c c&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>使用这种方式有几个需要注意的点。如果你想要合并一些单元格作为你的网格项，你需要重复元素的名字。网格区域需要能形成一个完整的矩形 —— 每个单元格都需要被填入一个值。如果你想要空出某些单元格，那就需要使用 <code>.</code> 这个值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123; <br><span class="hljs-attribute">display</span>: grid; <br><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr; <br><span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">&quot;a a b b&quot;</span> <br> <span class="hljs-string">&quot;a a c .&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;three&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;four&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;five&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">body</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>; </span><br><span class="language-css"><span class="hljs-attribute">font</span>: <span class="hljs-number">1em</span> Helvetica Neue, Helvetica, Arial, sans-serif; </span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css">* &#123;</span><br><span class="language-css"><span class="hljs-attribute">box-sizing</span>: border-box;</span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">p</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1em</span> <span class="hljs-number">0</span>; </span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.container</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>; </span><br><span class="language-css"><span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">111</span>,<span class="hljs-number">41</span>,<span class="hljs-number">97</span>); </span><br><span class="language-css"><span class="hljs-attribute">border-radius</span>: .<span class="hljs-number">5em</span>; </span><br><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>; </span><br><span class="language-css"><span class="hljs-attribute">display</span>: grid; </span><br><span class="language-css"><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr; </span><br><span class="language-css"><span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-built_in">minmax</span>(<span class="hljs-number">50px</span>, auto);</span><br><span class="language-css"><span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>; </span><br><span class="language-css"><span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">&quot;a a a&quot;</span> </span><br><span class="language-css"> <span class="hljs-string">&quot;b c c&quot;</span> </span><br><span class="language-css"> <span class="hljs-string">&quot;. . d&quot;</span> </span><br><span class="language-css"> <span class="hljs-string">&quot;e e d&quot;</span>;</span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.container</span> &gt; <span class="hljs-selector-tag">div</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>; </span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">111</span>,<span class="hljs-number">41</span>,<span class="hljs-number">97</span>,.<span class="hljs-number">3</span>); </span><br><span class="language-css"><span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">111</span>,<span class="hljs-number">41</span>,<span class="hljs-number">97</span>,.<span class="hljs-number">5</span>);</span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.one</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">grid-area</span>: a;</span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.two</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">grid-area</span>: b;</span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.three</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">grid-area</span>: c; </span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.four</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">grid-area</span>: d;</span><br><span class="language-css">&#125; </span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.five</span> &#123; </span><br><span class="language-css"><span class="hljs-attribute">grid-area</span>: e;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/3/1645ffbcc1e79e99~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h2 id="排版上下文"><a href="#排版上下文" class="headerlink" title="排版上下文"></a>排版上下文</h2><h3 id="行级排版上下文"><a href="#行级排版上下文" class="headerlink" title="行级排版上下文"></a>行级排版上下文</h3><ul><li>Inline Formatting Context (IFC)</li><li><strong>只包含行级盒子</strong> 的容器会创建一个IFC</li><li>IFC 内的排版规则：<ul><li>盒子在同一行水平摆放</li><li>一行放不下时，换行显示</li><li>text-align 决定一行内盒子的水平对齐</li><li>vertical-align 决定一个盒子的水平对其</li><li>避开浮动（float）元素*</li></ul></li></ul><h3 id="块级排版上下文"><a href="#块级排版上下文" class="headerlink" title="块级排版上下文"></a>块级排版上下文</h3><ul><li>Block Formatting Context (BFC)</li><li>某些元素会创建一个BFC：<ul><li>根元素</li><li>浮动、绝对定位、inline-block</li><li>Flex子项和Gird子项</li><li>overflow 值不是 visible 的块盒</li><li>display:flow-root;</li></ul></li></ul><h3 id="网格布局格式化上下文"><a href="#网格布局格式化上下文" class="headerlink" title="网格布局格式化上下文"></a>网格布局格式化上下文</h3><ul><li>Grid Formatting Context (GFC)</li><li>声明display:grid&#x2F;inline-grid能创建一个网格容器，网格容器会为其内容产生GFC。</li><li>网格布局引入了二维网格布局系统，通过一组相交的水平线和垂直线来定义网格的列和行，网格元素被布局到这些行和列相关的位置上。</li></ul><h3 id="弹性格式化上下文"><a href="#弹性格式化上下文" class="headerlink" title="弹性格式化上下文"></a>弹性格式化上下文</h3><ul><li>Flex Formatting Context (FFC)</li><li>声明display:flex&#x2F;inline-flex能创建一个弹性容器，弹性容器会为其内容产生FFC。</li></ul><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><h3 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">rgb(<span class="hljs-selector-id">#fff</span>, <span class="hljs-selector-id">#fff</span>, <span class="hljs-selector-id">#fff</span>);<br><br><span class="hljs-comment">/* rgba(#fff, #fff, #fff, 1); */</span><br></code></pre></td></tr></table></figure><h3 id="HSL"><a href="#HSL" class="headerlink" title="HSL"></a>HSL</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">hsl(<span class="hljs-number">120</span>, <span class="hljs-number">66%</span>, <span class="hljs-number">50%</span>);<br><br><span class="hljs-comment">/* hsla(120, 66%, 50%, 1); */</span><br></code></pre></td></tr></table></figure><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><h3 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h3><p>font-family 可以把多个字体名称作为一个“回退”系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。也就是说，font-family 属性的值是用于某个元素的字体族名称或&#x2F;及类族名称的一个优先表。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;Times New Roman&quot;</span>,Georgia,Serif;<br></code></pre></td></tr></table></figure><h3 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h3><p>用于设置 <code>字体大小</code>，辅以单位控制，实质上是控制 <code>字符框</code> 的高度。</p><h3 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a>font-style</h3><p>font-style属性指定文本的字体样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-style</span>:normal; <span class="hljs-comment">/*默认值。浏览器显示一个标准的字体样式。*/</span><br>//<span class="hljs-attribute">font-style</span>:italic; <span class="hljs-comment">/*浏览器会显示一个斜体的字体样式。*/</span><br>//<span class="hljs-attribute">font-style</span>:oblique; <span class="hljs-comment">/*浏览器会显示一个倾斜的字体样式。*/</span><br>//<span class="hljs-attribute">font-style</span>: inherit ; <span class="hljs-comment">/*规定应该从父元素继承字体样式。*/</span><br></code></pre></td></tr></table></figure><h3 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a>font-weight</h3><p>font-weight 属性设置文本的粗细。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-weight</span>:normal; <span class="hljs-comment">/*默认值，标准。*/</span><br>//<span class="hljs-attribute">font-weight</span>:bold; <span class="hljs-comment">/*加粗*/</span><br>//<span class="hljs-attribute">font-weight</span>:<span class="hljs-number">900</span>; <span class="hljs-comment">/*自定义数值*/</span><br></code></pre></td></tr></table></figure><h3 id="font-variant"><a href="#font-variant" class="headerlink" title="font-variant"></a>font-variant</h3><p>font-variant 属性设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小</p><p>font-variant 属性主要用于定义小型大写字母文本</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-variant</span>:normal; <span class="hljs-comment">/*默认值。浏览器会显示一个标准的字体。*/</span><br>//<span class="hljs-attribute">font-variant</span>:normal; <span class="hljs-comment">/*浏览器会显示小型大写字母的字体。*/</span><br>//<span class="hljs-attribute">font-variant</span>:normal; <span class="hljs-comment">/*规定应该从父元素继承 font-variant 属性的值。*/</span><br></code></pre></td></tr></table></figure><h3 id="font"><a href="#font" class="headerlink" title="font"></a>font</h3><p>font 简写属性在一个声明中设置所有字体属性。</p><p>可设置的属性是（按顺序）： “font-style font-variant font-weight font-size&#x2F;line-height font-family”</p><p>font-size和font-family的值是必需的。如果缺少了其他值，默认值将被插入，如果有默认值的话。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font</span>:<span class="hljs-number">15px</span> arial,sans-serif;<br>//<span class="hljs-attribute">font</span>:italic bold <span class="hljs-number">12px</span>/<span class="hljs-number">30px</span> Georgia, serif;<br></code></pre></td></tr></table></figure><h2 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h2><h3 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h3><p>设置以百分比计的行高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">line-height</span>:<span class="hljs-number">90%</span><br>//line-height:<span class="hljs-number">200%</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 负值是不允许的</p><h3 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h3><p>指定元素内的空白怎样处理。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">white-space</span>:normal; <span class="hljs-comment">/*默认。空白会被浏览器忽略。*/</span><br>//<span class="hljs-attribute">white-space</span>:pre; <span class="hljs-comment">/*空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。*/</span><br>//<span class="hljs-attribute">white-space</span>:nowrap; <span class="hljs-comment">/*文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。*/</span><br>//<span class="hljs-attribute">white-space</span>:pre-wrap; <span class="hljs-comment">/*保留空白符序列，但是正常地进行换行。*/</span><br>//<span class="hljs-attribute">white-space</span>:pre-line; <span class="hljs-comment">/*合并空白符序列，但是保留换行符。*/</span><br>//<span class="hljs-attribute">white-space</span>:inherit; <span class="hljs-comment">/*规定应该从父元素继承 white-space 属性的值。*/</span><br></code></pre></td></tr></table></figure><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><h3 id="块级"><a href="#块级" class="headerlink" title="块级"></a>块级</h3><p>Block Level Box 不和其他盒子并列摆放，适用所有的盒模型属性。</p><p>块级元素生成块级盒子：body、article、div、main、section、h1-6、p、ul、li 等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>:block;<br></code></pre></td></tr></table></figure><h3 id="行级"><a href="#行级" class="headerlink" title="行级"></a>行级</h3><p>Inline Level Box 和其他行级盒子一起放在一行或拆开成多行，盒模型中的width、height不适用。</p><p>行级元素生成行级盒子，内容分散在多个行盒（line box）中：span、em、strong、cite、code 等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>:inline;<br></code></pre></td></tr></table></figure><h3 id="Flex-Box"><a href="#Flex-Box" class="headerlink" title="Flex Box"></a>Flex Box</h3><p>Flex Box 是一种新的排版上下文，它可以控制子级盒子的：</p><ul><li>摆放的流向（→ ↑ ↓ ←）</li><li>摆放顺序</li><li>盒子宽度和高度</li><li>水平和垂直方向的对齐</li><li>是否允许折行</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>:flex;<br><br><span class="hljs-comment">/* 项目在主轴上的对齐方式 */</span><br><span class="hljs-attribute">justify-content</span>: center;     <span class="hljs-comment">/* 居中排列 */</span>  <br>//<span class="hljs-attribute">justify-content</span>: start;      <span class="hljs-comment">/* 从行首开始排列 */</span>  <br>//<span class="hljs-attribute">justify-content</span>: end;        <span class="hljs-comment">/* 从行尾开始排列 */</span>  <br>//<span class="hljs-attribute">justify-content</span>: flex-start; <span class="hljs-comment">/* 从行首起始位置开始排列 */</span>  <br>//<span class="hljs-attribute">justify-content</span>: flex-end;   <span class="hljs-comment">/* 从行尾位置开始排列 */</span>  <br>//<span class="hljs-attribute">justify-content</span>: left;       <span class="hljs-comment">/* 一个挨一个在对齐容器得左边缘 */</span>  <br>//<span class="hljs-attribute">justify-content</span>: right;      <span class="hljs-comment">/* 元素以容器右边缘为基准，一个挨着一个对齐, */</span>  <br>  <br><span class="hljs-comment">/* 基线对齐 */</span>  <br>//<span class="hljs-attribute">justify-content</span>: baseline;  <br>//<span class="hljs-attribute">justify-content</span>: first baseline;  <br>//<span class="hljs-attribute">justify-content</span>: last baseline;  <br>  <br><span class="hljs-comment">/* 分配弹性元素方式 */</span>  <br>//<span class="hljs-attribute">justify-content</span>: space-between;  <span class="hljs-comment">/* 均匀排列每个元素，首个元素放置于起点，末尾元素放置于终点 */</span>  <br>//<span class="hljs-attribute">justify-content</span>: space-around;  <span class="hljs-comment">/* 均匀排列每个元素，每个元素周围分配相同的空间 */</span>  <br>//<span class="hljs-attribute">justify-content</span>: space-evenly;  <span class="hljs-comment">/* 均匀排列每个元素，每个元素之间的间隔相等 */</span>  <br>//<span class="hljs-attribute">justify-content</span>: stretch;       <span class="hljs-comment">/* 均匀排列每个元素，auto-sized 的元素会被拉伸以适应容器的大小 */</span>  <br>  <br><span class="hljs-comment">/* 溢出对齐方式 */</span>  <br>//<span class="hljs-attribute">justify-content</span>: safe center;  <br>//<span class="hljs-attribute">justify-content</span>: unsafe center;  <br>  <br><span class="hljs-comment">/* 全局值 */</span>  <br>//<span class="hljs-attribute">justify-content</span>: inherit;  <br>//<span class="hljs-attribute">justify-content</span>: initial;  <br>//<span class="hljs-attribute">justify-content</span>: unset;<br><br><br><span class="hljs-comment">/* 项目在交叉轴上的对齐方式 */</span><br>//<span class="hljs-attribute">align-items</span>:...;<br><br><span class="hljs-comment">/* 多行项目的排列方式 */</span><br>//<span class="hljs-attribute">align-content</span>:...;<br></code></pre></td></tr></table></figure><h3 id="display-属性"><a href="#display-属性" class="headerlink" title="display 属性"></a>display 属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>:block; <span class="hljs-comment">/*块级盒子*/</span><br><br>//<span class="hljs-attribute">display</span>:linine; <span class="hljs-comment">/*行级盒子*/</span><br><br>//<span class="hljs-attribute">display</span>:inline-block; <span class="hljs-comment">/*本身是行级，可以放在行盒中；可以设置宽高；作为一个整体不会被拆散成多行*/</span><br><br>//<span class="hljs-attribute">display</span>:flex; <span class="hljs-comment">/*浮动布局*/</span><br><br>//<span class="hljs-attribute">display</span>:none; <span class="hljs-comment">/*排版时完全被忽略*/</span><br></code></pre></td></tr></table></figure><h2 id="调试-CSS"><a href="#调试-CSS" class="headerlink" title="调试 CSS"></a>调试 CSS</h2><ul><li>在chrome浏览器中，可以通过F12或菜单，打开“开发者工具”。</li><li>ctrl + shift + i</li></ul><!-- <p align="center">Create By Asuka24601</p> -->]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL的缓冲位</title>
    <link href="/2022/05/01/OpenGL%E7%9A%84%E7%BC%93%E5%86%B2%E4%BD%8D/"/>
    <url>/2022/05/01/OpenGL%E7%9A%84%E7%BC%93%E5%86%B2%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<p>OpenGL有多个缓冲位（Buffer Bit），这些缓冲位又称缓冲区。</p><span id="more"></span><h2 id="GL-COLOR-BUFFER-BIT，颜色缓冲区"><a href="#GL-COLOR-BUFFER-BIT，颜色缓冲区" class="headerlink" title="GL_COLOR_BUFFER_BIT，颜色缓冲区"></a>GL_COLOR_BUFFER_BIT，颜色缓冲区</h2><p>OpenGL在绘制图元时，先是在一个缓冲区中完成渲染，然后再把渲染结果交换到屏幕上。我们把这两个缓冲区称为前颜色缓冲区（屏幕）和后颜色缓冲区。在默认情况下，OpenGL命令是在后颜色缓冲区进行渲染的。当然，也可以直接在前颜色缓冲区中进行渲染。</p><p>若要在前颜色缓冲区中进行渲染，第一种方法是直接告诉OpenGL希望在前颜色缓冲区中进行绘图，可以调用下面这个函数来实现这个目的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> glDrawBuffer（Glenum mode）;<br></code></pre></td></tr></table></figure><p>如果参数 <strong>mode</strong> 指定为 <strong>GL_FRONT</strong> ，OpenGL就会在前颜色缓冲区中进行渲染；</p><p>如果参数 <strong>mode</strong> 指定为 <strong>GL_BACK</strong> ，那么渲染将在后颜色缓冲区中进行。</p><p>在前颜色缓冲区进行渲染的第二种方法是在OpenGL被初始化时简单地不要求进行双缓冲区渲染。进行单缓冲区渲染时，如果希望把渲染结果实际绘制到屏幕上，需要调用 <strong>glFlush()</strong> 或 <strong>glFinsh()</strong> ，这点非常重要。</p><p>OpenGL实现除了支持单纯的前颜色缓冲区和后颜色缓冲区之外，还支持其他模式，如用于立体渲染的左和右缓冲区以及辅助缓冲区。</p><h2 id="GL-DEPTH-BUFFER-BIT，深度缓冲区"><a href="#GL-DEPTH-BUFFER-BIT，深度缓冲区" class="headerlink" title="GL_DEPTH_BUFFER_BIT，深度缓冲区"></a>GL_DEPTH_BUFFER_BIT，深度缓冲区</h2><p>与颜色缓冲区不同的是，深度缓冲区中所填充的是深度值而不是颜色值。</p><p>为了启用深度缓冲区进行深度测试，只需要调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">glEnable（GL_DEPTH_TEST）;<br></code></pre></td></tr></table></figure><p>另外，即使深度缓冲区未被启用，如果深度缓冲区被创建，OpenGL也会把所有写入到颜色缓冲区的颜色片段对应的深度值写入到深度缓冲区中。但是，如果我们希望在进行深度测试时临时禁止把值写入到深度缓冲区，我们可以使用函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> glDepthMask（GLboolean mask）;<br></code></pre></td></tr></table></figure><p>把 <strong>GL_FALSE</strong> 作为参数，经禁止写入深度值，但并不禁止用已经写入到深度缓冲区的值进行深度测试。</p><p>把 <strong>GL_TRUE</strong> 作为参数，可以重新启用深度缓冲区的写入。同时，这也是默认的设置。</p><h2 id="GL-STENCIL-BUFFER-BIT，模板缓冲区"><a href="#GL-STENCIL-BUFFER-BIT，模板缓冲区" class="headerlink" title="GL_STENCIL_BUFFER_BIT，模板缓冲区"></a>GL_STENCIL_BUFFER_BIT，模板缓冲区</h2><p>与颜色缓冲区和深度缓冲区类似，模板缓冲区可以为屏幕上的每个像素点保存一个无符号整数值。这个值的具体意义视程序的具体应用而定。在渲染的过程中，可以用这个值与一个预先设定的参考值相比较，根据比较的结果来决定是否更新相应的像素点的颜色值。这个比较的过程被称为模板测试。</p><p>模板测试发生在 <strong>透明度测试（alpha test）</strong> 之后， <strong>深度测试（depth test）</strong> 之前。如果模板测试通过，则相应的像素点更新，否则不更新。就像使用纸板和喷漆一样精确的混图一样，当启动 <strong>模板测试（stencil test）</strong> 时，通过模板测试的片段像素点会被替换到颜色缓冲区中，从而显示出来，未通过的则不会保存到颜色缓冲区中，从而达到了过滤的功能。</p><div align="center" >  <img src="https://s2.loli.net/2024/02/16/jqNyVEmPJoaTkvf.png" width=35% hight=auto></div><p>为了启用模板缓冲区进行模板测试，只需要调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">glEnable</span>(GL_STENCIL_TEST);<br></code></pre></td></tr></table></figure><h2 id="GL-ACCUM-BUFFER-BIT，积累缓冲区"><a href="#GL-ACCUM-BUFFER-BIT，积累缓冲区" class="headerlink" title="GL_ACCUM_BUFFER_BIT，积累缓冲区"></a>GL_ACCUM_BUFFER_BIT，积累缓冲区</h2><p>累积缓冲区允许你把渲染到颜色缓冲区的值，拷贝到累积缓冲区。在多次拷贝操作到累积缓冲区时，可以用不同方式的把颜色缓冲区内容和当前累积缓冲区的内容进行重复混合。当在累积缓冲区完成一幅图像之后，可以拷回颜色缓冲区，然后通过SwapBuffers显示到屏幕上。</p><p>可以用 <strong>glClearAccum()</strong> 来设置红、绿和蓝色分量的清空值，按位顺序清空累积缓存或以 <strong>GL_ACCUM_BUFFER_BIT</strong> 调用 <strong>glClear()</strong> 命令。</p><!-- <p align="center">Create By Asuka24601</p> -->]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openGL</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Windows上配置轻量级的OpenGL开发环境</title>
    <link href="/2022/04/28/%E5%9C%A8Windows%E4%B8%8A%E9%85%8D%E7%BD%AE%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84OpenGL%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2022/04/28/%E5%9C%A8Windows%E4%B8%8A%E9%85%8D%E7%BD%AE%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84OpenGL%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>配置开发环境是最好的开始。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>得益于语言文字的多模糊性，对于 <strong>OpenGL</strong> ，我们的第一感觉很容易就认为那是一个图形类库，一个API，一堆代码，但是事实并非如此。<br><strong>OpenGL</strong> 是一类规范，并非实打实的代码，它严苛的规范了每一个函数应该如何执行，以及它们的返回值、输出值。而它的内部实现，则是由各个 OpenGL 库开发者完成的，因此当今市面上有很多 OpenGL 库可供开发者选择。</p><blockquote><p>值得说的一点是，OpenGL 的大多数实现都是由显卡厂商编写的，但各个厂商对 OpenGL 的不同实现带来了的性能差异基本可以无视，所以玩游戏卡不卡主要还是得靠硬件。</p></blockquote><p>现在 OpenGL的最新版本为 OpenGL4.5，但是作为初学者来说，我们并不需要学习那么新的版本，而 <strong>OpengGL3.3</strong> 是一个不错的开始，所以请记住这一点，后文中的所有代码都是符合 OpenGL3.3 规范的。</p><blockquote><p>请确认你的系统支持OpenGL3.3或更高版本，如果不支持，这边建议换个显卡。</p></blockquote><p>关于更多详细信息，可以访问 <a href="https://learnopengl-cn.github.io/">LearnOpenGL</a> 进行学习。</p><h2 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h2><p><strong>GLFW</strong> 是一个专门针对 OpenGL 的 C 语言库，但我们的实际情况主要是用 C++ 调用此C库，二者兼容，所以使用起来没有问题。</p><p>GLFW 提供了一些渲染物体所需的最低限度的接口。它允许用户创建 OpenGL上下文、定义窗口参数以及处理用户输入，对我们来说这就够了。</p><p>首先访问 <a href="https://www.glfw.org/download.html">GLFW官网</a> 下载源码包(Source package)到本地，之后再将其解压。</p><blockquote><p>此处，为了便于之后的代码文件查找和管理，我建议预先建立一个 文件夹 用于存放接下来要存在在本地的文件和代码，例如我建立了 D:&#x2F;DEV&#x2F; 用于存放之后的学习开发所需要的资源。</p></blockquote><p>获得源码之后，我们必须将其编译成适合我们开发环境的工程文件，为了完成这一点，我们需要下载安装 <a href="https://cmake.org/download/">CMake</a> ，它很适合完成这项工作。</p><p>当 CMake 安装完成后，在它的GUI界面中我们能看到这之画面。</p><p><img src="https://s2.loli.net/2024/02/16/XMfyaGBcS3jwLbR.png" alt="CMake"></p><p>Where is the source code 填写你下载的源代码的根目录（例如我的是 D:&#x2F;DEV&#x2F;glfw-3.3.7）。</p><p>Where to build the binaries 填写你的目标目录（例如我选择在源代码目录新建一个build目录作为我的目标目录，则我的目标目录是D:&#x2F;DEV&#x2F;glfw-3.3.&#x2F;build）</p><p><img src="https://s2.loli.net/2024/02/16/lRHCPAi173t2ner.png" alt="CMake2"></p><p>之后，点击 Tools 选项中的 <strong>Configure</strong> 按钮，让CMake 来读取 设置和源代码。</p><p>接下来我们要完成工程文件选择设置，具体情况具体选择，这里我使用的是 Visual Studio 2022，所以我选择的是Visual Studio 17 2022。其他选项默认即可。</p><p><img src="https://s2.loli.net/2024/02/16/hX7swjLW8BCk9a4.png" alt="CMake3"></p><p>然后点击 <strong>Finish</strong> 就可以让CMake读取项目文件的配置了！</p><p>当CMake读取完成后你将可以看到配置的具体内容。</p><p><img src="https://s2.loli.net/2024/02/16/ZTgRHdSc8jB1hJI.png" alt="CMake4"></p><p>最后点击 <strong>Generate(生成)</strong>  完成工作。然后你能在 <strong>build</strong> 文件夹中找到 <strong>GLFW.sln</strong> 工程文件了。</p><p>使用 Visual Studio 2022 打开 GLFW.sln。由于CMake已经为我们完成了所有的配置工作，所以我们这里直接点击 <strong>生成解决方案</strong> 。</p><p><img src="https://s2.loli.net/2024/02/16/xFJzGeDIPVyprUv.png" alt="VisualStudio2022.png"></p><p>待生成完成后，我们就能在 <strong>build&#x2F;src&#x2F;Debug</strong> 文件夹内找到编译出的库文件 <strong>glfw3.lib</strong> 。</p><blockquote><p>在 <strong>bulid</strong> 目录中还有 <strong>build&#x2F;examples</strong> 和 <strong>build&#x2F;tests</strong> 两个目录，这两个目录的 <strong>debug</strong> 文件夹内有一些官方提供的演示样例可供我们学习。</p></blockquote><p>至此，我们完成了对 GLFW 的获取以及编译。</p><blockquote><p>为了方便在后续的工程中链接我们的库文件，我可以在 <strong>DEV</strong> 目录下分别新建一个 <strong>include</strong> 文件夹 和 <strong>lib</strong> 文件夹来放置我们下载的库的头文件和运行库。</p></blockquote><p>这时我们将 <strong>glfw3.lib</strong> 复制粘贴到 <strong>DEV&#x2F;lib</strong> 目录中，之后再复制 <strong>glfw</strong> 根目录下的 <strong>include</strong> 文件夹内的一切粘贴到  <strong>DEV&#x2F;include</strong> 中。</p><h2 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h2><p>单单有 <strong>GLFW</strong> 还是不够的。因为 OpenGL 只是一个规范，具体的实现是由驱动开放商针对特定显卡实现的，由于市面上拥有众多 OpenGL 驱动版本，所以 OpenGL 的大多数函数地址都无法在编译时被确定下来，而需要在运行时查询， 所以开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。由于函数地址的获取方式因平台而异，并且有时会相对复杂，所以我们需要一个工具来帮我们解决这一问题 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取函数地址的过程类似如下</span><br><span class="hljs-comment">// 定义函数原型 </span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*GL_GENBUFFERS)</span> <span class="hljs-params">(GLsizei, GLuint*)</span></span>; <br><span class="hljs-comment">// 找到正确的函数并赋值给函数指针 </span><br>GL_GENBUFFERS glGenBuffers = (GL_GENBUFFERS)<span class="hljs-built_in">wglGetProcAddress</span>(<span class="hljs-string">&quot;glGenBuffers&quot;</span>); <br><span class="hljs-comment">// 现在函数可以被正常调用了 </span><br>GLuint buffer; <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;buffer);<br></code></pre></td></tr></table></figure><p><strong>GLAD</strong> 是一个开源的库，也是目前符合我们需求且最新最流行的库，它能帮助我们简化获取OpenGL函数地址的过程，所以我们需要它。</p><p>GLAD 与其他很多库不同的是，它使用了一个<a href="https://glad.dav1d.de/">在线服务</a> ，在这里我们要告诉 GLAD 我们需要定义的OpenGL的版本，并根据这个版本加载所有相关的OpenGL函数。</p><p>在这里，我们选择 <strong>Language</strong>（语言） 为 <strong>C&#x2F;C++</strong> ，<strong>Specification</strong>（规格） 为 <strong>OpenGL</strong> ， <strong>API</strong> 中选择选择 <strong>gl</strong> 的版本为 <strong>Version3.3</strong> 或以上，这里我们选择的是 <strong>Version3.3</strong> ， <strong>Profile</strong>（模式）选择为 <strong>Core</strong> ，然后在底部的 <strong>Options</strong> 勾选上 <strong>Generate a loader</strong> （生成加载器）。至于其他其他的 <strong>Extensions</strong> （扩展）选项，我们暂时忽略就好。</p><p><img src="https://s2.loli.net/2024/02/16/HXIzwFGWk8yLC41.png" alt="GLAD.png"></p><p>之后点击 <strong>GENERATE</strong>（生成），我们将打开一个界面。</p><p><img src="https://s2.loli.net/2024/02/16/ZwHEbh9f8nY56SV.png" alt="GLAD2.png"></p><p>在这里我们点击 <strong>glad.zip</strong> ，就能将库文件下载到本地。在这个压缩包内有两个头文件目录，<strong>include</strong> 和 <strong>src</strong> ，其中 <strong>src</strong> 中只有一个 <strong>glad.c</strong> 文件。此时我们将压缩包内的 <strong>inlcud</strong> 文件夹内的两个文件夹 <strong>glad</strong> 和 <strong>KHR</strong> 解压到 <strong>DEV&#x2F;include</strong> 中，再将 <strong>glad.c</strong> 解压到 <strong>DEV&#x2F;include</strong>（或者 <strong>DEV&#x2F;include&#x2F;src</strong>） 中。 </p><p>请记住这个 <strong>glad.c</strong> ，此时放入 <strong>DEV&#x2F;include</strong> （或者 <strong>DEV&#x2F;include&#x2F;src</strong>）只是为了方便查找，之后我们将要将它添加到我们的工程中。</p><p>基本情况如下图所示：</p><p><img src="https://s2.loli.net/2024/02/16/5sc9iXPHlwtrJEO.png" alt="dir.png"><br><img src="https://s2.loli.net/2024/02/16/OchHgR4SLseTjCU.png" alt="dir2.png"></p><p>至此，我们完成了对 <strong>GLFW</strong> 和 <strong>GLAD</strong> 两个库基本配置，下一步我们将在工程中链接它们。 </p><h2 id="第一个工程"><a href="#第一个工程" class="headerlink" title="第一个工程"></a>第一个工程</h2><p>你懂的，在 Visual Studio 2022 中新建一个 Empty Project ，为这个项目取个你喜欢的名字（建议取为 <strong>LearnOpenGL</strong> ），选个你喜欢的目录（建议选在 <strong>DEV&#x2F;</strong> ），我们就可以愉快的开始下一步了！</p><blockquote><p>注意，我们是在 64位 模式开展的工程，而新项目默认是 32位 的，所以我们要注意更改模式，即要将 Debug 模式更改为 x64。</p></blockquote><p><img src="https://s2.loli.net/2024/02/16/BKwfqnlGm7WELNJ.png" alt="debug.png">&gt; </p><p>为了正常使用 GLFW ，我们需要将 GLFW库 链接到我们的工程中，即我们要通过 <a href="../ComputerScience/%E9%93%BE%E6%8E%A5%E5%99%A8">链接器</a> 设置指定我们要使用 <strong>glfw3.lib</strong>。</p><p>由于第三方库在 <strong>链接器</strong> 默认识别的目录之外，它在工作时并不知道第三方库在哪，也不知道寻找哪个文件夹，所以我们需要将第三方库所在的文件夹的位置添加进工程设置中。</p><p>为了完成这一点，我们需要打开先前创建的第一个工程，右键项目，打开项目 <strong>属性</strong> 。</p><p><img src="https://s2.loli.net/2024/02/16/mIYazvr3fEc5Jno.png" alt="VisualStudio20222.png"></p><p>在项目属性窗口中的 <strong>配置属性</strong> 中，我们选中 <strong>VC++目录</strong> ，编辑 <strong>包含目录</strong>，将我们前面创建的 <strong>D:&#x2F;DEV&#x2F;include</strong> 添加进去。同理，我们再编辑 <strong>库目录</strong> ，将 <strong>D:&#x2F;DEV&#x2F;lib</strong> 添加进去。</p><p><img src="https://s2.loli.net/2024/02/16/wuXoMveTjYDRQ9m.png" alt="VisualStudio20223.png"></p><blockquote><p>在 <strong>包含目录</strong> 中所能添加的 include文件夹的路径是可以无限多的， <strong>库目录</strong> 同理。只要我们在 <strong>包含目录</strong> 中添加了相应的 inlcude文件夹，我们便能在该项目的代码中使用这些第三方库，链接器也知道去哪里找到我们指定包含的第三方库。</p></blockquote><p>但是到此还是不够的，最后我们还需要告诉链接器我们要链接的那个库的名字，于是我们要在 <strong>链接器</strong> 的选项卡中选中 <strong>输入</strong> 这一选项，编辑 <strong>附加依赖项目</strong> ，添加 <strong>glfw3.lib</strong> 这一字段，这样在编译的时候，链接器就知道把它链接进来了。</p><p>但是除了 <strong>glfw3.lib</strong> 以外， 我们还需要额外链接一个库，在 Windows 上这个库为 <strong>opengl32.lib</strong> 。</p><blockquote><p><strong>opengl32.lib</strong> 默认包含在 <strong>Microsoft SDK</strong> 里，这意味着我们在安装 <strong>Visual Studio</strong> 时就已经默认获得了这个库。如果你没有，请检查自己的 <strong>Visual Studio 安装程序</strong> 中是否勾选到 <strong>Microsoft SDK</strong> 。而且无论是 <strong>32位版本</strong> 还是 <strong>64位版本</strong> ，这个库文件的名字都是 <strong>opengl32.lib</strong> 。</p></blockquote><p><img src="https://s2.loli.net/2024/02/16/PfOI28sDbUMLln7.png" alt="VisualStudio20224.png"></p><p>完成这一步之后，我们便能在直接包含这些头文件，IDE也会自动识别这些头文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 形如以下操作</span><br><span class="hljs-comment">// 注意，glad 要在 GLFW 之前进行包含</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>现在，让我们新建一个 test.cpp 源文件，输入如下代码（注意，glad 要在 GLFW 之前进行包含，因为 glad 已经包含了正确的OpenGL文件）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 注意，glad 要在 GLFW 之前进行包含</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">glfwInit</span>(); <br><span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>); <br><span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<br><span class="hljs-comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); return 0;</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;OK&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>生成调试应该可以直接运行。如果有错误，请仔细检查自己是否打错了文件名或者遗漏了什么步骤，如果还有问题，这边建议去问问神奇的海螺。</p><!-- <p align="center">Create By Asuka24601</p> -->]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C++</tag>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>404</title>
    <link href="/2022/04/09/404/"/>
    <url>/2022/04/09/404/</url>
    
    <content type="html"><![CDATA[<blockquote><p>ps:我完全不知道这里该写些什么…</p></blockquote><span id="more"></span><p>这是一个空的页面</p><p>这里还什么都没有</p><p>这里只有虚无</p><p>一切的开始都是虚无</p><p>一切从虚无中脱生</p><p>一切从虚无中成形</p><p>我们幻想一切在森林中隐没的火苗</p><p>我们见过一切在日出前摇曳的影子</p><p>但我们并未拥有去拥有虚无的权利</p><p>但我们拥有着这个世界唯一的权利</p><p>去开始一切的权利</p><p>我们开始看见，开始热爱，开始生活，开始追逐…</p><p>于是，开始坠入更大的虚无…</p><p>一切被放大的幸福</p><p>一切被聚拢的孤独</p><p>这是人类的特性</p><p>也是我们所需要的努力</p><p>因此你无需害怕，也无需担心</p><p>因为我们选择了开始</p><p>从一个 Empty Project 开始</p><p>你好，404</p><!-- <p align="center">Create By Asuka24601</p> -->]]></content>
    
    
    <categories>
      
      <category>诗歌</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随想</tag>
      
      <tag>现代诗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用cout标准输出控制小数点后位数</title>
    <link href="/2021/12/30/%E4%BD%BF%E7%94%A8cout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E4%BD%8D%E6%95%B0/"/>
    <url>/2021/12/30/%E4%BD%BF%E7%94%A8cout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>踩过坑的就知道为什么…</p><span id="more"></span><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p><strong>float</strong> 和 <strong>double</strong> 的范围是由指数的位数来决定的。  </p><p><strong>float</strong> 的指数位有8位，而 <strong>double</strong> 的指数位有11位，分布如下:  </p><blockquote><p>float : 1bit（符号位） 8bits（指数位） 23bits（尾数位）<br>double : 1bit（符号位） 11bits（指数位） 52bits（尾数位）  </p></blockquote><p>于是，float的指数范围为-127 ~ +128，而double的指数范围为-1023 ~ +1024，并且指数位是按补码的形式来划分的。  </p><p>其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。  </p><p><strong>float</strong> 的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；</p><p><strong>double</strong> 的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。</p><h2 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h2><p>  <strong>float</strong> 和 <strong>double</strong> 的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。  </p><p>  <strong>float</strong> : 2^23 &#x3D; 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字；  </p><p>  <strong>double</strong> : 2^52 &#x3D; 4503599627370496，一共16位，同理，double的精度为15~16位。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>这属于冷门知识了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span> <span class="hljs-comment">//此头文件是输入/输出库的一部分。</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> value = <span class="hljs-number">12.3456789</span>;<br><br>    cout &lt;&lt; value &lt;&lt; endl; <span class="hljs-comment">// 默认以6精度，所以输出为 12.3457</span><br><br>    cout &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>) &lt;&lt; value &lt;&lt; endl; <span class="hljs-comment">// 改成4精度，所以输出为12.35</span><br><br>    cout &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">8</span>) &lt;&lt; value &lt;&lt; endl; <span class="hljs-comment">// 改成8精度，所以输出为12.345679</span><br><br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>) &lt;&lt; value &lt;&lt; endl; <span class="hljs-comment">// 加了fixed意味着是固定点方式显示，所以这里的精度指的是小数位，输出为12.3457</span><br><br>    cout &lt;&lt; value &lt;&lt; endl; <span class="hljs-comment">// fixed和setprecision的作用还在，依然显示12.3457</span><br><br>    cout.<span class="hljs-built_in">unsetf</span>( ios::fixed ); <span class="hljs-comment">// 去掉了fixed，所以精度恢复成整个数值的有效位数，显示为12.35</span><br><br>    cout &lt;&lt; value &lt;&lt; endl;<br><br>    cout.<span class="hljs-built_in">precision</span>( <span class="hljs-number">6</span> ); <span class="hljs-comment">// 恢复成原来的样子，输出为12.3457</span><br><br>    cout &lt;&lt; value &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><!-- <p align="center">Create By Asuka24601</p> -->]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode的json配置文件中各种变量的含义</title>
    <link href="/2021/11/01/VSCode%E7%9A%84json%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%90%84%E7%A7%8D%E5%8F%98%E9%87%8F%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <url>/2021/11/01/VSCode%E7%9A%84json%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%90%84%E7%A7%8D%E5%8F%98%E9%87%8F%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>可能什么时候就用得上吧…</p><span id="more"></span><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>&emsp;&emsp;在vscode中定义了一些变量,在配置任务脚本时,可能会用到。本文以 launch.json脚本为例，介绍各个变量的含义。<br>&emsp;&emsp;假设当前workspace的路径为: “C:\Users\admin\Desktop\test”, workspace文件夹下的结构如下：  </p><blockquote><p>C:\Users\admin\Desktop\test  </p><hr><p>├ .vscode<br>│&emsp; ├ tasks.json<br>│&emsp; └ launch.json<br>├ main.cpp  </p><hr></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">$<span class="hljs-punctuation">&#123;</span>workspaceFolder<span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">//表示当前workspace文件夹路径，也即 C:\Users\admin\Desktop\test</span><br><br>$<span class="hljs-punctuation">&#123;</span>workspaceRootFolderName<span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">//表示workspace的文件夹名，也即 test</span><br><br>$<span class="hljs-punctuation">&#123;</span>file<span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">//文件自身的绝对路径，也即 C:\Users\admin\Desktop\test\.vscode\launch.json</span><br><br>$<span class="hljs-punctuation">&#123;</span>relativeFile<span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">//文件在workspace中的路径，也即 .vscode\launch.json</span><br><br>$<span class="hljs-punctuation">&#123;</span>fileBasenameNoExtension<span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">//当前文件的文件名，不带后缀，也即 launch</span><br><br>$<span class="hljs-punctuation">&#123;</span>fileBasename<span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">//当前文件的文件名，也即 launch.json</span><br><br>$<span class="hljs-punctuation">&#123;</span>fileDirname<span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">//文件所在的文件夹路径，也即 C:\Users\admin\Desktop\test\.vscode</span><br><br>$<span class="hljs-punctuation">&#123;</span>fileExtname<span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">//当前文件的后缀，也即 .json</span><br><br>$<span class="hljs-punctuation">&#123;</span>lineNumber<span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">//当前文件光标所在的行号</span><br><br>$<span class="hljs-punctuation">&#123;</span>env<span class="hljs-punctuation">:</span>PATH<span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">//系统中的环境变量</span><br></code></pre></td></tr></table></figure><!-- <p align="center">Create By Asuka24601</p> -->]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>VSCode</tag>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
