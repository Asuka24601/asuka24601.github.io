[{"title":"404","url":"/2022/04/09/404/","content":"\n\n\n\n\n\n这是一个空的页面\n\n这里还什么都没有\n\n这里只有虚无\n\n一切的开始都是虚无\n\n一切从虚无中脱生\n\n一切从虚无中成形\n\n我们幻想一切在森林中隐没的火苗\n\n我们见过一切在日出前摇曳的影子\n\n但我们并未拥有去拥有虚无的权利\n\n但我们拥有着这个世界唯一的权利\n\n去开始一切的权利\n\n我们开始看见，开始热爱，开始生活，开始追逐...\n\n于是，开始坠入更大的虚无...\n\n一切被放大的幸福\n\n一切被聚拢的孤独\n\n这是人类的特性\n\n也是我们所需要的努力\n\n因此你无需害怕，也无需担心\n\n因为我们选择了开始\n\n从一个 Empty Project 开始\n\n你好，404\n\n\n\nCreate By Asuka24601\n\n\n\n\n你可以在这里:[https://asuka24601.github.io/2022/04/09/404/]找到这篇文章，如有问题，请通过邮件联系。","categories":["诗歌"],"tags":["随想","现代诗"]},{"title":"LaTex数学符号","url":"/2023/11/05/LaTexSymbols/","content":"\n简单的收集了一些Latex数学符号的写法，方便需要时查找。\n\n\n操作符\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\pm\n\n\\mp\n\n\\times\n\n\n\n\\div\n\n\\cdot\n\n\\ast\n\n\n\n\\star\n\n\\dagger\n\n\\ddagger\n\n\n\n\\amalg\n\n\\cap\n\n\\cup\n\n\n\n\\uplus\n\n\\sqcap\n\n\\sqcup\n\n\n\n\\vee\n\n\\wedge\n\n\\oplus\n\n\n\n\\ominus\n\n\\otimes\n\n\\circ\n\n\n\n\\bullet\n\n\\diamond\n\n\\lhd\n\n\n\n\\rhd\n\n\\unlhd\n\n\\unrhd\n\n\n\n\\oslash\n\n\\odot\n\n\\bigcirc\n\n\n\n\\triangleleft\n\n\\Diamond\n\n\\bigtriangleup\n\n\n\n\\bigtriangledown\n\n\\Box\n\n\\triangleright\n\n\n\n\\setminu\n\n\\wr\n\n\\sqrt{x}\n\n\n\nx^{\\circ}\n\n\\triangledown\n\n\\sqrt[n]{x}\n\n\n\na^x\n\na^{xyz}\n\n\n\n\n关系符\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\le\n\n\\ge\n\n\\ne\n\n\n\n\\sim\n\n\\ll\n\n\\gg\n\n\n\n\\doteq\n\n\\simeq\n\n\\subset\n\n\n\n\\supset\n\n\\approx\n\n\\asymp\n\n\n\n\\subseteq\n\n\\supseteq\n\n\\cong\n\n\n\n\\smile\n\n\\sqsubset\n\n\\sqsupset\n\n\n\n\\equiv\n\n\\frown\n\n\\sqsubseteq\n\n\n\n\\sqsupseteq\n\n\\propto\n\n\\bowtie\n\n\n\n\\in\n\n\\ni\n\n\\prec\n\n\n\n\\succ\n\n\\vdash\n\n\\dashv\n\n\n\n\\preceq\n\n\\succeq\n\n\\models\n\n\n\n\\perp\n\n\\parallel\n\n\n\n\n\n\\mid\n\n\\bumpeq\n\n\n\n\n只要将not放在符号前面或者在 \\ 和单词之间插入一个 n ，就可以形成许多这些关系的否定形式，这里有一些例子，加上一些其他的否定，它也适用于许多其他的。\n\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\nmid\n\n\\nleq\n\n\\ngeq\n\n\n\n\\nsim\n\n\\ncong\n\n\\nparallel\n\n\n\n\\not&lt;\n\n\\not&gt;\n\n\\not= or \\neq\n\n\n\n\\not\\le\n\n\\not\\ge\n\n\\not\\sim\n\n\n\n\\not\\approx\n\n\\not\\cong\n\n\\not\\equiv\n\n\n\n\\not\\paralle\n\n\\nless\n\n\\ngtr\n\n\n\n\\lneq\n\n\\gneq\n\n\\lnsim\n\n\n\n\\lneqq\n\n\\gneqq\n\n\n\n\n希腊字母小写\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\alpha\n\n\\beta\n\n\\gamma\n\n\\delta\n\n\n\n\\epsilon\n\n\\varepsilon\n\n\\zeta\n\n\\eta\n\n\n\n\\theta\n\n\\vartheta\n\n\\iota\n\n\\kappa\n\n\n\n\\lambda\n\n\\mu\n\n\\nu\n\n\\xi\n\n\n\n\\pi\n\n\\varpi\n\n\\rho\n\n\\varrho\n\n\n\n\\sigma\n\n\\varsigma\n\n\\tau\n\n\\upsilon\n\n\n\n\\phi\n\n\\varphi\n\n\\chi\n\n\\psi\n\n\n\n\\omega\n\n\n\n\n\n\n\n\n大写\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\Gamma\n\n\\Delta\n\n\\Theta\n\n\\Lambda\n\n\n\n\\Xi\n\n\\Pi\n\n\\Sigma\n\n\\Upsilon\n\n\n\n\\Phi\n\n\\Psi\n\n\\Omega\n\n\\nabla\n\n\n加粗在公式中的字母加粗：\n\n\n\nSymbol\nCommand\n\n\n\n\n\\boldsymbol{m}\n\n\n空心字母\n\n\nSymbol\nCommand\n\n\n\n\n\\mathbb{M}\n\n\n\n\\mathbb{R}\n\n\n箭头\n\n\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\gets\n\n\\to\n\n\n\n\\leftarrow\n\n\\Leftarrow\n\n\n\n\\rightarrow\n\n\\Rightarrow\n\n\n\n\\leftrightarrow\n\n\\Leftrightarrow\n\n\n\n\\mapsto\n\n\\hookleftarrow\n\n\n\n\\leftharpoonup\n\n\\leftharpoondown\n\n\n\n\\rightleftharpoons\n\n\\longleftarrow\n\n\n\n\\Longleftarrow\n\n\\longrightarrow\n\n\n\n\\Longrightarrow\n\n\\longleftrightarrow\n\n\n\n\\Longleftrightarrow\n\n\\longmapsto\n\n\n\n\\hookrightarrow\n\n\\rightharpoonup\n\n\n\n\\rightharpoondown\n\n\\leadsto\n\n\n\n\\uparrow\n\n\\Uparrow\n\n\n\n\\downarrow\n\n\\Downarrow\n\n\n\n\\updownarrow\n\n\\Updownarrow\n\n\n\n\\nearrow\n\n\\searrow\n\n\n\n\\swarrow\n\n\\nwarrow\n\n\n(对于不喜欢键入长串字母的人，\\iff和\\implies可以分别替代\\Longleftrightarrow和\\ longrighttarrow)\n点\n\n\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\cdot\n\n\\vdots\n\n\n\n\\dots\n\n\\ddots\n\n\n上标\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\hat{x\n\n\\check{x}\n\n\\dot{x}\n\n\n\n\\breve{x}\n\n\\acute{x}\n\n\\ddot{x}\n\n\n\n\\grave{x}\n\n\\tilde{x}\n\n\\mathring{x}\n\n\n\n\\bar{x}\n\n\\vec{x}\n\n\n\n\n当对i和j应用上标时，可以使用\\imath和\\jmath来防止点干扰上标:\n\n\n\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n​\n\\vec{\\jmath}\n\n\\tilde{\\imath}\n\n\n\\tilde和\\hat有很宽的版本，可以让你强调一个表达:\n\n\n\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n​\n\\widehat{7+x}\n\n\\widetilde{abc}\n\n\n其他\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\infty\n\n\\triangle\n\n\\angle\n\n\n\n\\aleph\n\n\\hbar\n\n\\imath\n\n\n\n\\jmath\n\n\\ell\n\n\\wp\n\n\n\n\\Re\n\n\\Im\n\n\\mho\n\n\n\n\\prime\n\n\\emptyset\n\n\\nabla\n\n\n\n\\surd\n\n\\partial\n\n\\top\n\n\n\n\\bot\n\n\\vdash\n\n\\dashv\n\n\n\n\\forall\n\n\\exists\n\n\\neg\n\n\n\n\\flat\n\n\\natural\n\n\\sharp\n\n\n\n\\backslash\n\n\\Box\n\n\\Diamond\n\n\n\n\\clubsuit\n\n\\diamondsuit\n\n\\heartsuit\n\n\n\n\\spadesuit\n\n\\Join\n\n\\blacksquare\n\n\n\n\\checkmark\n\n\\mathbb{R}\n©\n\\copyright\n\n\n£\n\\pounds\n\n\\square\n\n\\cup\n\n\n\n\\bigstar\n\n\\in\n\n\n\n\n命令符有些符号用于命令中，因此需要以特殊的方式处理它们。\n\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\backslash\nMisplaced &&amp;\n\\&amp;\n\n\\%\nYou can't use 'macro parameter character #' in math mode#\n\\#\n\n\nMissing superscript or subscript argument_\n\\_\n${$\n\\{\nExtra close brace or missing open brace}\n\\}\n\n\n\n\n您可能会注意到，如果使用其中任何一个来排版垂直较大的表达式，比如得到的表达式的括号的大小不对\n跨行或跨列的符号\n\n\nsymbol\ncommand\n\n\n\n\nf(x) = \n\n\n\n\\left\\lceil\\frac{x}{y}\\right\\rceil\n\n\n\n\\left\\lfloor\\frac{x}{y}\\right\\rfloor\n\n\n\n\\underbrace{a_0+a_1+a_2+\\cdots+a_n}_{x}\n\n\n\n​\\overbrace{a_0+a_1+a_2+\\cdots+a_n}^{x}\n\n\n\n\\arg \\underset{1\\leq k \\leq n} {max} \\frac{\\lambda_k}{\\lambda_{k+1}}\n\n\n\\left和\\right也可以用来调整下列符号的大小:\n\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\uparrow\n\n\\downarrow\n\n\\updownarrow\n\n\n\n\\Uparrow\n\n\\Downarrow\n\n\\Updownarrow\n\n\n\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\sum\n\n\\int\n\n\\oint\n\n\n\n\\prod\n\n\\coprod\n\n\\bigcap\n\n\n\n\\bigcup\n\n\\bigsqcup\n\n\\bigvee\n\n\n\n\\bigwedge\n\n\\bigodot\n\n\\bigotimes\n\n\n\n\\bigoplus\n\n\\biguplus\n\n\n\n\nCreate By Asuka24601\n\n\n\n\n你可以在这里:[https://asuka24601.github.io/2023/11/05/LaTexSymbols/]找到这篇文章，如有问题，请通过邮件联系。","categories":["数学"],"tags":["数学","latex"]},{"title":"OpenGL的缓冲位","url":"/2022/05/01/OpenGL%E7%9A%84%E7%BC%93%E5%86%B2%E4%BD%8D/","content":"OpenGL有多个缓冲位（Buffer Bit），这些缓冲位又称缓冲区。\n\n\nGL_COLOR_BUFFER_BIT，颜色缓冲区OpenGL在绘制图元时，先是在一个缓冲区中完成渲染，然后再把渲染结果交换到屏幕上。我们把这两个缓冲区称为前颜色缓冲区（屏幕）和后颜色缓冲区。在默认情况下，OpenGL命令是在后颜色缓冲区进行渲染的。当然，也可以直接在前颜色缓冲区中进行渲染。\n若要在前颜色缓冲区中进行渲染，第一种方法是直接告诉OpenGL希望在前颜色缓冲区中进行绘图，可以调用下面这个函数来实现这个目的：\nvoid glDrawBuffer（Glenum mode）;\n\n如果参数 mode 指定为 GL_FRONT ，OpenGL就会在前颜色缓冲区中进行渲染；\n如果参数 mode 指定为 GL_BACK ，那么渲染将在后颜色缓冲区中进行。\n在前颜色缓冲区进行渲染的第二种方法是在OpenGL被初始化时简单地不要求进行双缓冲区渲染。进行单缓冲区渲染时，如果希望把渲染结果实际绘制到屏幕上，需要调用 glFlush() 或 glFinsh() ，这点非常重要。\nOpenGL实现除了支持单纯的前颜色缓冲区和后颜色缓冲区之外，还支持其他模式，如用于立体渲染的左和右缓冲区以及辅助缓冲区。\nGL_DEPTH_BUFFER_BIT，深度缓冲区与颜色缓冲区不同的是，深度缓冲区中所填充的是深度值而不是颜色值。\n为了启用深度缓冲区进行深度测试，只需要调用：\nglEnable（GL_DEPTH_TEST）;\n\n\n另外，即使深度缓冲区未被启用，如果深度缓冲区被创建，OpenGL也会把所有写入到颜色缓冲区的颜色片段对应的深度值写入到深度缓冲区中。但是，如果我们希望在进行深度测试时临时禁止把值写入到深度缓冲区，我们可以使用函数：\nvoid glDepthMask（GLboolean mask）;\n\n把 GL_FALSE 作为参数，经禁止写入深度值，但并不禁止用已经写入到深度缓冲区的值进行深度测试。\n把 GL_TRUE 作为参数，可以重新启用深度缓冲区的写入。同时，这也是默认的设置。\nGL_STENCIL_BUFFER_BIT，模板缓冲区与颜色缓冲区和深度缓冲区类似，模板缓冲区可以为屏幕上的每个像素点保存一个无符号整数值。这个值的具体意义视程序的具体应用而定。在渲染的过程中，可以用这个值与一个预先设定的参考值相比较，根据比较的结果来决定是否更新相应的像素点的颜色值。这个比较的过程被称为模板测试。\n模板测试发生在 透明度测试（alpha test） 之后， 深度测试（depth test） 之前。如果模板测试通过，则相应的像素点更新，否则不更新。就像使用纸板和喷漆一样精确的混图一样，当启动 模板测试（stencil test） 时，通过模板测试的片段像素点会被替换到颜色缓冲区中，从而显示出来，未通过的则不会保存到颜色缓冲区中，从而达到了过滤的功能。\n\n\n\n为了启用模板缓冲区进行模板测试，只需要调用：\nglEnable(GL_STENCIL_TEST);\n\nGL_ACCUM_BUFFER_BIT，积累缓冲区累积缓冲区允许你把渲染到颜色缓冲区的值，拷贝到累积缓冲区。在多次拷贝操作到累积缓冲区时，可以用不同方式的把颜色缓冲区内容和当前累积缓冲区的内容进行重复混合。当在累积缓冲区完成一幅图像之后，可以拷回颜色缓冲区，然后通过SwapBuffers显示到屏幕上。\n可以用 glClearAccum() 来设置红、绿和蓝色分量的清空值，按位顺序清空累积缓存或以 GL_ACCUM_BUFFER_BIT 调用 glClear() 命令。\nCreate By Asuka24601\n\n\n\n\n你可以在这里:[https://asuka24601.github.io/2022/05/01/OpenGL的缓冲位/]找到这篇文章，如有问题，请通过邮件联系。","categories":["计算机图形学"],"tags":["openGL","技术"]},{"title":"VSCode的json配置文件中各种变量的含义","url":"/2021/11/01/VSCode%E7%9A%84json%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%90%84%E7%A7%8D%E5%8F%98%E9%87%8F%E7%9A%84%E5%90%AB%E4%B9%89/","content":"前提&emsp;&emsp;在vscode中定义了一些变量,在配置任务脚本时,可能会用到。本文以 launch.json脚本为例，介绍各个变量的含义。&emsp;&emsp;假设当前workspace的路径为: “C:\\Users\\admin\\Desktop\\test”, workspace文件夹下的结构如下：  \n\nC:\\Users\\admin\\Desktop\\test  \n\n├ .vscode│&emsp; ├ tasks.json│&emsp; └ launch.json├ main.cpp  \n\n\n变量$&#123;workspaceFolder&#125; //表示当前workspace文件夹路径，也即 C:\\Users\\admin\\Desktop\\test$&#123;workspaceRootFolderName&#125; //表示workspace的文件夹名，也即 test$&#123;file&#125; //文件自身的绝对路径，也即 C:\\Users\\admin\\Desktop\\test\\.vscode\\launch.json$&#123;relativeFile&#125; //文件在workspace中的路径，也即 .vscode\\launch.json$&#123;fileBasenameNoExtension&#125; //当前文件的文件名，不带后缀，也即 launch$&#123;fileBasename&#125; //当前文件的文件名，也即 launch.json$&#123;fileDirname&#125; //文件所在的文件夹路径，也即 C:\\Users\\admin\\Desktop\\test\\.vscode$&#123;fileExtname&#125; //当前文件的后缀，也即 .json$&#123;lineNumber&#125; //当前文件光标所在的行号$&#123;env:PATH&#125; //系统中的环境变量\n\nCreate By Asuka24601\n\n\n\n你可以在这里:[https://asuka24601.github.io/2021/11/01/VSCode的json配置文件中各种变量的含义/]找到这篇文章，如有问题，请通过邮件联系。","categories":["技术"],"tags":["技术","VSCode","配置"]},{"title":"在Windows上配置轻量级的OpenGL开发环境","url":"/2022/04/28/%E5%9C%A8Windows%E4%B8%8A%E9%85%8D%E7%BD%AE%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84OpenGL%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","content":"配置开发环境是最好的开始。\n\n\n前言得益于语言文字的多模糊性，对于 OpenGL ，我们的第一感觉很容易就认为那是一个图形类库，一个API，一堆代码，但是事实并非如此。OpenGL 是一类规范，并非实打实的代码，它严苛的规范了每一个函数应该如何执行，以及它们的返回值、输出值。而它的内部实现，则是由各个 OpenGL 库开发者完成的，因此当今市面上有很多 OpenGL 库可供开发者选择。\n\n值得说的一点是，OpenGL 的大多数实现都是由显卡厂商编写的，但各个厂商对 OpenGL 的不同实现带来了的性能差异基本可以无视，所以玩游戏卡不卡主要还是得靠硬件。\n\n现在 OpenGL的最新版本为 OpenGL4.5，但是作为初学者来说，我们并不需要学习那么新的版本，而 OpengGL3.3 是一个不错的开始，所以请记住这一点，后文中的所有代码都是符合 OpenGL3.3 规范的。\n\n请确认你的系统支持OpenGL3.3或更高版本，如果不支持，这边建议换个显卡。\n\n关于更多详细信息，可以访问 LearnOpenGL 进行学习。\nGLFWGLFW 是一个专门针对 OpenGL 的 C 语言库，但我们的实际情况主要是用 C++ 调用此C库，二者兼容，所以使用起来没有问题。\nGLFW 提供了一些渲染物体所需的最低限度的接口。它允许用户创建 OpenGL上下文、定义窗口参数以及处理用户输入，对我们来说这就够了。\n首先访问 GLFW官网 下载源码包(Source package)到本地，之后再将其解压。\n\n此处，为了便于之后的代码文件查找和管理，我建议预先建立一个 文件夹 用于存放接下来要存在在本地的文件和代码，例如我建立了 D:&#x2F;DEV&#x2F; 用于存放之后的学习开发所需要的资源。\n\n获得源码之后，我们必须将其编译成适合我们开发环境的工程文件，为了完成这一点，我们需要下载安装 CMake ，它很适合完成这项工作。\n当 CMake 安装完成后，在它的GUI界面中我们能看到这之画面。\n\nWhere is the source code 填写你下载的源代码的根目录（例如我的是 D:&#x2F;DEV&#x2F;glfw-3.3.7）。\nWhere to build the binaries 填写你的目标目录（例如我选择在源代码目录新建一个build目录作为我的目标目录，则我的目标目录是D:&#x2F;DEV&#x2F;glfw-3.3.&#x2F;build）\n\n之后，点击 Tools 选项中的 Configure 按钮，让CMake 来读取 设置和源代码。\n接下来我们要完成工程文件选择设置，具体情况具体选择，这里我使用的是 Visual Studio 2022，所以我选择的是Visual Studio 17 2022。其他选项默认即可。\n\n然后点击 Finish 就可以让CMake读取项目文件的配置了！\n当CMake读取完成后你将可以看到配置的具体内容。\n\n最后点击 Generate(生成)  完成工作。然后你能在 build 文件夹中找到 GLFW.sln 工程文件了。\n使用 Visual Studio 2022 打开 GLFW.sln。由于CMake已经为我们完成了所有的配置工作，所以我们这里直接点击 生成解决方案 。\n\n待生成完成后，我们就能在 build&#x2F;src&#x2F;Debug 文件夹内找到编译出的库文件 glfw3.lib 。\n\n在 bulid 目录中还有 build&#x2F;examples 和 build&#x2F;tests 两个目录，这两个目录的 debug 文件夹内有一些官方提供的演示样例可供我们学习。\n\n至此，我们完成了对 GLFW 的获取以及编译。\n\n为了方便在后续的工程中链接我们的库文件，我可以在 DEV 目录下分别新建一个 include 文件夹 和 lib 文件夹来放置我们下载的库的头文件和运行库。\n\n这时我们将 glfw3.lib 复制粘贴到 DEV&#x2F;lib 目录中，之后再复制 glfw 根目录下的 include 文件夹内的一切粘贴到  DEV&#x2F;include 中。\nGLAD单单有 GLFW 还是不够的。因为 OpenGL 只是一个规范，具体的实现是由驱动开放商针对特定显卡实现的，由于市面上拥有众多 OpenGL 驱动版本，所以 OpenGL 的大多数函数地址都无法在编译时被确定下来，而需要在运行时查询， 所以开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。由于函数地址的获取方式因平台而异，并且有时会相对复杂，所以我们需要一个工具来帮我们解决这一问题 。\n// 获取函数地址的过程类似如下// 定义函数原型 typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*); // 找到正确的函数并赋值给函数指针 GL_GENBUFFERS glGenBuffers = (GL_GENBUFFERS)wglGetProcAddress(&quot;glGenBuffers&quot;); // 现在函数可以被正常调用了 GLuint buffer; glGenBuffers(1, &amp;buffer);\n\nGLAD 是一个开源的库，也是目前符合我们需求且最新最流行的库，它能帮助我们简化获取OpenGL函数地址的过程，所以我们需要它。\nGLAD 与其他很多库不同的是，它使用了一个在线服务 ，在这里我们要告诉 GLAD 我们需要定义的OpenGL的版本，并根据这个版本加载所有相关的OpenGL函数。\n在这里，我们选择 Language（语言） 为 C&#x2F;C++ ，Specification（规格） 为 OpenGL ， API 中选择选择 gl 的版本为 Version3.3 或以上，这里我们选择的是 Version3.3 ， Profile（模式）选择为 Core ，然后在底部的 Options 勾选上 Generate a loader （生成加载器）。至于其他其他的 Extensions （扩展）选项，我们暂时忽略就好。\n\n之后点击 GENERATE（生成），我们将打开一个界面。\n\n在这里我们点击 glad.zip ，就能将库文件下载到本地。在这个压缩包内有两个头文件目录，include 和 src ，其中 src 中只有一个 glad.c 文件。此时我们将压缩包内的 inlcud 文件夹内的两个文件夹 glad 和 KHR 解压到 DEV&#x2F;include 中，再将 glad.c 解压到 DEV&#x2F;include（或者 DEV&#x2F;include&#x2F;src） 中。 \n请记住这个 glad.c ，此时放入 DEV&#x2F;include （或者 DEV&#x2F;include&#x2F;src）只是为了方便查找，之后我们将要将它添加到我们的工程中。\n基本情况如下图所示：\n\n至此，我们完成了对 GLFW 和 GLAD 两个库基本配置，下一步我们将在工程中链接它们。 \n第一个工程你懂的，在 Visual Studio 2022 中新建一个 Empty Project ，为这个项目取个你喜欢的名字（建议取为 LearnOpenGL ），选个你喜欢的目录（建议选在 DEV&#x2F; ），我们就可以愉快的开始下一步了！\n\n注意，我们是在 64位 模式开展的工程，而新项目默认是 32位 的，所以我们要注意更改模式，即要将 Debug 模式更改为 x64。\n\n&gt; \n为了正常使用 GLFW ，我们需要将 GLFW库 链接到我们的工程中，即我们要通过 链接器 设置指定我们要使用 glfw3.lib。\n由于第三方库在 链接器 默认识别的目录之外，它在工作时并不知道第三方库在哪，也不知道寻找哪个文件夹，所以我们需要将第三方库所在的文件夹的位置添加进工程设置中。\n为了完成这一点，我们需要打开先前创建的第一个工程，右键项目，打开项目 属性 。\n\n在项目属性窗口中的 配置属性 中，我们选中 VC++目录 ，编辑 包含目录，将我们前面创建的 D:&#x2F;DEV&#x2F;include 添加进去。同理，我们再编辑 库目录 ，将 D:&#x2F;DEV&#x2F;lib 添加进去。\n\n\n在 包含目录 中所能添加的 include文件夹的路径是可以无限多的， 库目录 同理。只要我们在 包含目录 中添加了相应的 inlcude文件夹，我们便能在该项目的代码中使用这些第三方库，链接器也知道去哪里找到我们指定包含的第三方库。\n\n但是到此还是不够的，最后我们还需要告诉链接器我们要链接的那个库的名字，于是我们要在 链接器 的选项卡中选中 输入 这一选项，编辑 附加依赖项目 ，添加 glfw3.lib 这一字段，这样在编译的时候，链接器就知道把它链接进来了。\n但是除了 glfw3.lib 以外， 我们还需要额外链接一个库，在 Windows 上这个库为 opengl32.lib 。\n\nopengl32.lib 默认包含在 Microsoft SDK 里，这意味着我们在安装 Visual Studio 时就已经默认获得了这个库。如果你没有，请检查自己的 Visual Studio 安装程序 中是否勾选到 Microsoft SDK 。而且无论是 32位版本 还是 64位版本 ，这个库文件的名字都是 opengl32.lib 。\n\n\n完成这一步之后，我们便能在直接包含这些头文件，IDE也会自动识别这些头文件。\n// 形如以下操作// 注意，glad 要在 GLFW 之前进行包含#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;//...\n\n现在，让我们新建一个 test.cpp 源文件，输入如下代码（注意，glad 要在 GLFW 之前进行包含，因为 glad 已经包含了正确的OpenGL文件）：\n// 注意，glad 要在 GLFW 之前进行包含#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;int main()&#123;\tglfwInit(); \tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); \tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\tglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\t//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); return 0;\tstd::cout &lt;&lt; &quot;OK&quot;;\treturn 0;&#125;\n\n生成调试应该可以直接运行。如果有错误，请仔细检查自己是否打错了文件名或者遗漏了什么步骤，如果还有问题，这边建议去问问神奇的海螺。\nCreate By Asuka24601\n\n\n\n你可以在这里:[https://asuka24601.github.io/2022/04/28/在Windows上配置轻量级的OpenGL开发环境/]找到这篇文章，如有问题，请通过邮件联系。","categories":["计算机图形学"],"tags":["技术","OpenGL"]},{"title":"理解CSS","url":"/2022/07/25/%E7%90%86%E8%A7%A3CSS/","content":"本文于字节跳动青训营期间创作。\n\n\nCSS 是什么？CSS (Cascading Style Sheets) 又称层叠样式表，主要与HTML一同使用，被用来定义页面元素的样式，是用来控制网页外观的一门技术。它可以为HTML页面设置字体和颜色、添加位置和大小、添加动画效果等。\nCSS 的工作流程\nCSS 的使用在页面中使用css的方式有三种。\n外链式&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/style.css&gt;\n\n嵌入式&lt;style&gt;   div&#123;     width:100px;     height:100px;     border:3px soild red;   &#125;&lt;/style&gt;\n\n内联式&lt;div style=&quot;width:100px; height:100px; border:3px soild red;&quot;&gt;&lt;/div&gt;\n\n选择器与属性选择器 (Selector) 会找到并选择页面中的元素，以便给它们设置样式。\n选择器可以使用多种方式选择元素：\n\n按照标签名、类名或id\n按照属性\n按照 DOM 树中的位置\n\n选择器有多种类型：\n通配选择器在 CSS 中，一个星号 (*) 就是一个通配选择器。它可以匹配任意类型的 HTML 元素。在配合其他简单选择器的时候，省略掉通配选择器会有同样的效果。比如，*.warning 和.warning 的效果完全相同。\n*.warning &#123;color:red;&#125;*#maincontent &#123;border: 1px solid blue;&#125;\n\n标签选择器标签选择器主要针对的是页面中某个标签中的样式设置，它的作用范围是这个页面内所有写在该标签内的内容，标签选择器可以定义多个标签的样式\np &#123;color: red;&#125;\n\n类选择器类选择器在定义的时候需要 “.” 来做前缀，类名是自定义的，然后在括号内定义属性和属性值。它不是直接作用在该页面中，而是需要使用class方法去自定义要作用的标签\n.MyClass &#123;\tcolor: red;&#125;\n\n定义完类选择器的样式之后，使用class方法去设置要调用改样式的标签。使用class方法调用类选择器中的样式的时候，直接接类名即可，不需要输入”.”。\n&lt;p class=&quot;MyClass&quot;&gt;Hello&lt;/p&gt;\n\n类选择器可以在页面中的多个标签内重复使用，也可以中定义多个类选择器。\nid选择器ID选择器使用”#”作前缀，标识名照样是自定义的。然后括号内输入要修改样式的属性和属性值。\n#MyId &#123;\tcolor: blue;&#125;\n\n内定义好ID选择器之后，在需要使用该样式的标签内使用ID方法即可。\n&lt;p id=&quot;MyId&quot;&gt;Hello&lt;/p&gt;\n\nID&#x3D;”标识名” 需要注意的是ID选择器可以创建多个，但一个id选择器中的样式只能在页面中的一个标签内使用一次。\n属性选择器类选择器 和 ID 选择器都属于 属性选择器。 应为本质上 类选择器 是 匹配 HTML 中 class 的属性值， ID 选择器 是 匹配 HTML 中的 Id 属性值。\n但此处说的属性选择器则是可以根据元素的属性及属性值来选择元素，与类选择器、ID选择器略有不同。\n属性值 直接匹配 选择器包括下面4 种：\n简单属性选择如果希望选择有某个属性的元素，而不论属性值是什么，可以使用简单属性选择器。\n/*把包含标题（title）的所有元素变为红色*/*[title] &#123;color:red;&#125;/*对有 href 属性的锚（a 元素）应用样式*/a[href] &#123;color:red;&#125;/*将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色*/a[href][title] &#123;color:red;&#125;\n\n根据具体属性值选择除了选择拥有某些属性的元素，还可以进一步缩小选择范围，只选择有特定属性值的元素。\n/*将指向 Web 服务器上某个指定文档的超链接变成红色*/a[href=&quot;http://www.juejin.cn/about.html&quot;] &#123;color: red;&#125;/*与简单属性选择器类似，可以把多个属性-值选择器链接在一起来选择一个文档*/a[href=&quot;http://www.juejin.cn/&quot;][title=&quot;juejin&quot;] &#123;color: red;&#125;\n\n请注意，这种格式要求必须与属性值完全匹配。\n如果属性值包含用空格分隔的值列表，匹配就可能出问题。\n&lt;p class=&quot;important warning&quot;&gt;This paragraph is a very important warning.&lt;/p&gt;&lt;style&gt;\tp[class=&quot;important warning&quot;] &#123;color: red;&#125;&lt;/style&gt;\n\n根据部分属性值选择如果需要根据属性值中的词列表的某个词进行选择，则需要使用波浪号（~），它能用于任何属性。\n/*选择 class 属性中包含 important 的元素*/p[class~=&quot;important&quot;] &#123;color: red;&#125;/*这个规则会选择 title 文本包含 &quot;Figure&quot; 的所有图像。没有 title 属性或者 title 属性中不包含 &quot;Figure&quot; 的图像都不会匹配。*/img[title~=&quot;Figure&quot;] &#123;border: 1px solid gray;&#125;\n\n如果忽略了波浪号，则说明需要完成完全值匹配。\n特定属性选择类型该类型需要使用竖杠（|）。\n/*这个规则会选择 lang 属性等于 en 或以 en- 开头的所有元素*/*[lang|=&quot;en&quot;] &#123;color: red;&#125;\n\n根据以上规则，以下示例标记中的前三个元素将被选中，而不会选择后两个元素：\n/*会被选中*/&lt;p lang=&quot;en&quot;&gt;Hello!&lt;/p&gt;&lt;p lang=&quot;en-us&quot;&gt;Greetings!&lt;/p&gt;&lt;p lang=&quot;en-au&quot;&gt;G&#x27;day!&lt;/p&gt;/*不会被选中*/&lt;p lang=&quot;fr&quot;&gt;Bonjour!&lt;/p&gt;&lt;p lang=&quot;cy-en&quot;&gt;Jrooana!&lt;/p&gt;\n\n组合选择器组合选择器可以让多个选择器公用同一个CSS样式代码。\n后代组合 ( )后代选择器用于选取某元素的后代元素，使用空格分隔。\n/*选取所有&lt;div&gt;元素中的&lt;p&gt;元素应用样式*/div p &#123; background-color:red; &#125;\n\n亲子组合 (&gt;)子元素选择器只能选择作为某元素直接或一级子元素的元素，使用（&gt;）连接。\n/*选择&lt;div&gt;元素中所有直接子元素&lt;p&gt;*/div&gt;p &#123; background-color:red; &#125;\n\n兄弟选择器 (~)找到指定的元素后面的所有满足条件的兄弟元素，使用（~）连接。\n/*选择&lt;p&gt;元素后的所有&lt;h3&gt;元素*/p ~ h3 &#123; color:red; &#125;\n\n相邻选择器 (+)该选择器使用（+）连接，选择紧接在另一个元素后的元素，而且二者有相同的父元素，兄弟只会影响下面的兄弟的样式，不影响上面兄弟的样式。\n/*选择与&lt;h1&gt;元素相邻的&lt;p&gt;元素*/h1 + p &#123; margin-top:50px; color:red; &#125;\n\n分组选择器 (,)分组选择器使用逗号把同组内不同对象分隔，其本质上不是一种选择器类型，而是一种选择器使用方法。当多个对象定义了相同的样式时，就可以把它们分成一组，这样能够简化代码。\n/*定义所有级别的标题和段落行高为22px*/h1,h2,h3,h4,h5,h6,p&#123;    line-height:22px;&#125;\n\n伪类选择器伪类通常用于标记一些特殊的样，用于控制一个元素在不同动作下有不同的样式。\n伪类主要有两方面的用处，一方面是标记一些特殊的状态，另外还有一类伪类是有筛选的功能。\n以下仅记录一些常用的伪类。\n状态伪类/*选取未访问过的超链接元素。如果我们注意过搜索引擎的结果的话，它里面的链接只要点过的就会变色，从而标记哪个链接是访问过的*/:link&#123;&#125;/*选取访问过的超链接元素。和第一条相反，:visited 是用来标记哪个链接是已经访问过的，防止重复点击*/:visited&#123;&#125;/*选取鼠标悬停的元素,当鼠标放在一个元素上时显示的样式*/:hover&#123;&#125;/*选取点中的元素。这个伪类的作用在刚才提到过了，当我们希望按钮有操作反馈的时候，可以用它来标记操作反馈的样式。当然这个伪类也是可以通用的，并不是只能用在按钮上*/:active&#123;&#125;/*选取获得焦点的元素。这个伪类用来标识获得焦点的元素，比如搜索框在聚焦的时候有个比较明显的边框，方便用户知道当前在可输入的状态*/:focus&#123;&#125;\n\n筛选伪类/*选取没有子元素的元素。比如选择空的 span，就可以用 span:empty 选择器来选择。这里要注意元素内有空格的话也不能算空，不会被这个伪类选中*/:empty&#123;&#125;/*选取勾选状态的 input 元素， 只对 radio 和 checkbox 生效*/:checked&#123;&#125;/*选取禁用的表单元素*/:disabled&#123;&#125;/*选取当前选择器下第一个元素*/:first-child&#123;&#125;/*和 first-child 相反，选取当前选择器下最后一个元素*/:last-child&#123;&#125;/*选取指定位置的元素。这个伪类是有参数的，参数可以支持 an+b 的形式，这里 a 和 b 都是可变的，n 从0起。使用这个伪类可以做到选择第几个，或者选择序号符合 an+b 的所有元素。比如使用 li:nth-child(2n+1)，就可以选中 li 元素中序号是2的整数倍加1的所有元素，也就是第1、3、5、7、9、2n+1个 li 元素*/:nth-child(an+b)&#123;&#125;/*这个伪类和 nth-child 相似，只不过在计数的时候，这个伪类是从后往前计数*/:nth-last-child(an+b)&#123;&#125;/*选取唯一子元素。如果一个元素的父元素只有它一个子元素，这个伪类就会生效。如果一个元素还有兄弟元素，这个伪类就不会对它生效*/:only-child&#123;&#125;/*选取唯一的某个类型的元素。如果一个元素的父元素里只有它一个当前类型的元素，这个伪类就会生效。这个伪类允许父元素里有其他元素，只要不和自己一样就可以*/:only-of-type&#123;&#125;\n\n伪元素选择器伪元素选择器是用于向某些元素设置特殊效果。伪元素选择器选中的并不是真实的 DOM 元素，所以叫伪元素选择器。常用的伪元素选择器有5个。\n/*为某个元素的第一行文字使用样式*/::first-line&#123;&#125;/*为某个元素中的文字的首字母或第一个字使用样式*/::first-letter&#123;&#125;/*在某个元素之前插入一些内容*/::before&#123;&#125;/*在某个元素之后插入一些内容*/::after&#123;&#125;/*对光标选中的元素添加样式*/::selection&#123;&#125;\n\n\n\n伪元素选择器构造的元素是虚拟的，所以不能用 JS 去操作它。 \n如果同时使用了 before 和 first-letter 两个伪类，第一个字是要从 before 里的内容开始算起的，如果 before里面的内容是一个非文本元素，那 first-letter 也会作用在这个非文本元素上，但是不一定能生效。 \nfirst-line 和 first-letter 不适用于内联元素，在内联元素中这两个选择器都会失效。 \n在 CSS3 中，规定了伪类用一个冒号（:）表示，伪元素用两个冒号表示（::）。但除了 selection，其余四个伪元素选择器已经在 CSS2 中存在且和伪类用的是一样的单冒号表示的。为了向下兼容，现在的浏览器中伪元素选择器用单冒号和双冒号都可以。在没有兼容问题的情况下，还是建议大家按着新的 CSS3 标准来开发。\n\n\n选择器的特异度选择器的特异度由选择器本身的组件确定。\n如果一个元素有两个或多个冲突的属性声明，那么有最特异度高的声明就会胜出。\n特异度表述为4个部分，如：(0, 0, 0, 0)，从左到右的权重由高到低。\n权重排行（高到低）：\n行内样式 （!important）\nID选择器 #id\nclass、属性、伪类选择器 .titleinput[type=&quot;text&quot;]:hover\n类型和伪元素选择器 div::before\n\n权重向量(0, 0, 0, 0)(行内样式，ID选择器，class&#x2F;属性&#x2F;伪类选择器&#x2F;，类型&#x2F;伪元素)\n若权重相同，则定义靠后优先。\n实例\n&lt;div id=&quot;container&quot;&gt;    &lt;ul class=&quot;menu&quot;&gt;        &lt;li id=&quot;item1&quot; class=&quot;item1&quot;&gt;item1&lt;/li&gt;        &lt;li class=&quot;item2&quot;&gt;item2&lt;/li&gt;        &lt;li class=&quot;item3&quot;&gt;item3&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;style&gt;    /* (0, 1, 3, 1) */    #container .menu li.item2 &#123;        color: #ff4757;    &#125;    /* (0, 1, 2, 1) */    #container li:nth-child(2).item2 &#123;        color: #7bed9f;    &#125;    \t/* (0, 1, 1, 1) */    #container li.item2 &#123;        color: #ffa502;    &#125;    /* (0, 0, 1, 1) */    li.item2 &#123;        color: #5352ed;    &#125;    /* (0, 0, 1, 0) */    .item2 &#123;        color: #ff6b81    &#125;&lt;/style&gt;\n\n继承无继承性的属性\ndisplay：元素布局类型\n文本属性：\nvertical-align：垂直文本对齐\ntext-decration：规定添加到文本的装饰\ntext-shadow：文本阴影效果\nwhite-space：空白符的处理\nunicode-bidi：设置文本的方向\n\n\n盒子模型的属性：\nwidth\nheight\nmargin\nborder\npadding\n\n\n背景属性：\nbackground\nbackground-color\nbackground-image\nbackground-repeat\nbackground-position\nbackground-attachment\n\n\n定位属性：\nfloat\nclear\nposition\ntop\nright\nbottom\nleft\nmin-width\nmin-height\nmax-width\nmax-height\noverflow\nclip\nz-index\n\n\n生成内容属性：\ncontent\ncounter-reset\ncounter-increment\n\n\n轮廓样式属性：\noutline-style\noutline-width\noutline-color\noutline\n\n\n页面样式属性：\nsize\npage-break-before\npage-break-after\n\n\n声音样式属性：\npause-before\npause-after\npause\ncue-before\ncue-after\ncue\nplay-during\n\n\n\n有继承性的属性\n字体系列属性：\nfont-family：字体系列\nfont-weight：字体的粗细\nfont-size：字体的大小\nfont-style：字体的风格\n\n\n文本系列属性\ntext-indent：文本缩进\ntext-align：文本水平对齐\nline-height：行高\nword-spacing：单词之间的间距\nletter-spacing：中文或者字母之间的间距\ntext-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）\ncolor：文本颜色\n\n\n元素可见性：\nvisibility：控制元素显示隐藏\n\n\n列表布局属性：\nlist-style：列表风格，包括list-style-type、list-style-image等\n\n\n光标属性：\ncursor：光标显示为何种形态\n\n\n\n布局内容主要来源：一篇全面的CSS布局学习指南(译) \n布局（layout）即确定内容的大小和位置的算法，其根据元素、容器、兄弟节点和内容等信息来计算。\ncss中的布局有多种。\n常规流布局（normal flow）在正常流中，元素盒子（boxes）会基于文档的写作模式（writing mode）一个接一个地排列。这就意味着，如果你的写作模式是水平方向的（句子是从左到右或从右到左书写），正常流会垂直地一个接一个排列页面的块级元素。\n当然，如果你是在一个垂直方向的写作模式下，句子是垂直方向书写的，所以块级元素会水平方法排列。\n\n\n根元素、浮动和绝对定位的元素会脱离常规流\n其他元素都在常规流之内（in-flow）\n常规流中的盒子，在某种 排版上下文 中参与布局\n\n浮动布局 (float)浮动布局被用来将盒子（box）置于左侧或右侧，同时让内容环绕其展示。\n如果要让一个元素进行浮动，需要为该元素设置一个值为left或right等的float属性。默认值为none。\n.item &#123; float: left &#125;/* 其他常见的float的值 */.item &#123;float: left; &#125; /*表明元素必须浮动在其所在的块容器左侧的关键字。*/.item &#123;float: right; &#125; /*表明元素必须浮动在其所在的块容器右侧的关键字。*/.item &#123;float: none; &#125; /*表明元素不进行浮动的关键字。*/.item &#123;float: inline-start; &#125; /*关键字，表明元素必须浮动在其所在块容器的开始一侧，在 `ltr` 脚本中是左侧，在 `rtl` 脚本中是右侧。*/.item &#123;float: inline-end; &#125; /*关键字，表明元素必须浮动在其所在块容器的结束一侧，在 `ltr` 脚本中是右侧，在 `rtl` 脚本中是左侧。*/\n\n清除浮动一旦你对一个元素应用了浮动，所有接下来的元素都会环绕它直到内容处于它下方且开始应用正常文档流。如果你想要避免这种情况，可以手动去清除浮动。\n当你不想要某个元素受到其之前的浮动元素影响时，为其添加clear属性即可。使用left值可以清除左浮动效果，right值为右浮动，both则会清除左右浮动。\n.clear &#123; clear: both; &#125;/*其他常见的clear的值*/.clear &#123; clear: none; &#125; /*元素不会被向下移动以清除浮动。*/.clear &#123; clear: left; &#125; /*元素被向下移动以清除左浮动。*/.clear &#123; clear: right; &#125; /*元素被向下移动以清除右浮动。*/.clear &#123; clear: both; &#125; /*元素被向下移动以清除左右浮动。*/.clear &#123; clear: inline-start; &#125; /*元素被向下移动以清除其包含块的起始侧浮动，即 ltr 时清除左浮动，rtl 时清除右浮动。*/.clear &#123; clear: inline-end; &#125; /*元素被向下移动以清除其包含块的结束侧浮动，即 ltr 时清除右浮动，rtl 时清除左浮动。*/\n\n定位 (Positioning)position 属性用于指定一个元素在文档中的定位方式。\n想要把一个元素从正常流中移除，或者改变其在正常文档流中的位置，可以使用CSS中的position属性。当处于正常文档流时，元素的position属性为static。在块级维度上元素会一个接一个排列下去，当你滚动页面时元素也会随着滚动。\n当你改变元素的position属性时，通常情况下你也会设置一些偏移量来使元素相对于参照点进行一定的移动。不同的position值会产生不同的参照点。\n静态定位（STATIC POSTIONING）该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。\n.item &#123; position: static; &#125;\n\n相对定位（RELATIVE POSTIONING）在绝对定位中，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。\n如果一个元素具有属性position: relative，那么它偏移的参照位是其原先在正常文档流中的位置。你可以使用top、left、bottom和right属性来相对其正常流位置进行移动。\n.item &#123; position: relative; bottom: 50px; &#125;\n\n\n相对定位是不脱离标准流的, 会继续在标准流中占用一份空间在相对定位中同一个方向上的定位属性只能使用一个由于相对定位是不脱离标准流的, 所以在相对定位中是区分块级元素&#x2F;行内元素&#x2F;行内块级元素由于相对定位是不脱离标准流的, 并且相对定位的元素会占用标准流中的位置, 所以当给相对定位 的元素设置margin&#x2F;padding等属性的时会影响到标准流的布局\n\n绝对定位（ABSOLUTE POSTIONING）给一个元素设置 position: absolute ，其元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。\n因此，当你为某个元素设置 position: absolute 时，首先发生的变化是该元素会定位在视口的左上角。你可以通过设置 top 、left 、bottom 和 right 偏移量属性来将元素移动到你想要的位置。\n.item &#123; position: absolute; top: 20px; right: 20px; &#125;\n\n\n绝对定位参考点：\n规律：默认情况下所有的绝对定位的元素, 无论有没有祖先元素, 都会以 body 作为参考点。\n如果一个绝对定位的元素有祖先元素, 并且祖先元素也是定位流, 那么这个绝对定位的元素就会以定位流的那个祖先元素作为参考点。\n只要是这个绝对定位元素的祖先元素都可以 。\n指的定位流是指绝对定位&#x2F;相对定位&#x2F;固定定位 。\n定位流中只有静态定位不行。\n\n\n如果一个绝对定位的元素有祖先元素, 并且祖先元素也是定位流, 而且祖先元素中有多个元素都是定位流, 那么这个绝对定位的元素会以离它最近的那个定位流的祖先元素为参考点。\n\n\n绝对定位注意点：\n绝对定位的元素是脱离标准流的 。\n绝对定位的元素是不区分块级元素&#x2F;行内元素&#x2F;行内块级元素 。\n如果一个绝对定位的元素是以 body 作为参考点, 那么其实是以网页首屏的宽度和高度作为参考点, 而不是以整个网页的宽度和高度作为参考点 。\n一个绝对定位的元素会忽略祖先元素的 padding。\n\n\n绝对定位-子绝父相：\n相对定位弊端：相对定位不会脱离标准流, 会继续在标准流中占用一份空间, 所以不利于布局界面。\n绝对定位弊端：默认情况下绝对定位的元素会以 body 作为参考点, 所以会随着浏览器的宽度高度的变化而变化。\n子绝父相：子元素用绝对定位, 父元素用相对定位。（如果不这么做，子元素就会相对 body 或浏览器定位产生不好的效果。）\n\n\n\n固定定位（FIXED POSTIONING）position: fixed 的元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform ， perspective 或 filter 属性非 none 时，容器由视口改为该祖先。\n.item &#123; position: fixed; top: 20px; left: 100px; &#125;\n\n当你想要一个固定导航栏一直停留在屏幕上时这会非常有效。\nSTICKY 定位设置 position: sticky 会让元素在页面滚动时如同在正常流中，但当其滚动到相对于视口的某个特定位置时就会固定在屏幕上，如同fixed一般。\n.item &#123; position: sticky; top: 0; &#125;\n\n弹性布局（Flex Layout）弹性盒子（Flexbox）布局是一种为一维布局而设计的布局方法。一维的意思是你希望内容是按行或者列来布局。你可以使用 display: flex 来将元素变为弹性布局。\n.container &#123; display: flex; &#125;\n\nFlex的主轴与交叉轴当使用 flex 布局时，首先想到的是两根轴线 — 主轴和交叉轴。主轴由 flex-direction 定义，另一根轴垂直于它。我们使用 flexbox 的所有属性都跟这两根轴线有关，所以有必要在一开始首先理解它。\n主轴主轴由 flex-direction 定义，可以取 4 个值（默认为 row ）：\n\nrow\nrow-reverse\ncolumn\ncolumn-reverse\n\n如果你选择了 row 或者 row-reverse，你的主轴将沿着 inline 方向延伸。\n.itme &#123; \tdisplay: flex; \tflex-direction: row; &#125;\n\n选择 column 或者 column-reverse 时，你的主轴会沿着上下方向延伸 — 也就是 block 排列的方向。\n交叉轴交叉轴垂直于主轴，所以如果你的flex-direction (主轴) 设成了 row 或者 row-reverse 的话，交叉轴的方向就是沿着列向下的。\n如果主轴方向设成了 column 或者 column-reverse，交叉轴就是水平方向。\n理解主轴和交叉轴的概念对于对齐 flexbox 里面的元素是很重要的；flexbox 的特性是沿着主轴或者交叉轴对齐之中的元素。\nflex-wrap虽然flexbox是一维模型，但可以使我们的flex项目应用到多行中。在这样做的时候，您应该把每一行看作一个新的flex容器。任何空间分布都将在该行上发生，而不影响该空间分布的其他行。\n为了实现多行效果，请为属性 flex-wrap 添加一个属性值 wrap 。现在，如果您的项目太大而无法全部显示在一行中，则会换行显示。下面的实时例子包含已给出宽度的项目，对于 flex 容器，项目的子元素总宽度大于容器最大宽度。由于 flex-wrap 的值设置为 wrap ，所以项目的子元素换行显示。若将其设置为 nowrap ，这也是初始值，它们将会缩小以适应容器，因为它们使用的是允许缩小的初始 Flexbox 值。如果项目的子元素无法缩小，使用 nowrap 会导致溢出，或者缩小程度还不够小。\n.item &#123; \tdisplay: flex; \tflex-wrap: wrap;\t/*flex-wrap: nowrap;*/&#125;\n\n一些Flex的属性这些flex的属性是用来控制弹性项在主轴上空间大小的。这三个属性是：\n\nflex-grow\nflex-shrink\nflex-basis\n\n通常可以使用它们的简写形式：flex 。第一个值代表 flex-grow ，第二个是 flex-shrink ，而第三个则是 flex-basis 。\n.item &#123; flex: 1 1 200px; &#125;\n\nflex-basis 会为弹性项设置未拉伸和压缩时的初始大小。在上面的例子中，大小是200px，因此我们会给每个项200px的空间大小。但是大多数情况下容器元素大小不会正好被分为许多200px大小的项，而是可能有一些不足或剩余空间。 flex-grow 和 flow-shrink 属性允许我们在容器大小不足或有空余时控制各个弹性项的大小。\n如果 flex-grow 的值是任意的正数，那么弹性项会被允许拉伸来占据更多的空间。因此，在上面的例子中，当各项被设为200px后，所有多余的空间会被每个弹性项平分并填满。\n如果 flex-shrink 的值为任意的正数，那么当弹性项被设置了 flex-basis 后，元素溢出容器时会进行收缩。在上面这个CSS的例子中，如果容器空间不足，每个弹性项会等比例缩放以适应容器的大小。\nflex-grow 和 flex-shrink 的值可以是任意的正数。一个具有较大 flex-grow 值的弹性项会在容器有剩余空间时拉伸更大的比例；而一个具有更大 flex-shrink 值的项则会在容器空间不足时被压缩的更多。\n大多数情况下可以用预定义的简写形式。在这个教程中你可能经常会看到这种写法，许多情况下你都可以这么使用。下面是几种预定义的值：\n\nflex: initial\nflex: auto\nflex: none\nflex: &lt;positive-number&gt;\n\nflex: initial 是把 flex 元素重置为 Flexbox 的初始值，它相当于 flex: 0 1 auto。在这里 flex-grow 的值为 0，所以 flex 元素不会超过它们 flex-basis 的尺寸。flex-shrink 的值为 1, 所以可以缩小 flex 元素来防止它们溢出。flex-basis 的值为 auto. Flex 元素尺寸可以是在主维度上设置的，也可以是根据内容自动得到的。\nflex: auto 等同于 flex: 1 1 auto；和上面的 flex:initial 基本相同，但是这种情况下，flex 元素在需要的时候既可以拉伸也可以收缩。\nflex: none 可以把 flex 元素设置为不可伸缩。它和设置为 flex: 0 0 auto 是一样的。元素既不能拉伸或者收缩，但是元素会按具有 flex-basis: auto 属性的 flexbox 进行布局。\n你在教程中常看到的 flex: 1 或者 flex: 2 等等。它相当于flex: 1 1 0。元素可以在flex-basis为 0 的基础上伸缩。\n网格布局（grid layout）内容主要来源：最强大的 CSS 布局 —— Grid 布局\nCSS网格布局（grid layout）是一种用来进行二维布局的技术。二维（two-dimesional）意味着你希望按照行和列来排布你的内容。和弹性盒子类似，网格布局也需要设置一个 display 值。你可以为容器元素设置 display: grid ，并且使用 grid-template-columns 和 grid-template-rows 属性来控制网格中的行与列。\nGrid 布局是将容器划分成了“行”和“列”，产生了一个个的网格，我们可以将网格元素放在与这些行和列相关的位置上，从而达到我们布局的目的。\n.container &#123; \tdisplay: grid; \tgrid-template-columns: 200px 200px 200px; \tgrid-template-rows: 200px 200px; &#125;\n\ngrid-template-columns 属性和 grid-template-rows 属性grid-template-columns 属性设置列宽，grid-template-rows 属性设置行高，这两个属性在 Grid 布局中尤为重要，它们的值是有多种多样的，而且它们的设置是比较相似的。\n.wrapper &#123; \tdisplay: grid; \t/* 声明了三列，宽度分别为 200px 100px 200px */ \tgrid-template-columns: 200px 100px 200px; \t/* 声明了两行，行高分别为 50px 50px */ \tgrid-template-rows: 50px 50px; \tgrid-gap: 5px; &#125;\n\n以上表示固定列宽为 200px 100px 200px，行高为 50px 50px 。\n\nrepeat() 函数repeat() 函数可以简化重复的值。该函数接受两个参数，第一个参数是重复的次数，第二个参数是所要重复的值。比如上面行高都是一样的，我们可以这么去实现，实际效果是一模一样的。\n.wrapper &#123; display: grid; grid-template-columns: 200px 100px 200px; grid-gap: 5px; /* 2行，而且行高都为 50px */ grid-template-rows: repeat(2, 50px);&#125;\n\nauto-fill 关键字auto-fill 关键字表示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格。grid-template-columns: repeat(auto-fill, 200px) 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素\n.wrapper &#123; \tdisplay: grid; \tgrid-template-columns: repeat(auto-fill, 200px); \tgrid-gap: 5px; \tgrid-auto-rows: 50px;&#125;\n\n\nfr 关键字Grid 布局还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。fr 单位代表网格容器中可用空间的一等份。grid-template-columns: 200px 1fr 2fr 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1&#x2F;3 和 2&#x2F;3。\n.wrapper &#123; \tdisplay: grid; \tgrid-template-columns: 200px 1fr 2fr; \tgrid-gap: 5px; \tgrid-auto-rows: 50px; &#125;\n\n\nminmax() 函数minmax() 函数：我们有时候想给网格元素一个最小和最大的尺寸，minmax() 函数产生一个长度范围，表示长度就在这个范围之中都可以应用到网格项目中。它接受两个参数，分别为最小值和最大值。grid-template-columns: 1fr 1fr minmax(300px, 2fr) 的意思是，第三个列宽最少也是要 300px，但是最大不能大于第一第二列宽的两倍。\n.wrapper-4 &#123; \tdisplay: grid; \tgrid-template-columns: 1fr 1fr minmax(300px, 2fr); \tgrid-gap: 5px; \tgrid-auto-rows: 50px; &#125;\n\n\ngrid-row-gap 属性、grid-column-gap 属性以及 grid-gap 属性grid-row-gap 属性、grid-column-gap 属性分别设置行间距和列间距。grid-gap 属性是两者的简写形式。\ngrid-row-gap: 10px 表示行间距是 10px，grid-column-gap: 20px 表示列间距是 20px。grid-gap: 10px 20px 实现的效果是一样的\n.wrapper &#123; \tdisplay: grid; \tgrid-template-columns: 200px 100px 100px; \tgrid-gap: 10px 20px; \tgrid-auto-rows: 50px; &#125;.wrapper-1 &#123; \tdisplay: grid; \tgrid-template-columns: 200px 100px 100px; \tgrid-auto-rows: 50px; \tgrid-row-gap: 10px; \tgrid-column-gap: 20px; &#125;\n\n基于行&#x2F;列的基本定位方法定位网格元素最简单的方式是使用基于行&#x2F;列（line）的定位方法，只需告诉浏览器从哪一排到哪一排来进行合并。例如，如果你需要一个2*2的网格区域，你可以将指定元素从第一行开始到第三行、从第一列开始到第三列，这样就可以覆盖到四个单元格。\n.item &#123; \tgrid-column-start: 1; \tgrid-column-end: 3; \tgrid-row-start: 1; \tgrid-row-end: 3; &#125;\n\n这些属性可以用缩写来表示：grid-column和grid-row，其中起一个值代表起始值，第二个值代表结束值。\n.item &#123; \tgrid-column: 1 / 3; \tgrid-row: 1 / 3; &#125;\n\n你也可以让网格项（grid item）占据同一个单元格。支持一些内容间会覆盖的设计。网格项会像通常网页中的元素那样叠起来，在html源码中下面的网格项会叠在其他元素上面。你仍然可以用z-index来控制它的堆叠顺序。\n实例：\n&lt;div class=&quot;container&quot;&gt;\t&lt;div class=&quot;one&quot;&gt;1&lt;/div&gt;\t&lt;div class=&quot;two&quot;&gt;2&lt;/div&gt; \t&lt;div class=&quot;three&quot;&gt;3&lt;/div&gt; \t&lt;div class=&quot;four&quot;&gt;4&lt;/div&gt; \t&lt;div class=&quot;five&quot;&gt;5&lt;/div&gt; &lt;/div&gt;&lt;style&gt;\tbody &#123; \t\tpadding: 20px; \t\tfont: 1em Helvetica Neue, Helvetica, Arial, sans-serif; \t&#125; \t* &#123;\t\tbox-sizing: border-box;\t&#125; \tp &#123; \t\tmargin: 0 0 1em 0; \t&#125; \t.container &#123; \t\twidth: 500px; \t\tborder: 5px solid rgb(111,41,97); \t\tborder-radius: .5em; \t\tpadding: 10px; \t\tdisplay: grid; \t\tgrid-template-columns: 1fr 1fr 1fr; \t\tgrid-gap: 20px; \t&#125; \t.container &gt; div &#123; \t\tpadding: 10px; \t&#125; \t.one &#123; \t\tgrid-column: 1 / 4; \t\tgrid-row: 1; \t\tbackground-color: rgba(111,41,97,.3); \t\tborder: 2px solid rgba(111,41,97,.5); \t&#125; \t.two &#123; \t\tgrid-column: 1 / 3; \t\tgrid-row: 2; \t\tbackground-color: rgba(111,41,97,.3); \t\tborder: 2px solid rgba(111,41,97,.5); \t&#125; \t.three &#123; \t\tgrid-column: 2 / 4; \t\tgrid-row: 2 / 5; \t\tbackground-color: rgba(193,225,237,.3); \t\tborder: 2px solid rgba(193,225,237,.5); \t&#125; \t.four &#123; \t\tgrid-column: 1; \t\tgrid-row: 4 ; \t\tbackground-color: rgba(193,225,237,.3); \t\tborder: 2px solid rgba(193,225,237,.5); \t&#125; \t.five &#123; \t\tgrid-column: 3 ; \t\tgrid-row: 4 / 5; \t\tbackground-color: rgba(111,41,97,.3); \t\tborder: 2px solid rgba(111,41,97,.5); \t&#125;&lt;/style&gt;\n\n\n通过命名区域来定位元素你可以通过命名区域（named areas）来定位网格中的元素。要是用这种方式，你需要给每个元素一个名字，然后通过grid-template-areas属性的值来描述布局方式。\n.item1 &#123; grid-area: a; &#125; .item2 &#123; grid-area: b; &#125; .item3 &#123; grid-area: c; &#125; .container &#123; \tdisplay: grid; \tgrid-template-columns: 1fr 1fr 1fr 1fr; \tgrid-template-areas: &quot;a a b b&quot; \t\t\t\t\t\t &quot;a a c c&quot;; &#125;\n\n使用这种方式有几个需要注意的点。如果你想要合并一些单元格作为你的网格项，你需要重复元素的名字。网格区域需要能形成一个完整的矩形 —— 每个单元格都需要被填入一个值。如果你想要空出某些单元格，那就需要使用 . 这个值。\n.container &#123; \tdisplay: grid; \tgrid-template-columns: 1fr 1fr 1fr 1fr; \tgrid-template-areas: &quot;a a b b&quot; \t\t\t\t\t\t &quot;a a c .&quot;; &#125;\n\n实例：\n&lt;div class=&quot;container&quot;&gt;\t&lt;div class=&quot;one&quot;&gt;1&lt;/div&gt;\t&lt;div class=&quot;two&quot;&gt;2&lt;/div&gt; \t&lt;div class=&quot;three&quot;&gt;3&lt;/div&gt; \t&lt;div class=&quot;four&quot;&gt;4&lt;/div&gt; \t&lt;div class=&quot;five&quot;&gt;5&lt;/div&gt; &lt;/div&gt;&lt;style&gt;\tbody &#123; \t\tpadding: 20px; \t\tfont: 1em Helvetica Neue, Helvetica, Arial, sans-serif; \t&#125; \t* &#123;\t\tbox-sizing: border-box;\t&#125; \tp &#123; \t\tmargin: 0 0 1em 0; \t&#125; \t.container &#123; \t\twidth: 500px; \t\tborder: 5px solid rgb(111,41,97); \t\tborder-radius: .5em; \t\tpadding: 10px; \t\tdisplay: grid; \t\tgrid-template-columns: 1fr 1fr 1fr; \t\tgrid-auto-rows: minmax(50px, auto);\t\tgrid-gap: 20px; \t\tgrid-template-areas: &quot;a a a&quot; \t\t\t\t\t\t\t &quot;b c c&quot; \t\t\t\t\t\t\t &quot;. . d&quot; \t\t\t\t\t\t\t &quot;e e d&quot;;\t&#125; \t.container &gt; div &#123; \t\tpadding: 10px; \t\tbackground-color: rgba(111,41,97,.3); \t\tborder: 2px solid rgba(111,41,97,.5);\t&#125; \t.one &#123; \t\tgrid-area: a;\t&#125; \t.two &#123; \t\tgrid-area: b;\t&#125; \t.three &#123; \t\tgrid-area: c; \t&#125; \t.four &#123; \t\tgrid-area: d;\t&#125; \t.five &#123; \t\tgrid-area: e;\t&#125;&lt;/style&gt;\n\n\n排版上下文行级排版上下文\nInline Formatting Context (IFC)\n只包含行级盒子 的容器会创建一个IFC\nIFC 内的排版规则：\n盒子在同一行水平摆放\n一行放不下时，换行显示\ntext-align 决定一行内盒子的水平对齐\nvertical-align 决定一个盒子的水平对其\n避开浮动（float）元素*\n\n\n\n块级排版上下文\nBlock Formatting Context (BFC)\n某些元素会创建一个BFC：\n根元素\n浮动、绝对定位、inline-block\nFlex子项和Gird子项\noverflow 值不是 visible 的块盒\ndisplay:flow-root;\n\n\n\n网格布局格式化上下文\nGrid Formatting Context (GFC)\n声明display:grid&#x2F;inline-grid能创建一个网格容器，网格容器会为其内容产生GFC。\n网格布局引入了二维网格布局系统，通过一组相交的水平线和垂直线来定义网格的列和行，网格元素被布局到这些行和列相关的位置上。\n\n弹性格式化上下文\nFlex Formatting Context (FFC)\n声明display:flex&#x2F;inline-flex能创建一个弹性容器，弹性容器会为其内容产生FFC。\n\n颜色RGBrgb(#fff, #fff, #fff);/* rgba(#fff, #fff, #fff, 1); */\n\nHSLhsl(120, 66%, 50%);/* hsla(120, 66%, 50%, 1); */\n\n\n字体font-familyfont-family 可以把多个字体名称作为一个“回退”系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。也就是说，font-family 属性的值是用于某个元素的字体族名称或&#x2F;及类族名称的一个优先表。\nfont-family:&quot;Times New Roman&quot;,Georgia,Serif;\n\nfont-size用于设置 字体大小，辅以单位控制，实质上是控制 字符框 的高度。\nfont-stylefont-style属性指定文本的字体样式。\nfont-style:normal; /*默认值。浏览器显示一个标准的字体样式。*///font-style:italic; /*浏览器会显示一个斜体的字体样式。*///font-style:oblique; /*浏览器会显示一个倾斜的字体样式。*///font-style: inherit ; /*规定应该从父元素继承字体样式。*/\n\nfont-weightfont-weight 属性设置文本的粗细。\nfont-weight:normal; /*默认值，标准。*///font-weight:bold; /*加粗*///font-weight:900; /*自定义数值*/\n\nfont-variantfont-variant 属性设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小\nfont-variant 属性主要用于定义小型大写字母文本\nfont-variant:normal; /*默认值。浏览器会显示一个标准的字体。*///font-variant:normal; /*浏览器会显示小型大写字母的字体。*///font-variant:normal; /*规定应该从父元素继承 font-variant 属性的值。*/\n\nfontfont 简写属性在一个声明中设置所有字体属性。\n可设置的属性是（按顺序）： “font-style font-variant font-weight font-size&#x2F;line-height font-family”\nfont-size和font-family的值是必需的。如果缺少了其他值，默认值将被插入，如果有默认值的话。\nfont:15px arial,sans-serif;//font:italic bold 12px/30px Georgia, serif;\n\n文本格式line-height设置以百分比计的行高。\nline-height:90%//line-height:200%\n\n注意： 负值是不允许的\nwhite-space指定元素内的空白怎样处理。\nwhite-space:normal; /*默认。空白会被浏览器忽略。*///white-space:pre; /*空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。*///white-space:nowrap; /*文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。*///white-space:pre-wrap; /*保留空白符序列，但是正常地进行换行。*///white-space:pre-line; /*合并空白符序列，但是保留换行符。*///white-space:inherit; /*规定应该从父元素继承 white-space 属性的值。*/\n\n盒子模型块级Block Level Box 不和其他盒子并列摆放，适用所有的盒模型属性。\n块级元素生成块级盒子：body、article、div、main、section、h1-6、p、ul、li 等。\ndisplay:block;\n\n行级Inline Level Box 和其他行级盒子一起放在一行或拆开成多行，盒模型中的width、height不适用。\n行级元素生成行级盒子，内容分散在多个行盒（line box）中：span、em、strong、cite、code 等。\ndisplay:inline;\n\nFlex BoxFlex Box 是一种新的排版上下文，它可以控制子级盒子的：\n\n摆放的流向（→ ↑ ↓ ←）\n摆放顺序\n盒子宽度和高度\n水平和垂直方向的对齐\n是否允许折行\n\ndisplay:flex;/* 项目在主轴上的对齐方式 */justify-content: center;     /* 居中排列 */  //justify-content: start;      /* 从行首开始排列 */  //justify-content: end;        /* 从行尾开始排列 */  //justify-content: flex-start; /* 从行首起始位置开始排列 */  //justify-content: flex-end;   /* 从行尾位置开始排列 */  //justify-content: left;       /* 一个挨一个在对齐容器得左边缘 */  //justify-content: right;      /* 元素以容器右边缘为基准，一个挨着一个对齐, */    /* 基线对齐 */  //justify-content: baseline;  //justify-content: first baseline;  //justify-content: last baseline;    /* 分配弹性元素方式 */  //justify-content: space-between;  /* 均匀排列每个元素，首个元素放置于起点，末尾元素放置于终点 */  //justify-content: space-around;  /* 均匀排列每个元素，每个元素周围分配相同的空间 */  //justify-content: space-evenly;  /* 均匀排列每个元素，每个元素之间的间隔相等 */  //justify-content: stretch;       /* 均匀排列每个元素，auto-sized 的元素会被拉伸以适应容器的大小 */    /* 溢出对齐方式 */  //justify-content: safe center;  //justify-content: unsafe center;    /* 全局值 */  //justify-content: inherit;  //justify-content: initial;  //justify-content: unset;/* 项目在交叉轴上的对齐方式 *///align-items:...;/* 多行项目的排列方式 *///align-content:...;\n\ndisplay 属性display:block; /*块级盒子*///display:linine; /*行级盒子*///display:inline-block; /*本身是行级，可以放在行盒中；可以设置宽高；作为一个整体不会被拆散成多行*///display:flex; /*浮动布局*///display:none; /*排版时完全被忽略*/\n\n调试 CSS\n在chrome浏览器中，可以通过F12或菜单，打开“开发者工具”。\nctrl + shift + i\n\nCreate By Asuka24601\n\n\n\n你可以在这里:[https://asuka24601.github.io/2022/07/25/理解CSS/]找到这篇文章，如有问题，请通过邮件联系。","categories":["技术"],"tags":["技术","前端","CSS"]},{"title":"使用cout标准输出控制小数点后位数","url":"/2021/12/30/%E4%BD%BF%E7%94%A8cout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E4%BD%8D%E6%95%B0/","content":"范围float 和 double 的范围是由指数的位数来决定的。  \nfloat 的指数位有8位，而 double 的指数位有11位，分布如下:  \n\nfloat : 1bit（符号位） 8bits（指数位） 23bits（尾数位）double : 1bit（符号位） 11bits（指数位） 52bits（尾数位）  \n\n于是，float的指数范围为-127 ~ +128，而double的指数范围为-1023 ~ +1024，并且指数位是按补码的形式来划分的。  \n其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。  \nfloat 的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；\ndouble 的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。\n精度  float 和 double 的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。  \n  float : 2^23 &#x3D; 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字；  \n  double : 2^52 &#x3D; 4503599627370496，一共16位，同理，double的精度为15~16位。\n示例代码这属于冷门知识了。\n#include &lt;iostream&gt;#include &lt;iomanip&gt; //此头文件是输入/输出库的一部分。using namespace std;int main()&#123;    const double value = 12.3456789;    cout &lt;&lt; value &lt;&lt; endl; // 默认以6精度，所以输出为 12.3457    cout &lt;&lt; setprecision(4) &lt;&lt; value &lt;&lt; endl; // 改成4精度，所以输出为12.35    cout &lt;&lt; setprecision(8) &lt;&lt; value &lt;&lt; endl; // 改成8精度，所以输出为12.345679    cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; value &lt;&lt; endl; // 加了fixed意味着是固定点方式显示，所以这里的精度指的是小数位，输出为12.3457    cout &lt;&lt; value &lt;&lt; endl; // fixed和setprecision的作用还在，依然显示12.3457    cout.unsetf( ios::fixed ); // 去掉了fixed，所以精度恢复成整个数值的有效位数，显示为12.35    cout &lt;&lt; value &lt;&lt; endl;    cout.precision( 6 ); // 恢复成原来的样子，输出为12.3457    cout &lt;&lt; value &lt;&lt; endl;    return 0;&#125;\n\n\n\nCreate By Asuka24601\n\n\n\n你可以在这里:[https://asuka24601.github.io/2021/12/30/使用cout标准输出控制小数点后位数/]找到这篇文章，如有问题，请通过邮件联系。","categories":["C/C++"],"tags":["技术","C++"]},{"title":"西瓜书学习笔记(1)","url":"/2023/12/18/%E8%A5%BF%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/","content":"\n\n\n机器学习的定义正如我们根据过去的经验来判断明天的天气，人们希望从购买经验中挑选一个好瓜，那能不能让计算机帮助人类来实现这个呢？机器学习正是这样的一门学科，人的”经验”对应计算机中的”数据”， 让计算机来学习这些经验数据，生成一个算法模型，在面对新的情况中，计算机便能作出有效的判断，这便是机器学习 。\n另一本经典教材的作者 Mitchell 给出了一个形式化的定义，假设：\n\nP ：计算机程序在某任务类T上的性能。\nT ：计算机程序希望实现的任务类。\nE ：表示经验，即历史的数据集。\n\n若该计算机程序通过利用经验E在任务T上获得了性能P的改善，则称该程序对E进行了学习。\n机器学习的一些基本术语假设我们收集了一批西瓜的数据，例如：(色泽=青绿;根蒂=蜷缩;敲声=浊响) ， (色泽=乌黑;根蒂=稍蜷;敲声=沉闷)， (色泽=浅自;根蒂=硬挺;敲声=清脆)……每对括号内是一个西瓜的记录。定义：\n\n所有记录的集合为： 数据集 。\n\n每一条记录为：一个 示例（instance）或样本（sample） 。\n\n单个的特点(例如西瓜的色泽或敲声)：为 特征（feature）或属性（attribute） 。\n\n\n对于一条记录，如果在坐标轴上表示，每个西瓜都可以用坐标轴中的一个点表示，一个点也是一个向量，例如（青绿，蜷缩，浊响），即每个西瓜为：一个 特征向量（feature vector） 。\n一个样本的特征数为：维数（dimensionality） ，该西瓜的例子维数为3，当维数非常大时会产生”维数灾难”。\n计算机程序学习经验数据生成算法模型的过程中，每一条记录称为一个”训练样本”，同时在训练好模型后，我们希望使用新的样本来测试模型的效果，则每一个新的样本称为一个”测试样本”。定义：\n\n所有 训练样本 的集合为： 训练集（trainning set） ，[特殊] 。\n\n所有 测试样本 的集合为： 测试集（test set） ，[一般] 。\n\n\n机器学习出来的模型适用于新样本的能力为： 泛化能力（generalization） ，即从特殊到一般。\n\n用一个实际例子来说明一下，就像考试之前我们肯定是要反复做题的，为的就是考试能考个好点的成绩。但是考试大多数都是新题，谁也没做过，考前的刷题是为了掌握试题的规律，能够举一反三、学以致用，这样我们在做新题的时候也能够从容面对。这种规律的掌握便是泛化能力，有的同学就能很好掌握这种规律，考试考个高分，也就是说他的”泛化能力”好。考试考的不好的同学，无非是这三个原因：\n\n泛化能力弱，做了很多题，始终掌握不了规律，不管遇到老题还是新题都不会做；\n泛化能力弱，做了很多题，只会死记硬背，看到考试的新题就懵了；\n完全不做题，考试都是靠想象力瞎蒙。\n\n在机器学习中，我们把第一类情况称为欠拟合，第二类情况称为过拟合，第三类情况称作不收敛。\n\n西瓜的例子中，我们是想计算机通过学习西瓜的特征数据，训练出一个决策模型，来判断一个新的西瓜是否是好瓜。可以得知我们预测的是：西瓜是好是坏，即好瓜与差瓜两种，是离散值。同样地，也有通过历年的人口数据，来预测未来的人口数量，人口数量则是连续值。定义：\n\n预测值为 离散 值的问题为： 分类（classification） 。\n\n预测值为 连续 值的问题为： 回归（regression） 。\n\n\n我们预测西瓜是否是好瓜的过程中，很明显对于训练集中的西瓜，我们事先已经知道了该瓜是否是好瓜，学习器通过学习这些好瓜或差瓜的特征，从而总结出规律，即训练集中的西瓜我们都做了标记，称为标记信息。但也有没有标记信息的情形，例如：我们想将一堆西瓜根据特征分成两个小堆，使得某一堆的西瓜尽可能相似，即都是好瓜或差瓜，对于这种问题，我们事先并不知道西瓜的好坏，样本没有标记信息。定义：\n\n训练数据 有标记信息 的学习任务为： 监督学习（supervised learning） ，容易知道上面所描述的分类和回归都是监督学习的范畴。\n\n训练数据 没有标记信息 的学习任务为： 无监督学习（unsupervised learning） ，常见的有聚类和关联规则。\n\n\n假设空间我们可以把学习过程看作一个在所有 假设(hypothesis)组成的空间 中进行搜索的过程，搜索目标是找到与训练集”匹配”(fit)的假设，即能够将训练集中的瓜判断正确的假设。\n\n假设空间既”由输入空间到输出空间的映射的集合”，我们把所有可能的由输入空间 X 到输出空间 Y 的映射 f : XY 构成的集合记为，则假设空间为的一个子集，即。也就是我们可以自行选择所考虑问题的假设空间的大小范围，并不一定非要选择包含所有可能性的映射集作为假设空间。\n\n假设的表示一旦确定，假设空间及其规模大小就确定了。这里我们的假设空间由形如”(色泽=?)(根蒂=?)(敲声=?)”的可能取值所形成的假设组成。\n\n例如色泽有”青绿”、”乌黑”、”浅白”这三种可能取值;还需考虑到，也许”色泽”无论取什么值都合适，我们用通配符来表示，例如”好瓜(色泽=*)(根蒂=蜷缩)(敲声=浊响)”，即”好瓜是根蒂蜷缩、敲声浊响的瓜，什么色泽都行”。\n\n此外，还需考虑极端情况:有可能”好瓜”这个概念根本就不成立，世界上没有”好瓜”这种东西;我们用表示这个假设。这样，若”色泽””根蒂””敲声”分别有3、2、2种可能取值，则我们面临的假设空间规模大小为4x3x3+1=37。\n版本空间现实问题中我们常面临很大的假设空间，但学习过程是基于 有限样本训练集进行的，因此，可能有多个假设与训练集一致，即存在着一个与训练集一致的”假设集合”，我们称之为 版本空间(version space) 。\n归纳偏好对于一个具体的学习算法而言，它必须要产生一个模型。这时，学习算 法本身的”偏好”就会起到关键的作用。\n\n例如，若我们的算法喜欢”尽可能特殊”的模型,则它会选择”好瓜(色泽=*)(根蒂=蜷缩)(敲声=浊响)”; 但若我们的算法喜欢”尽可能一般”的模型，并且由于某种原因它更”相信”根蒂,则它会选择”好瓜(色泽=*)(根蒂=蜷缩)(敲声=*)”。\n\n机器学习算法在学习过程中对某种类型假设的偏好，称为 归纳偏好(inductive bias), 或简称为”偏好”。\n归纳偏好可看作学习算法自身在一个可能很庞大的假设空间中对假设进 行选择的启发式或”价值观”。\n事实上，归纳偏好对应了学习算法本身所做出的关于”什么样的模型更好”的假设。在具体的现实问题中，这个假设是否成立，即算法的归纳偏好是否与问题本身匹配,大多数时候直接决定了算法能否取得好的性能。\n“没有免费午餐”定理在计算机人工智能（AI）领域，“没有免费午餐”（No Free Lunch，NFL）定理 特别指出，不存在一种算法能够在所有可能的问题上都优于其他算法。这一定理对于理解和选择机器学习和优化算法尤其重要。\n在机器学习和人工智能中,我们经常面临模型或算法的选择问题。”没有免费午餐”定理明确告诉我们:\n\n没有单一的机器学习模型能够保证在所有可能的问题上都优于其他模型。每个模型都有其擅长和不擅长的问题。\n\n机器学习算法的性能高度依赖于所处理问题的特点以及数据的统计属性。算法和问题域之间的适配性至关重要。\n\n在比较不同的机器学习算法时,必须基于某特定问题和数据集进行比较。在不同问题下进行的比较并无意义。\n\n\n这一定理强调了针对具体问题设计和选择算法的重要性。它也解释了为什么在机器学习研究中,几乎所有算法和模型的分析都是基于某特定数据集的。\n总之，这个定理是让我们意识到，讨论算法的优劣，泛化能力的强弱，都不能脱离实际的问题，要针对具体的问题具体地分析。\nCreate By Asuka24601\n\n\n\n\n你可以在这里:[https://asuka24601.github.io/2023/12/18/西瓜书学习笔记-1/]找到这篇文章，如有问题，请通过邮件联系。","categories":["机器学习"],"tags":["机器学习","算法","读书笔记"]},{"title":"西瓜书学习笔记(2)","url":"/2023/12/19/%E8%A5%BF%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/","content":"\n\n\n经验误差与过拟合我们把学习器的实际预测输出与样本的真实输出之间的差异称为 误差(error) :\n\n在训练集上的误差称为 训练误差(training error) 或 经验误差(empirical error)\n在新样本上的误差称为 泛化误差(generalization error)\n在测试集上的误差称为 测试误差(test error)\n\n显然，我们希望得到的是在新样本上表现得很好的学习器，即泛化误差小的学习器。因此，我们应该让学习器尽可能地从训练集中学出普适性的”一般特征”，这样在遇到新样本时才能做出正确的判别。然而，当学习器把训练集学得”太好”的时候，即把一些训练样本的自身特点当做了普遍特征；同时也有学习能力不足的情况，即训练集的基本特征都没有学习出来。我们定义：\n\n学习能力过强，以至于把训练样本所包含的不太一般的特性都学到了，称为： 过拟合(overfitting)\n学习能太差，训练样本的一般性质尚未学好，称为： 欠拟合(underfitting)\n\n\n在过拟合问题中，训练误差十分小，但测试误差教大；在欠拟合问题中，训练误差和测试误差都比较大。\n目前，欠拟合问题比较容易克服，例如增加迭代次数等，但过拟合问题还没有十分好的解决方案，过拟合是机器学习面临的关键障碍。\n过拟合是无法彻底避免的，我们所能做的只是”缓解”，或者说减小其风险。关于这一点，可大致这样理解:机器学习面临的问题通常是NP难甚至更难，而有效的学习算法必然是在多项式时间内运行完成，若可彻底避免过拟合，则通过经验误差最小化就能获最优解，这就意味着我们构造性地证明了”P=NP” ;因此，只要相信”PNP”，过拟合就不可避免。\n评估方法通常，我们可通过实验测试来对学习器的泛化误差进行评估并进而做出选择。为此需使用一个 测试集(testing set) 来测试学习器对新样本的判别能力，然后以测试集上的 测试误差(testing error) 作为 泛化误差 的近似。\n测试样本也是从样本真实分布中独立同分布采样而得，测试集应该尽可能与训练集互斥，即测试样本尽量不在训练集中出现、未在训练过程中使用过。\n\n假设老师出了10道习题供同学们练习，考试时老师又用同样的这10道题作为试题，可能有的童鞋只会做这10 道题却能得高分，很明显：这个考试成绩并不能有效地反映出真实水平。回到我们的问题上来，我们希望得到泛化性能好的模型，好比希望同学们课程学得好并获得了对所学知识”举一反三”的能力；训练样本相当于给同学们练习的习题，测试过程则相当于考试。显然，若测试样本被用作训练了，则得到的将是过于”乐观”的估计结果。\n\n留出法将数据集D划分为两个互斥的集合，一个作为训练集S，一个作为测试集T，满足D=ST且ST=，常见的划分为：大约~的样本用作训练，剩下的用作测试。\n需要注意的是：训练/测试集的划分要尽可能保持数据分布的一致性，以避免由于分布的差异引入额外的偏差，常见的做法是采取分层抽样。同时，由于划分的随机性，单次的留出法结果往往不够稳定，一般要采用若干次随机划分，重复实验取平均值的做法。\n\n例如进行100次随机划分，每次产生一个训练/测试集用于实验评估，100次后就得到100个结果，而留出法返回的则是这100个结果的平均。\n\n交叉验证法(K倍交叉验证)将数据集D划分为k个大小相同的互斥子集，满足D=，，同样地尽可能保持数据分布的一致性，即采用分层抽样的方法获得这些子集。\n交叉验证法的思想是： 每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集，这样就有K种训练集/测试集划分的情况，从而可进行k次训练和测试，最终返回k次测试结果的均值。 k最常用的取值是10。\n\n与留出法类似，将数据集D划分为k个子集的过程具有随机性，因此K折交叉验证通常也要重复p次，称为p次k折交叉验证，常见的是10次10折交叉验证，即进行了100次训练/测试。\n特殊地当划分的k个子集的每个子集中只有一个样本时，称为”留一法”，显然，留一法的评估结果比较准确，但对计算机的消耗也是巨大的。\n自助法我们希望评估的是用整个D训练出的模型。但在留出法和交叉验证法中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集比D小，这必然会引入一些因训练样本规模不同而导致的估计偏差。留一法受训练样本规模变化的影响较小，但计算复杂度又太高了。”自助法”正是解决了这样的问题。\n自助法的基本思想是： 给定包含m个样本的数据集D，每次随机从D 中挑选一个样本，将其拷贝放入D’，然后再将该样本放回初始数据集D 中，使得该样本在下次采样时仍有可能被采到。重复执行m 次，就可以得到了包含m个样本的数据集D’。 可以得知在m次采样中，样本始终不被采到的概率取极限为：\n\n这样，通过自助采样，初始样本集D中大约有36.8%的样本没有出现在D’中，于是可以将D’作为训练集，D-D’作为测试集。自助法在数据集较小，难以有效划分训练集/测试集时很有用，但由于自助法产生的数据集（随机抽样）改变了初始数据集的分布，因此引入了估计偏差。在初始数据集足够时，留出法和交叉验证法更加常用。\n调参大多数学习算法都有些参数(parameter) 需要设定，参数配置不同，学得模型的性能往往有显著差别，这就是通常所说的”参数调节”或简称”调参” (parameter tuning)。\n学习算法的很多参数是在实数范围内取值，因此，对每种参数取值都训练出模型来是不可行的。常用的做法是：对每个参数选定一个范围和步长，这样使得学习的过程变得可行。\n\n例如，假定算法有3个参数，每个参数仅考虑5个候选值，这样对每一组训练/测试集就有= 125个模型需考察，由此可见：拿下一个参数（即经验值）对于算法人员来说是有多么的happy。\n\n最后需要注意的是：当选定好模型和调参完成后，我们需要使用初始的数据集D重新训练模型，即让最初划分出来用于评估的测试集也被模型学习，增强模型的学习效果。\n\n用考试的例子来比喻：就像高中时大家每次考试完，要将考卷的题目消化掉（大多数题目都还是之前没有见过的吧？），这样即使考差了也能开心的玩耍了~。\n\n性能度量性能度量（performance measure）是衡量模型泛化能力的评价标准，在对比不同模型的能力时，使用不同的性能度量往往会导致不同的评判结果。\n在预测任务中，给定样例集D={}，其中是示例的真实标记。要评估学习器f的性能，就要把学习器预测结果f(x)与真实标记y进行比较。\n回归任务中，即预测连续值的问题，最常用的性能度量是 “均方误差”（mean squared error） ,很多的经典算法都是采用了MSE作为评价函数：\n\n更一般的，对于数据分布D和概率密度函数p(·)，均方误差可描述为：\n\n错误率与精度在分类任务中，即预测离散值的问题，最常用的是错误率和精度，错误率是分类错误的样本数占样本总数的比例，精度则是分类正确的样本数占样本总数的比例，易知：错误率+精度=1。\n错误率定义为:\nⅡ\n精度定义为：\nⅡ\n更一般的，对于数据分布D和概率密度函数p(·)，错误率与精度可分布描述为：\nⅡⅡ\n查准率、查全率与F1错误率和精度虽然常用，但不能满足所有的需求，例如：在推荐系统中，我们只关心推送给用户的内容用户是否感兴趣（即查准率），或者说所有用户感兴趣的内容我们推送出来了多少（即查全率）。因此，使用查准/查全率更适合描述这类问题。\n对于二分类问题，分类结果混淆矩阵（confusion matrix）定义如下：\n\n\n\n真实情况\n预测为正\n预测为反\n\n\n\n正例\nTP（真正例）\nFN（假反例）\n\n\n反例\nFP（假正例）\nTN（真反例）\n\n\n查准率P与查全率R定义如下:\n\n\n查准率和查全率是一对矛盾的度量。一般来说，查准率高时，查全率往往 偏低；而查全率高时，查准率往往偏低。\n\n例如，若希望将好瓜尽可能多地选出来, 则可通过增加选瓜的数量来实现，如果将所有西瓜都选上，那么所有的好瓜也必然都被选上了，但这样查准率就会较低;若希望选出的瓜中好瓜比例尽可能 高，则可只挑选最有把握的瓜，但这样就难免会漏掉不少好瓜，使得查全率较 低.通常只有在一些简单任务中，才可能使查全率和查准率都很高.\n\nP-R曲线“P-R曲线”正是描述查准/查全率变化的曲线，P-R曲线定义如下：\n根据学习器的 预测结果（一般为一个实值或概率） 对测试样本进行 排序 ，将 最可能 是”正例”的样本排在 前面 ， 最不可能 是”正例”的排在 后面 ，按此顺序从前到后，逐个将当前预测结果设定为 阈值 ，比阈值大的，也就是前面所有的样例，都预测是正例，后面所有的都是反例，每次计算出当前的P值和R值。\n\n能看到一个分类器的P-R曲线是成负相关的，从（0，1）到（1，0），从胆小谨慎，到胆大包天。\nP-R曲线如何评估若一个学习器C的P-R曲线被另一个学习器A的P-R曲线完全包住（如上图所示），则称：A的性能优于C。若A和B的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。\n但一般来说，曲线下的面积是很难进行估算的，所以衍生出了”平衡点”（Break-Event Point，简称BEP），即当P=R时的取值，平衡点的取值越高，性能更优。\nF1度量P-R指标有时会出现矛盾的情况，这样就需要综合考虑他们，最常见的方法就是F-Measure，又称F-Score。F-Measure是P和R的加权调和平均，既：\n\n特别的，当时，也就是常见的F1度量，是P和R的调和平均。当F1较高时，模型的性能越好。\n样例总数\n\nF1是基于查准率与查全率的调和平均定义的：则是加权调和平均：其中&gt;0度量了查全率对查准率的相对重要性；&gt;1时查全率有更大影响；&lt;1时查准率有更大影响。\n\nn个混淆矩阵的综合考察有时候我们会有多个二分类混淆矩阵，例如：多次训练或者在多个数据集上训练，那么估算全局性能的方法有两种，分为宏观和微观。\n\n宏观：先算出每个混淆矩阵的P值和R值，然后取得平均P值macro_P和平均R值macro_R，在算出Fβ或F1\n\n\n\n\n\n微观：计算出混淆矩阵的平均TP、FP、TN、FN，接着进行计算P、R，进而求出Fβ或F1。\n\n\n\n\nROC与AUC学习器对测试样本的评估结果一般为一个实值或概率，设定一个阈值，大于阈值为正例，小于阈值为负例，因此这个实值的好坏直接决定了学习器的泛化性能，若将这些实值排序，则排序的好坏决定了学习器的性能高低。ROC曲线正是从这个角度出发来研究学习器的泛化性能。\nROC受试者工作特征曲线 （receiver operating characteristic curve，简称ROC曲线），又称为感受性曲线（sensitivity curve）。\nROC曲线与P-R曲线十分类似，都是按照排序的顺序逐一按照正例预测，不同的是ROC曲线以 “真正例率”（True Positive Rate，简称TPR）为横轴，纵轴为 “假正例率”（False Positive Rate，简称FPR），ROC曲线偏重研究基于测试样本评估值的排序好坏。\n\n\n\n\nFPR的值等于1-特异性。特异性（Specificity）是指在所有实际为负例的样本中，模型正确地预测为负例的样本比例，其衡量的是模型对负例样本的判断能力。\n\n\n简单分析图像，可以得知（0,0）表示将所有的样本预测为负例，（1,1）则表示将所有的样本预测为正例，（0,1）对应正例全部出现在负例之前的理想模型，（1,0）则表示负例全部出现在正例之前的最差模型，对角线对应于”随即猜测”模型。\n\nROC曲线是正相关的，纵轴为真正例率，横轴为假正例率，从（0，0）到（1，1），从小兵到将军，到达人生巅峰。\n\n现实中的任务通常都是有限个测试样本，因此难以绘制出光滑的ROC曲线，只能绘制出近似ROC曲线。绘制方法：首先根据测试样本的评估值对测试样本排序，接着按照以下规则进行绘制。\n\n第一步是按照属于’正样本’的概率将所有样本排序，如下图所示:\n\n第二步，让我们依次来看每个样本。对于样本1，如果我们将他的score值做阈值，也就是说，只有score大于等于0.9时，我们才把样本归类到真阳性（true positive），这么一来， 在ROC曲线图中，样本1对应的混淆矩阵（confusion matrix）为:\n\n其中，只有样本1我们看作是正确分类了（也就是我们预测是正样本，实际也是正样本）；其余还有9个实际是正样本，而我们预测是负样本的（2，4，5，6，9，11，13，17，19）；剩下的实际是负样本，我们都预测出是负样本了（也就是false positive = 0， true negative = 10）。\n\n同理我们来看样本3，它的混淆矩阵为:\n\n其中，样本1，2我们看作是正确分类了（也就是我们预测是正样本，实际也是正样本）;其余还有8个实际是正样本，而我们预测是负样本的（2，4，5，6，9，11，13，17，19）;而样本3是假阳性（我们预测是正样本，实际是负样本）;剩下的（7，8，10，12，14，15，16，18，20）实际是负样本，我们都预测出是负样本了（也就是false positive = 1，true negative = 9）。\n从样本3的混淆矩阵中，我们可以算出X轴坐标（false positive rate）= 1/(1+9)= 0.1 和Y轴坐标（true positive rate）= 2/(2+8)= 0.2，这就是下图中的第三个点。\n依次把20个样本的混淆矩阵列出来，再算出X轴坐标（false positive rate） 和Y轴坐标（true positive rate），就可以得到ROC曲线啦～\n\nAUC进行模型的性能比较时，若一个学习器A的ROC曲线被另一个学习器B的ROC曲线完全包住，则称B的性能优于A。\n若A和B的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。\nROC曲线下的面积定义为AUC（Area Uder ROC Curve），不同于P-R的是，这里的AUC是可估算的，即AOC曲线下每一个小矩形的面积之和。易知：AUC越大，证明排序的质量越好，AUC为1时，证明所有正例排在了负例的前面，AUC为0时，所有的负例排在了正例的前面。\n假设ROC曲线是由坐标为{}的点按顺序连接而成，则AUG定义为：\n\nAUC考虑的是样本预测的排序质量，因此它与排序误差有紧密联系.给定个正例和个反例，令和分别表示正、反例集合，则排序”损失”(loss)定义为：\nⅡⅡ\n对应的是ROC曲线之上的面积，于是便有：\n\n代价敏感错误率与代价曲线代价敏感错误率通俗来讲就针对错误来赋予其代价。\n\n例如：将无疾病–&gt;有疾病只是增多了检查，但有疾病–&gt;无疾病却是增加了生命危险.\n\n以二分类为例，由此引入了 “代价矩阵”（cost matrix） 。\n\n\n通常来说重要的是比值而非绝对值。\n\n在非均等错误代价下，我们希望的是最小化”总体代价”，这样”代价敏感”的错误率:\nⅡⅡ\n代价曲线同样对于ROC曲线，在非均等错误代价下，演变成了”代价曲线”，代价曲线横轴是取值在[0,1]之间的正例概率代价，式中p表示正例的概率，纵轴是取值为[0,1]的归一化代价。\n\n\n代价曲线的绘制很简单，如图所示：\n\n\n\n设ROC曲线上一点的坐标为(TPR，FPR) ，则可相应计算出FNR=1-TPR，然后在代价平面上绘制一条从(0，FPR) 到(1，FNR) 的线段，线段下的面积即表示了该条件下的期望总体代价；如此将ROC 曲线土的每个点转化为代价平面上的一条线段，然后取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价\n\nCreate By Asuka24601\n\n\n\n你可以在这里:[https://asuka24601.github.io/2023/12/19/西瓜书学习笔记-2/]找到这篇文章，如有问题，请通过邮件联系。","categories":["机器学习"],"tags":["机器学习","算法","读书笔记"]},{"title":"依赖注入(DI)和控制反转(IOC)","url":"/2023/02/17/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-DI-%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-IOC/","content":"在软件工程领域，理解依赖注入（DI）与控制反转（IOC）不仅是提高编程效率的关键，也是实现高质量代码设计的基石。\n\n\n理论基础首先，控制反转（IOC）是一种设计原则，用于减少计算机代码之间的耦合。在传统的程序设计中，高级模块依赖于低级模块的实现细节，这种直接的依赖关系使得代码难以维护和扩展。控制反转的核心思想是通过抽象化来降低模块间的直接依赖，从而实现模块间的松耦合。在控制反转的模式下，不是由高级模块主动创建或查找所需的低级模块，而是将这一职责交给外部的容器或框架，由它来负责创建并维护对象之间的关系。\n依赖注入（DI）是实现控制反转的一种技术手段。通过依赖注入，对象的依赖关系不再在对象内部静态地创建，而是在对象被创建的时候，由外部动态地注入。这种方式有三种基本形式：构造函数注入、属性注入和方法注入。构造函数注入是指通过构造函数传递依赖对象，属性注入则是通过公开的属性来接收依赖对象，而方法注入是通过调用方法的方式来传递依赖对象。无论采用哪种形式，依赖注入的目的都是将对象的创建和对象间的依赖关系的管理从业务逻辑中解耦出来，交给外部容器处理。\n说明例如：现有类 A 依赖于类 B\n\n传统的开发方式 ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来\n使用 IoC 思想的开发方式 ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面过去即可。\n\n从以上两种开发方式的对比来看：我们 “丧失了一个权力” (创建、管理对象的权力)，从而也得到了一个好处（不用再考虑对象的创建、管理等一系列的事情）。\n为什么叫控制反转?控制：指的是对象创建（实例化、管理）的权力。反转：控制权交给外部环境（Spring 框架、IoC 容器）。\n\nIoC解决了什么问题?IoC的思想就是两方之间不互相依赖，由第三方容器来管理相关资源。\n这样有什么好处呢？对象之间的耦合度或者说依赖程度降低；资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。例如：现有一个针对 User 的操作，利用 Service 和 Dao 两层结构进行开发在没有使用 IoC 思想的情况下，Service 层想要使用 Dao 层的具体实现的话，需要通过 new 关键字在UserServiceImpl 中手动 new 出 IUserDao 的具体实现类 UserDaoImpl（不能直接 new 接口类）。\n\n很完美，这种方式也是可以实现的，但是我们想象一下如下场景：开发过程中突然接到一个新的需求，针对对IUserDao 接口开发出另一个具体实现类。因为 Server 层依赖了IUserDao的具体实现，所以我们需要修改UserServiceImpl中 new 的对象。如果只有一个类引用了IUserDao的具体实现，可能觉得还好，修改起来也不是很费力气，但是如果有许许多多的地方都引用了IUserDao的具体实现的话，一旦需要更换IUserDao 的实现方式，那修改起来将会非常的头疼。\n\n使用 IoC 的思想，我们将对象的控制权（创建、管理）交有 IoC 容器去管理，我们在使用的时候直接向 IoC 容器 “要” 就可以了。\n\n结论依赖注入和控制反转的好处是显而易见的。首先，它们能够显著提高代码的可测试性。由于依赖关系是外部注入的，因此在单元测试时可以很容易地用模拟对象（Mock Object）替换真实的依赖，这样就可以在隔离环境中测试代码的功能。其次，它们促进了代码的重用。由于依赖关系不再硬编码在组件内部，因此同一个组件可以在不同的环境中被重用，只需改变依赖对象的配置即可。最后，它们提高了代码的可维护性。当系统需要升级或替换组件时，由于组件之间的耦合度降低，改动的影响范围也随之减小。\n在SpringBoot中的应用在当今的软件开发实践中，Spring Boot作为一种轻量级的开源框架，已经广泛被用于创建高效、易维护的Java应用程序。Spring Boot的核心特性之一就是依赖注入（DI）和控制反转（IOC），这两个概念是Spring框架的基石，对于理解和有效使用Spring Boot至关重要。\n控制反转（IOC）在没有IOC的情况下，对象通常自行创建和管理它们所依赖的对象。这种方式导致了高度耦合和难以测试的代码。IOC的核心思想是将对象的创建和管理工作交给外部容器（在Spring框架中，这个容器通常是ApplicationContext），从而实现解耦。\n依赖注入（DI）通过DI，对象的依赖不再由对象本身在内部创建，而是在创建对象的时候由外部注入。这样做的好处是减少了组件之间的耦合，增加了代码的模块化，使得单元测试更加容易。\nDI的实现方式在Spring Boot中，DI可以通过以下几种方式实现：\n\n构造器注入：通过对象的构造器来注入依赖。\nSetter注入：通过对象的Setter方法来注入依赖。\n字段注入：直接在字段上使用@Autowired注解来注入依赖。\n\n代码示例为了更好地理解这些概念，让我们通过一些简单的代码示例来看看它们是如何在实践中应用的。\n构造器注入@Componentpublic class UserService &#123;    private final UserRepository userRepository;    @Autowired    public UserService(UserRepository userRepository) &#123;        this.userRepository = userRepository;    &#125;&#125;\n\n在上述代码中，UserService依赖于UserRepository。通过将UserRepository作为构造器的参数，Spring容器在创建UserService实例时自动注入UserRepository的实例。\nSetter注入@Componentpublic class UserService &#123;    private UserRepository userRepository;    @Autowired    public void setUserRepository(UserRepository userRepository) &#123;        this.userRepository = userRepository;    &#125;&#125;\n\n与构造器注入类似，但是这里依赖是通过Setter方法注入的。Spring容器会在创建UserService实例后调用setUserRepository方法来注入UserRepository的实例。\n字段注入@Componentpublic class UserService &#123;    @Autowired    private UserRepository userRepository;&#125;\n\n字段注入是最简单的注入方式，只需在字段上添加@Autowired注解即可。Spring容器会自动寻找匹配的类型并注入相应的实例。\n结论通过上述讨论和代码示例，我们可以看到，依赖注入和控制反转在Spring Boot中是如何帮助我们实现低耦合、高内聚的设计的。通过将对象的创建和管理责任交给Spring容器，我们的应用程序变得更加模块化，易于测试和维护。\n总结IoC 和 DI 别再傻傻分不清楚。IoC是一种设计思想，或者说是某种模式，这个设计思想就是 将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。 IoC 在其他语言中也有应用，并非 Spring 特有。IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。并且，Martin Fowler 在一篇文章中提到将 IoC 改名为 DI，原文如下，原文地址：https://martinfowler.com/articles/injection.html。\n\nMartin 的大概意思是 IoC 太普遍并且不表意，很多人会因此而迷惑，所以，使用 DI 来精确指名这个模式比较好。\nCreate By Asuka24601\n\n\n\n你可以在这里:[https://asuka24601.github.io/2023/02/17/依赖注入-DI-和控制反转-IOC/]找到这篇文章，如有问题，请通过邮件联系。","categories":["技术"],"tags":["技术","java","springboot"]},{"title":"为什么chrom采取多进程方式？","url":"/2024/02/20/%E4%B8%BA%E4%BB%80%E4%B9%88chrom%E9%87%87%E5%8F%96%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%96%B9%E5%BC%8F%EF%BC%9F/","content":"简单点说： chrome是一个用内存换速度和安全性的浏览器 。\n\n\n传统的浏览器被设计为显示网页，而Chrome的设计目标是支撑”Web App”（当时的js和相关技术已经相当发达了，Gmail等服务也很成功）。这就要求Chrome提供一个类似于”操作系统”感觉的架构，支持App的运行。而App会变得相当的复杂，这就难以避免出现bug，然后crash。同时浏览器也要面临可能运行”恶意代码”。流览器不能决定上面的js怎么写，会不会以某种形式有意无意的攻击浏览器的渲染引擎。如果将所有这些App和浏览器实现在一个进程里，一旦挂，就全挂。\n因此Chrome一开始就设计为把隔离性作为基本的设计原则，用进程的隔离性来实现对App的隔离。这样用户就不用担心：一个Web App挂掉造成其他所有的Web App全部挂掉（稳定性）一个Web App可以以某种形式访问其他App的数据（安全性）以及Web App之间是并发的，可以提供更好的响应，一个App的渲染卡顿不会影响其他App的渲染（性能）（当然这点线程也能做到），因此，这样看起来用进程实现非常自然。\n\n我们再来看看Chrome的多进程体系架构的优势：\n\n每打开一个新网页，Chrome都会开启一个新的Tab，每个插件都会对应启动一个新进程，这样即便某个网页卡死也不影响其他网页的正常显示。\n早期的webkit内核有不少内存泄漏，采用多进程架构，一个进程结束内存全部回收，不用考虑内存泄漏的问题。\n多进程架构相比多线程架构的安全性高的不是一星半点。\n\n\n反观早期的firefox之类的浏览器就经常整体卡死或者崩掉，另外firebox在2017年之后也改用多进程架构了。在插件的实现中，html和js的规则是非常松散的，不管浏览器考虑的边界条件多完备，总是有各种奇怪的东西需要解析和兼容，随便一个小错误就会导致卡死或者崩溃。\n\nCreate By Asuka24601\n\n\n\n\n你可以在这里:[https://asuka24601.github.io/2024/02/20/为什么chrom采取多进程方式？/]找到这篇文章，如有问题，请通过邮件联系。","categories":["知识"],"tags":["技术","知识"]},{"title":"redis持久化的三种方式","url":"/2024/02/19/redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/","content":"Redis 是基于内存的数据库，而内存又是易失性的，一旦遇到断电或异常重启等问题时，内存中的数据就会丢失。所以 Redis 为了保证数据的可靠性花了不少功夫。\n\n\nRedis 主要是通过 AOF 日志和 RDB 快照来实现持久化的。\nRedis 共有三种数据持久化的方式：\n\nAOF 日志 ：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；\nRDB 快照 ：将某一时刻的内存数据，以二进制的方式写入磁盘；\n混合持久化 ：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；\n\nAOF (Append Only File)Redis 的 AOF 是一种为了数据持久化而设计的日志系统。AOF 持久化会记录每个写操作命令到一个日志文件中，这些命令会在 Redis 重启时被重新执行来重建整个数据集。AOF 持久化提供了一种更加可靠的方式来确保数据不会因为故障而丢失。\nAOF 持久化的工作原理\n记录命令 ：每当 Redis 执行一个写命令（比如 SET, HSET 等），这个命令会被追加到 AOF 文件的末尾。这确保了所有对数据的更改都会被记录下来。\n\n文件同步策略 ：Redis 提供了几种不同的文件同步策略，让你可以在性能和数据安全性之间做出权衡。这些策略包括：\n\nalways ：每次写操作后都会同步文件，这提供了最高的数据安全性，但可能会因为磁盘 I&#x2F;O 的频繁操作而导致性能问题。\neverysec （默认）：每秒同步一次文件。这提供了一个平衡的选择，既保证了较好的数据安全性，又避免了过多的性能损失。\nno ：不主动同步文件，只依赖操作系统的缓存策略和周期。这种策略提供了最高的性能，但在系统崩溃的情况下可能会丢失最近一秒钟的数据。\n\n\n文件重写 ：随着时间的推移，AOF 文件可能会变得非常大，因为它记录了所有的写操作。Redis 提供了 AOF 重写的功能，这个过程会创建一个新的 AOF 文件，其中只包含达到当前数据集状态所需的最小命令集。这有助于减少磁盘空间的占用并提高 Redis 启动时的恢复速度。\n\n恢复数据 ：当 Redis 重启时，它会读取 AOF 文件中的所有命令并重新执行它们，以此来重建整个数据集。这个过程可能需要一些时间，取决于 AOF 文件的大小。\n\n\n使用 AOF 持久化的优点包括：\n\n数据安全性 ：通过记录每个写操作，AOF 提供了很高的数据安全性。\n灵活性 ：提供了不同的文件同步策略，让用户可以根据自己的需求选择最合适的设置。\n可读性 ：AOF 文件是纯文本格式的，可以很容易地进行查看和编辑。\n\n但是存在两个风险：\n\n执行写操作命令和记录日志是两个过程，如果 Redis 还没来得及将命令写入到硬盘，服务器发生宕机，这个数据就会有 丢失的风险 。\n由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是 可能会给下一个命令带来阻塞风险 。\n\n然而，使用 AOF 也有一些潜在的缺点，比如可能会对性能产生影响（尤其是在 always 同步模式下），并且在数据集很大时，AOF 文件的重写可能需要较长时间。因此，在使用 AOF 时，合理配置和定期监控是很重要的。\nRDB (Redis Database)Redis Database，即快照&#x2F;内存快照，RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据（二进制数据，使用 LZF 算法进行压缩），因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。\nRDB持久化通过创建数据集的快照来实现，在指定的时间间隔内执行快照操作，将Redis的某一时刻的数据状态保存到磁盘上的一个文件中（通常是dump.rdb文件）。\nRDB的工作原理\n触发时机 ：RDB持久化可以通过两种方式触发：\n\n根据配置文件中的规则自动触发。例如，可以设定”在900秒内至少有1个键被修改”或”在300秒内至少有10个键被修改”等规则。\n# 在配置文件中使用如&quot;save m n&quot;，表示m秒内数据修改n次,自动触发bgsave。save 900 1save 300 10save 60 10000\n\n手动触发，通过执行SAVE或BGSAVE命令。SAVE命令会阻塞当前Redis服务器直到RDB文件创建完毕，而BGSAVE命令会在后台异步创建RDB文件，这样就不会阻塞主服务器。\n\n\n创建快照 ：当RDB持久化被触发时，Redis会创建一个数据集的快照。如果是BGSAVE命令，Redis会fork一个子进程来创建这个快照，父进程则可以继续处理客户端的请求。\n\n写入磁盘 ：快照数据会被写入到一个临时RDB文件中。写入过程中，会使用一种高效的压缩算法来减少磁盘空间的占用。一旦整个数据集被成功写入临时文件，这个临时文件会替换掉之前的RDB文件。\n\n\nRDB的优点包括：\n\n快速重启 ：使用RDB恢复数据比使用AOF（Append Only File，另一种Redis持久化机制）的方式要快得多。\n数据压缩 ：RDB文件是压缩的，占用磁盘空间较小。简单性：RDB是一个非常简单的持久化方式，只需要一个文件就能完成数据的恢复。\n\n然而，RDB也有一些缺点：\n\n数据丢失风险：如果Redis崩溃，自上次快照以来的所有修改都会丢失。\n在大数据集上保存快照可能会导致延迟：尽管使用BGSAVE可以减少这种影响，但在快照过程中仍然可能会出现短暂的延迟。\n主线程修改数据需要复制物理内存，如果所有的共享内存都被修改，则此时的内存占用是原先的两倍。\n\n总的来说，RDB提供了一种快速、高效的方式来恢复Redis数据，但在对数据丢失的容忍度较低的应用中，可能需要与AOF等其他持久化机制结合使用。\n混合持久化Redis 4.0 开始支持混合使用 AOF 日志和内存快照，也叫混合持久化。简单来说就是，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。\n当开启了混合持久化时，在 AOF 重写日志时，重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。\n也就是说，使用了混合持久化，AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。\n这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样加载的时候速度会很快。\nCreate By Asuka24601\n\n\n\n\n\n\n你可以在这里:[https://asuka24601.github.io/2024/02/19/redis持久化的三种方式/]找到这篇文章，如有问题，请通过邮件联系。","categories":["技术"],"tags":["技术","java","知识"]}]