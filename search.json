[{"title":"LaTexSymbols","url":"/2023/11/05/LaTexSymbols/","content":" \n\n\n\n简单的收集了一些Latex数学符号的写法，方便需要时查找。\n操作符\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\pm\n\n\\mp\n\n\\times\n\n\n\n\\div\n\n\\cdot\n\n\\ast\n\n\n\n\\star\n\n\\dagger\n\n\\ddagger\n\n\n\n\\amalg\n\n\\cap\n\n\\cup\n\n\n\n\\uplus\n\n\\sqcap\n\n\\sqcup\n\n\n\n\\vee\n\n\\wedge\n\n\\oplus\n\n\n\n\\ominus\n\n\\otimes\n\n\\circ\n\n\n\n\\bullet\n\n\\diamond\n\n\\lhd\n\n\n\n\\rhd\n\n\\unlhd\n\n\\unrhd\n\n\n\n\\oslash\n\n\\odot\n\n\\bigcirc\n\n\n\n\\triangleleft\n\n\\Diamond\n\n\\bigtriangleup\n\n\n\n\\bigtriangledown\n\n\\Box\n\n\\triangleright\n\n\n\n\\setminu\n\n\\wr\n\n\\sqrt{x}\n\n\n\nx^{\\circ}\n\n\\triangledown\n\n\\sqrt[n]{x}\n\n\n\na^x\n\na^{xyz}\n\n\n\n\n关系符\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\le\n\n\\ge\n\n\\ne\n\n\n\n\\sim\n\n\\ll\n\n\\gg\n\n\n\n\\doteq\n\n\\simeq\n\n\\subset\n\n\n\n\\supset\n\n\\approx\n\n\\asymp\n\n\n\n\\subseteq\n\n\\supseteq\n\n\\cong\n\n\n\n\\smile\n\n\\sqsubset\n\n\\sqsupset\n\n\n\n\\equiv\n\n\\frown\n\n\\sqsubseteq\n\n\n\n\\sqsupseteq\n\n\\propto\n\n\\bowtie\n\n\n\n\\in\n\n\\ni\n\n\\prec\n\n\n\n\\succ\n\n\\vdash\n\n\\dashv\n\n\n\n\\preceq\n\n\\succeq\n\n\\models\n\n\n\n\\perp\n\n\\parallel\n\n\n\n\n\n\\mid\n\n\\bumpeq\n\n\n\n\n只要将not放在符号前面或者在 \\ 和单词之间插入一个 n ，就可以形成许多这些关系的否定形式，这里有一些例子，加上一些其他的否定，它也适用于许多其他的。\n\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\nmid\n\n\\nleq\n\n\\ngeq\n\n\n\n\\nsim\n\n\\ncong\n\n\\nparallel\n\n\n\n\\not&lt;\n\n\\not&gt;\n\n\\not= or \\neq\n\n\n\n\\not\\le\n\n\\not\\ge\n\n\\not\\sim\n\n\n\n\\not\\approx\n\n\\not\\cong\n\n\\not\\equiv\n\n\n\n\\not\\paralle\n\n\\nless\n\n\\ngtr\n\n\n\n\\lneq\n\n\\gneq\n\n\\lnsim\n\n\n\n\\lneqq\n\n\\gneqq\n\n\n\n\n希腊字母小写\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\alpha\n\n\\beta\n\n\\gamma\n\n\\delta\n\n\n\n\\epsilon\n\n\\varepsilon\n\n\\zeta\n\n\\eta\n\n\n\n\\theta\n\n\\vartheta\n\n\\iota\n\n\\kappa\n\n\n\n\\lambda\n\n\\mu\n\n\\nu\n\n\\xi\n\n\n\n\\pi\n\n\\varpi\n\n\\rho\n\n\\varrho\n\n\n\n\\sigma\n\n\\varsigma\n\n\\tau\n\n\\upsilon\n\n\n\n\\phi\n\n\\varphi\n\n\\chi\n\n\\psi\n\n\n\n\\omega\n\n\n\n\n\n\n\n\n大写\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\Gamma\n\n\\Delta\n\n\\Theta\n\n\\Lambda\n\n\n\n\\Xi\n\n\\Pi\n\n\\Sigma\n\n\\Upsilon\n\n\n\n\\Phi\n\n\\Psi\n\n\\Omega\n\n\\nabla\n\n\n加粗在公式中的字母加粗：\n\n\n\nSymbol\nCommand\n\n\n\n\n\\boldsymbol{m}\n\n\n空心字母\n\n\nSymbol\nCommand\n\n\n\n\n\\mathbb{M}\n\n\n\n\\mathbb{R}\n\n\n箭头\n\n\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\gets\n\n\\to\n\n\n\n\\leftarrow\n\n\\Leftarrow\n\n\n\n\\rightarrow\n\n\\Rightarrow\n\n\n\n\\leftrightarrow\n\n\\Leftrightarrow\n\n\n\n\\mapsto\n\n\\hookleftarrow\n\n\n\n\\leftharpoonup\n\n\\leftharpoondown\n\n\n\n\\rightleftharpoons\n\n\\longleftarrow\n\n\n\n\\Longleftarrow\n\n\\longrightarrow\n\n\n\n\\Longrightarrow\n\n\\longleftrightarrow\n\n\n\n\\Longleftrightarrow\n\n\\longmapsto\n\n\n\n\\hookrightarrow\n\n\\rightharpoonup\n\n\n\n\\rightharpoondown\n\n\\leadsto\n\n\n\n\\uparrow\n\n\\Uparrow\n\n\n\n\\downarrow\n\n\\Downarrow\n\n\n\n\\updownarrow\n\n\\Updownarrow\n\n\n\n\\nearrow\n\n\\searrow\n\n\n\n\\swarrow\n\n\\nwarrow\n\n\n(对于不喜欢键入长串字母的人，\\iff和\\implies可以分别替代\\Longleftrightarrow和\\ longrighttarrow)\n点\n\n\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\cdot\n\n\\vdots\n\n\n\n\\dots\n\n\\ddots\n\n\n上标\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\hat{x\n\n\\check{x}\n\n\\dot{x}\n\n\n\n\\breve{x}\n\n\\acute{x}\n\n\\ddot{x}\n\n\n\n\\grave{x}\n\n\\tilde{x}\n\n\\mathring{x}\n\n\n\n\\bar{x}\n\n\\vec{x}\n\n\n\n\n当对i和j应用上标时，可以使用\\imath和\\jmath来防止点干扰上标:\n\n\n\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n​\n\\vec{\\jmath}\n\n\\tilde{\\imath}\n\n\n\\tilde和\\hat有很宽的版本，可以让你强调一个表达:\n\n\n\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n​\n\\widehat{7+x}\n\n\\widetilde{abc}\n\n\n其他\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\infty\n\n\\triangle\n\n\\angle\n\n\n\n\\aleph\n\n\\hbar\n\n\\imath\n\n\n\n\\jmath\n\n\\ell\n\n\\wp\n\n\n\n\\Re\n\n\\Im\n\n\\mho\n\n\n\n\\prime\n\n\\emptyset\n\n\\nabla\n\n\n\n\\surd\n\n\\partial\n\n\\top\n\n\n\n\\bot\n\n\\vdash\n\n\\dashv\n\n\n\n\\forall\n\n\\exists\n\n\\neg\n\n\n\n\\flat\n\n\\natural\n\n\\sharp\n\n\n\n\\backslash\n\n\\Box\n\n\\Diamond\n\n\n\n\\clubsuit\n\n\\diamondsuit\n\n\\heartsuit\n\n\n\n\\spadesuit\n\n\\Join\n\n\\blacksquare\n\n\n\n\\checkmark\n\n\\mathbb{R}\n©\n\\copyright\n\n\n£\n\\pounds\n\n\\square\n\n\\cup\n\n\n\n\\bigstar\n\n\\in\n\n\n\n\n命令符有些符号用于命令中，因此需要以特殊的方式处理它们。\n\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\backslash\nMisplaced &&amp;\n\\&amp;\n\n\\%\nYou can't use 'macro parameter character #' in math mode#\n\\#\n\n\nMissing superscript or subscript argument_\n\\_\n${$\n\\{\nExtra close brace or missing open brace}\n\\}\n\n\n\n\n您可能会注意到，如果使用其中任何一个来排版垂直较大的表达式，比如得到的表达式的括号的大小不对\n跨行或跨列的符号:\n\n\nsymbol\ncommand\n\n\n\n\nf(x) = \n\n\n\n\\left\\lceil\\frac{x}{y}\\right\\rceil\n\n\n\n\\left\\lfloor\\frac{x}{y}\\right\\rfloor\n\n\n\n\\underbrace{a_0+a_1+a_2+\\cdots+a_n}_{x}\n\n\n\n​\\overbrace{a_0+a_1+a_2+\\cdots+a_n}^{x}\n\n\n\n\\arg \\underset{1\\leq k \\leq n} {max} \\frac{\\lambda_k}{\\lambda_{k+1}}\n\n\n\\left和\\right也可以用来调整下列符号的大小:\n\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\uparrow\n\n\\downarrow\n\n\\updownarrow\n\n\n\n\\Uparrow\n\n\\Downarrow\n\n\\Updownarrow\n\n\n\n\n\nSymbol\nCommand\nSymbol\nCommand\nSymbol\nCommand\n\n\n\n\n\\sum\n\n\\int\n\n\\oint\n\n\n\n\\prod\n\n\\coprod\n\n\\bigcap\n\n\n\n\\bigcup\n\n\\bigsqcup\n\n\\bigvee\n\n\n\n\\bigwedge\n\n\\bigodot\n\n\\bigotimes\n\n\n\n\\bigoplus\n\n\\biguplus\n\n\n\n\nCreate By Asuka24601","categories":["数学"],"tags":["latex","数学"]},{"title":"理解CSS","url":"/2022/07/25/%E7%90%86%E8%A7%A3CSS/","content":"来源本文于字节跳动青训营期间创作。\nCSS 是什么？CSS (Cascading Style Sheets) 又称层叠样式表，主要与HTML一同使用，被用来定义页面元素的样式，是用来控制网页外观的一门技术。它可以为HTML页面设置字体和颜色、添加位置和大小、添加动画效果等。\nCSS 的工作流程\nCSS 的使用在页面中使用css的方式有三种。\n外链式&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/style.css&gt;\n\n嵌入式&lt;style&gt;   div&#123;     width:100px;     height:100px;     border:3px soild red;   &#125;&lt;/style&gt;\n\n内联式&lt;div style=&quot;width:100px; height:100px; border:3px soild red;&quot;&gt;&lt;/div&gt;\n\n选择器与属性选择器 (Selector) 会找到并选择页面中的元素，以便给它们设置样式。\n选择器可以使用多种方式选择元素：\n\n按照标签名、类名或id\n按照属性\n按照 DOM 树中的位置\n\n选择器有多种类型：\n通配选择器在 CSS 中，一个星号 (*) 就是一个通配选择器。它可以匹配任意类型的 HTML 元素。在配合其他简单选择器的时候，省略掉通配选择器会有同样的效果。比如，*.warning 和.warning 的效果完全相同。\n*.warning &#123;color:red;&#125;*#maincontent &#123;border: 1px solid blue;&#125;\n\n标签选择器标签选择器主要针对的是页面中某个标签中的样式设置，它的作用范围是这个页面内所有写在该标签内的内容，标签选择器可以定义多个标签的样式\np &#123;color: red;&#125;\n\n类选择器类选择器在定义的时候需要 “.” 来做前缀，类名是自定义的，然后在括号内定义属性和属性值。它不是直接作用在该页面中，而是需要使用class方法去自定义要作用的标签\n.MyClass &#123;\tcolor: red;&#125;\n\n定义完类选择器的样式之后，使用class方法去设置要调用改样式的标签。使用class方法调用类选择器中的样式的时候，直接接类名即可，不需要输入”.”。\n&lt;p class=&quot;MyClass&quot;&gt;Hello&lt;/p&gt;\n\n类选择器可以在页面中的多个标签内重复使用，也可以中定义多个类选择器。\nid选择器ID选择器使用”#”作前缀，标识名照样是自定义的。然后括号内输入要修改样式的属性和属性值。\n#MyId &#123;\tcolor: blue;&#125;\n\n内定义好ID选择器之后，在需要使用该样式的标签内使用ID方法即可。\n&lt;p id=&quot;MyId&quot;&gt;Hello&lt;/p&gt;\n\nID&#x3D;”标识名” 需要注意的是ID选择器可以创建多个，但一个id选择器中的样式只能在页面中的一个标签内使用一次。\n属性选择器类选择器 和 ID 选择器都属于 属性选择器。 应为本质上 类选择器 是 匹配 HTML 中 class 的属性值， ID 选择器 是 匹配 HTML 中的 Id 属性值。\n但此处说的属性选择器则是可以根据元素的属性及属性值来选择元素，与类选择器、ID选择器略有不同。\n属性值 直接匹配 选择器包括下面4 种：\n简单属性选择如果希望选择有某个属性的元素，而不论属性值是什么，可以使用简单属性选择器。\n/*把包含标题（title）的所有元素变为红色*/*[title] &#123;color:red;&#125;/*对有 href 属性的锚（a 元素）应用样式*/a[href] &#123;color:red;&#125;/*将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色*/a[href][title] &#123;color:red;&#125;\n\n根据具体属性值选择除了选择拥有某些属性的元素，还可以进一步缩小选择范围，只选择有特定属性值的元素。\n/*将指向 Web 服务器上某个指定文档的超链接变成红色*/a[href=&quot;http://www.juejin.cn/about.html&quot;] &#123;color: red;&#125;/*与简单属性选择器类似，可以把多个属性-值选择器链接在一起来选择一个文档*/a[href=&quot;http://www.juejin.cn/&quot;][title=&quot;juejin&quot;] &#123;color: red;&#125;\n\n请注意，这种格式要求必须与属性值完全匹配。\n如果属性值包含用空格分隔的值列表，匹配就可能出问题。\n&lt;p class=&quot;important warning&quot;&gt;This paragraph is a very important warning.&lt;/p&gt;&lt;style&gt;\tp[class=&quot;important warning&quot;] &#123;color: red;&#125;&lt;/style&gt;\n\n根据部分属性值选择如果需要根据属性值中的词列表的某个词进行选择，则需要使用波浪号（~），它能用于任何属性。\n/*选择 class 属性中包含 important 的元素*/p[class~=&quot;important&quot;] &#123;color: red;&#125;/*这个规则会选择 title 文本包含 &quot;Figure&quot; 的所有图像。没有 title 属性或者 title 属性中不包含 &quot;Figure&quot; 的图像都不会匹配。*/img[title~=&quot;Figure&quot;] &#123;border: 1px solid gray;&#125;\n\n如果忽略了波浪号，则说明需要完成完全值匹配。\n特定属性选择类型该类型需要使用竖杠（|）。\n/*这个规则会选择 lang 属性等于 en 或以 en- 开头的所有元素*/*[lang|=&quot;en&quot;] &#123;color: red;&#125;\n\n根据以上规则，以下示例标记中的前三个元素将被选中，而不会选择后两个元素：\n/*会被选中*/&lt;p lang=&quot;en&quot;&gt;Hello!&lt;/p&gt;&lt;p lang=&quot;en-us&quot;&gt;Greetings!&lt;/p&gt;&lt;p lang=&quot;en-au&quot;&gt;G&#x27;day!&lt;/p&gt;/*不会被选中*/&lt;p lang=&quot;fr&quot;&gt;Bonjour!&lt;/p&gt;&lt;p lang=&quot;cy-en&quot;&gt;Jrooana!&lt;/p&gt;\n\n组合选择器组合选择器可以让多个选择器公用同一个CSS样式代码。\n后代组合 ( )后代选择器用于选取某元素的后代元素，使用空格分隔。\n/*选取所有&lt;div&gt;元素中的&lt;p&gt;元素应用样式*/div p &#123; background-color:red; &#125;\n\n亲子组合 (&gt;)子元素选择器只能选择作为某元素直接或一级子元素的元素，使用（&gt;）连接。\n/*选择&lt;div&gt;元素中所有直接子元素&lt;p&gt;*/div&gt;p &#123; background-color:red; &#125;\n\n兄弟选择器 (~)找到指定的元素后面的所有满足条件的兄弟元素，使用（~）连接。\n/*选择&lt;p&gt;元素后的所有&lt;h3&gt;元素*/p ~ h3 &#123; color:red; &#125;\n\n相邻选择器 (+)该选择器使用（+）连接，选择紧接在另一个元素后的元素，而且二者有相同的父元素，兄弟只会影响下面的兄弟的样式，不影响上面兄弟的样式。\n/*选择与&lt;h1&gt;元素相邻的&lt;p&gt;元素*/h1 + p &#123; margin-top:50px; color:red; &#125;\n\n分组选择器 (,)分组选择器使用逗号把同组内不同对象分隔，其本质上不是一种选择器类型，而是一种选择器使用方法。当多个对象定义了相同的样式时，就可以把它们分成一组，这样能够简化代码。\n/*定义所有级别的标题和段落行高为22px*/h1,h2,h3,h4,h5,h6,p&#123;    line-height:22px;&#125;\n\n伪类选择器伪类通常用于标记一些特殊的样，用于控制一个元素在不同动作下有不同的样式。\n伪类主要有两方面的用处，一方面是标记一些特殊的状态，另外还有一类伪类是有筛选的功能。\n以下仅记录一些常用的伪类。\n状态伪类/*选取未访问过的超链接元素。如果我们注意过搜索引擎的结果的话，它里面的链接只要点过的就会变色，从而标记哪个链接是访问过的*/:link&#123;&#125;/*选取访问过的超链接元素。和第一条相反，:visited 是用来标记哪个链接是已经访问过的，防止重复点击*/:visited&#123;&#125;/*选取鼠标悬停的元素,当鼠标放在一个元素上时显示的样式*/:hover&#123;&#125;/*选取点中的元素。这个伪类的作用在刚才提到过了，当我们希望按钮有操作反馈的时候，可以用它来标记操作反馈的样式。当然这个伪类也是可以通用的，并不是只能用在按钮上*/:active&#123;&#125;/*选取获得焦点的元素。这个伪类用来标识获得焦点的元素，比如搜索框在聚焦的时候有个比较明显的边框，方便用户知道当前在可输入的状态*/:focus&#123;&#125;\n\n筛选伪类/*选取没有子元素的元素。比如选择空的 span，就可以用 span:empty 选择器来选择。这里要注意元素内有空格的话也不能算空，不会被这个伪类选中*/:empty&#123;&#125;/*选取勾选状态的 input 元素， 只对 radio 和 checkbox 生效*/:checked&#123;&#125;/*选取禁用的表单元素*/:disabled&#123;&#125;/*选取当前选择器下第一个元素*/:first-child&#123;&#125;/*和 first-child 相反，选取当前选择器下最后一个元素*/:last-child&#123;&#125;/*选取指定位置的元素。这个伪类是有参数的，参数可以支持 an+b 的形式，这里 a 和 b 都是可变的，n 从0起。使用这个伪类可以做到选择第几个，或者选择序号符合 an+b 的所有元素。比如使用 li:nth-child(2n+1)，就可以选中 li 元素中序号是2的整数倍加1的所有元素，也就是第1、3、5、7、9、2n+1个 li 元素*/:nth-child(an+b)&#123;&#125;/*这个伪类和 nth-child 相似，只不过在计数的时候，这个伪类是从后往前计数*/:nth-last-child(an+b)&#123;&#125;/*选取唯一子元素。如果一个元素的父元素只有它一个子元素，这个伪类就会生效。如果一个元素还有兄弟元素，这个伪类就不会对它生效*/:only-child&#123;&#125;/*选取唯一的某个类型的元素。如果一个元素的父元素里只有它一个当前类型的元素，这个伪类就会生效。这个伪类允许父元素里有其他元素，只要不和自己一样就可以*/:only-of-type&#123;&#125;\n\n伪元素选择器伪元素选择器是用于向某些元素设置特殊效果。伪元素选择器选中的并不是真实的 DOM 元素，所以叫伪元素选择器。常用的伪元素选择器有5个。\n/*为某个元素的第一行文字使用样式*/::first-line&#123;&#125;/*为某个元素中的文字的首字母或第一个字使用样式*/::first-letter&#123;&#125;/*在某个元素之前插入一些内容*/::before&#123;&#125;/*在某个元素之后插入一些内容*/::after&#123;&#125;/*对光标选中的元素添加样式*/::selection&#123;&#125;\n\n\n\n伪元素选择器构造的元素是虚拟的，所以不能用 JS 去操作它。 \n如果同时使用了 before 和 first-letter 两个伪类，第一个字是要从 before 里的内容开始算起的，如果 before里面的内容是一个非文本元素，那 first-letter 也会作用在这个非文本元素上，但是不一定能生效。 \nfirst-line 和 first-letter 不适用于内联元素，在内联元素中这两个选择器都会失效。 \n在 CSS3 中，规定了伪类用一个冒号（:）表示，伪元素用两个冒号表示（::）。但除了 selection，其余四个伪元素选择器已经在 CSS2 中存在且和伪类用的是一样的单冒号表示的。为了向下兼容，现在的浏览器中伪元素选择器用单冒号和双冒号都可以。在没有兼容问题的情况下，还是建议大家按着新的 CSS3 标准来开发。\n\n\n选择器的特异度选择器的特异度由选择器本身的组件确定。\n如果一个元素有两个或多个冲突的属性声明，那么有最特异度高的声明就会胜出。\n特异度表述为4个部分，如：(0, 0, 0, 0)，从左到右的权重由高到低。\n权重排行（高到低）：\n行内样式 （!important）\nID选择器 #id\nclass、属性、伪类选择器 .titleinput[type=&quot;text&quot;]:hover\n类型和伪元素选择器 div::before\n\n权重向量(0, 0, 0, 0)(行内样式，ID选择器，class&#x2F;属性&#x2F;伪类选择器&#x2F;，类型&#x2F;伪元素)\n若权重相同，则定义靠后优先。\n实例\n&lt;div id=&quot;container&quot;&gt;    &lt;ul class=&quot;menu&quot;&gt;        &lt;li id=&quot;item1&quot; class=&quot;item1&quot;&gt;item1&lt;/li&gt;        &lt;li class=&quot;item2&quot;&gt;item2&lt;/li&gt;        &lt;li class=&quot;item3&quot;&gt;item3&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;style&gt;    /* (0, 1, 3, 1) */    #container .menu li.item2 &#123;        color: #ff4757;    &#125;    /* (0, 1, 2, 1) */    #container li:nth-child(2).item2 &#123;        color: #7bed9f;    &#125;    \t/* (0, 1, 1, 1) */    #container li.item2 &#123;        color: #ffa502;    &#125;    /* (0, 0, 1, 1) */    li.item2 &#123;        color: #5352ed;    &#125;    /* (0, 0, 1, 0) */    .item2 &#123;        color: #ff6b81    &#125;&lt;/style&gt;\n\n继承无继承性的属性\ndisplay：元素布局类型\n文本属性：\nvertical-align：垂直文本对齐\ntext-decration：规定添加到文本的装饰\ntext-shadow：文本阴影效果\nwhite-space：空白符的处理\nunicode-bidi：设置文本的方向\n\n\n盒子模型的属性：\nwidth\nheight\nmargin\nborder\npadding\n\n\n背景属性：\nbackground\nbackground-color\nbackground-image\nbackground-repeat\nbackground-position\nbackground-attachment\n\n\n定位属性：\nfloat\nclear\nposition\ntop\nright\nbottom\nleft\nmin-width\nmin-height\nmax-width\nmax-height\noverflow\nclip\nz-index\n\n\n生成内容属性：\ncontent\ncounter-reset\ncounter-increment\n\n\n轮廓样式属性：\noutline-style\noutline-width\noutline-color\noutline\n\n\n页面样式属性：\nsize\npage-break-before\npage-break-after\n\n\n声音样式属性：\npause-before\npause-after\npause\ncue-before\ncue-after\ncue\nplay-during\n\n\n\n有继承性的属性\n字体系列属性：\nfont-family：字体系列\nfont-weight：字体的粗细\nfont-size：字体的大小\nfont-style：字体的风格\n\n\n文本系列属性\ntext-indent：文本缩进\ntext-align：文本水平对齐\nline-height：行高\nword-spacing：单词之间的间距\nletter-spacing：中文或者字母之间的间距\ntext-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）\ncolor：文本颜色\n\n\n元素可见性：\nvisibility：控制元素显示隐藏\n\n\n列表布局属性：\nlist-style：列表风格，包括list-style-type、list-style-image等\n\n\n光标属性：\ncursor：光标显示为何种形态\n\n\n\n布局内容主要来源：一篇全面的CSS布局学习指南(译) \n布局（layout）即确定内容的大小和位置的算法，其根据元素、容器、兄弟节点和内容等信息来计算。\ncss中的布局有多种。\n常规流布局（normal flow）在正常流中，元素盒子（boxes）会基于文档的写作模式（writing mode）一个接一个地排列。这就意味着，如果你的写作模式是水平方向的（句子是从左到右或从右到左书写），正常流会垂直地一个接一个排列页面的块级元素。\n当然，如果你是在一个垂直方向的写作模式下，句子是垂直方向书写的，所以块级元素会水平方法排列。\n\n\n根元素、浮动和绝对定位的元素会脱离常规流\n其他元素都在常规流之内（in-flow）\n常规流中的盒子，在某种 排版上下文 中参与布局\n\n浮动布局 (float)浮动布局被用来将盒子（box）置于左侧或右侧，同时让内容环绕其展示。\n如果要让一个元素进行浮动，需要为该元素设置一个值为left或right等的float属性。默认值为none。\n.item &#123; float: left &#125;/* 其他常见的float的值 */.item &#123;float: left; &#125; /*表明元素必须浮动在其所在的块容器左侧的关键字。*/.item &#123;float: right; &#125; /*表明元素必须浮动在其所在的块容器右侧的关键字。*/.item &#123;float: none; &#125; /*表明元素不进行浮动的关键字。*/.item &#123;float: inline-start; &#125; /*关键字，表明元素必须浮动在其所在块容器的开始一侧，在 `ltr` 脚本中是左侧，在 `rtl` 脚本中是右侧。*/.item &#123;float: inline-end; &#125; /*关键字，表明元素必须浮动在其所在块容器的结束一侧，在 `ltr` 脚本中是右侧，在 `rtl` 脚本中是左侧。*/\n\n清除浮动一旦你对一个元素应用了浮动，所有接下来的元素都会环绕它直到内容处于它下方且开始应用正常文档流。如果你想要避免这种情况，可以手动去清除浮动。\n当你不想要某个元素受到其之前的浮动元素影响时，为其添加clear属性即可。使用left值可以清除左浮动效果，right值为右浮动，both则会清除左右浮动。\n.clear &#123; clear: both; &#125;/*其他常见的clear的值*/.clear &#123; clear: none; &#125; /*元素不会被向下移动以清除浮动。*/.clear &#123; clear: left; &#125; /*元素被向下移动以清除左浮动。*/.clear &#123; clear: right; &#125; /*元素被向下移动以清除右浮动。*/.clear &#123; clear: both; &#125; /*元素被向下移动以清除左右浮动。*/.clear &#123; clear: inline-start; &#125; /*元素被向下移动以清除其包含块的起始侧浮动，即 ltr 时清除左浮动，rtl 时清除右浮动。*/.clear &#123; clear: inline-end; &#125; /*元素被向下移动以清除其包含块的结束侧浮动，即 ltr 时清除右浮动，rtl 时清除左浮动。*/\n\n定位 (Positioning)position 属性用于指定一个元素在文档中的定位方式。\n想要把一个元素从正常流中移除，或者改变其在正常文档流中的位置，可以使用CSS中的position属性。当处于正常文档流时，元素的position属性为static。在块级维度上元素会一个接一个排列下去，当你滚动页面时元素也会随着滚动。\n当你改变元素的position属性时，通常情况下你也会设置一些偏移量来使元素相对于参照点进行一定的移动。不同的position值会产生不同的参照点。\n静态定位（STATIC POSTIONING）该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。\n.item &#123; position: static; &#125;\n\n相对定位（RELATIVE POSTIONING）在绝对定位中，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。\n如果一个元素具有属性position: relative，那么它偏移的参照位是其原先在正常文档流中的位置。你可以使用top、left、bottom和right属性来相对其正常流位置进行移动。\n.item &#123; position: relative; bottom: 50px; &#125;\n\n\n相对定位是不脱离标准流的, 会继续在标准流中占用一份空间在相对定位中同一个方向上的定位属性只能使用一个由于相对定位是不脱离标准流的, 所以在相对定位中是区分块级元素&#x2F;行内元素&#x2F;行内块级元素由于相对定位是不脱离标准流的, 并且相对定位的元素会占用标准流中的位置, 所以当给相对定位 的元素设置margin&#x2F;padding等属性的时会影响到标准流的布局\n\n绝对定位（ABSOLUTE POSTIONING）给一个元素设置 position: absolute ，其元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。\n因此，当你为某个元素设置 position: absolute 时，首先发生的变化是该元素会定位在视口的左上角。你可以通过设置 top 、left 、bottom 和 right 偏移量属性来将元素移动到你想要的位置。\n.item &#123; position: absolute; top: 20px; right: 20px; &#125;\n\n\n绝对定位参考点：\n规律：默认情况下所有的绝对定位的元素, 无论有没有祖先元素, 都会以 body 作为参考点。\n如果一个绝对定位的元素有祖先元素, 并且祖先元素也是定位流, 那么这个绝对定位的元素就会以定位流的那个祖先元素作为参考点。\n只要是这个绝对定位元素的祖先元素都可以 。\n指的定位流是指绝对定位&#x2F;相对定位&#x2F;固定定位 。\n定位流中只有静态定位不行。\n\n\n如果一个绝对定位的元素有祖先元素, 并且祖先元素也是定位流, 而且祖先元素中有多个元素都是定位流, 那么这个绝对定位的元素会以离它最近的那个定位流的祖先元素为参考点。\n\n\n绝对定位注意点：\n绝对定位的元素是脱离标准流的 。\n绝对定位的元素是不区分块级元素&#x2F;行内元素&#x2F;行内块级元素 。\n如果一个绝对定位的元素是以 body 作为参考点, 那么其实是以网页首屏的宽度和高度作为参考点, 而不是以整个网页的宽度和高度作为参考点 。\n一个绝对定位的元素会忽略祖先元素的 padding。\n\n\n绝对定位-子绝父相：\n相对定位弊端：相对定位不会脱离标准流, 会继续在标准流中占用一份空间, 所以不利于布局界面。\n绝对定位弊端：默认情况下绝对定位的元素会以 body 作为参考点, 所以会随着浏览器的宽度高度的变化而变化。\n子绝父相：子元素用绝对定位, 父元素用相对定位。（如果不这么做，子元素就会相对 body 或浏览器定位产生不好的效果。）\n\n\n\n固定定位（FIXED POSTIONING）position: fixed 的元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform ， perspective 或 filter 属性非 none 时，容器由视口改为该祖先。\n.item &#123; position: fixed; top: 20px; left: 100px; &#125;\n\n当你想要一个固定导航栏一直停留在屏幕上时这会非常有效。\nSTICKY 定位设置 position: sticky 会让元素在页面滚动时如同在正常流中，但当其滚动到相对于视口的某个特定位置时就会固定在屏幕上，如同fixed一般。\n.item &#123; position: sticky; top: 0; &#125;\n\n弹性布局（Flex Layout）弹性盒子（Flexbox）布局是一种为一维布局而设计的布局方法。一维的意思是你希望内容是按行或者列来布局。你可以使用 display: flex 来将元素变为弹性布局。\n.container &#123; display: flex; &#125;\n\nFlex的主轴与交叉轴当使用 flex 布局时，首先想到的是两根轴线 — 主轴和交叉轴。主轴由 flex-direction 定义，另一根轴垂直于它。我们使用 flexbox 的所有属性都跟这两根轴线有关，所以有必要在一开始首先理解它。\n主轴主轴由 flex-direction 定义，可以取 4 个值（默认为 row ）：\n\nrow\nrow-reverse\ncolumn\ncolumn-reverse\n\n如果你选择了 row 或者 row-reverse，你的主轴将沿着 inline 方向延伸。\n.itme &#123; \tdisplay: flex; \tflex-direction: row; &#125;\n\n选择 column 或者 column-reverse 时，你的主轴会沿着上下方向延伸 — 也就是 block 排列的方向。\n交叉轴交叉轴垂直于主轴，所以如果你的flex-direction (主轴) 设成了 row 或者 row-reverse 的话，交叉轴的方向就是沿着列向下的。\n如果主轴方向设成了 column 或者 column-reverse，交叉轴就是水平方向。\n理解主轴和交叉轴的概念对于对齐 flexbox 里面的元素是很重要的；flexbox 的特性是沿着主轴或者交叉轴对齐之中的元素。\nflex-wrap虽然flexbox是一维模型，但可以使我们的flex项目应用到多行中。在这样做的时候，您应该把每一行看作一个新的flex容器。任何空间分布都将在该行上发生，而不影响该空间分布的其他行。\n为了实现多行效果，请为属性 flex-wrap 添加一个属性值 wrap 。现在，如果您的项目太大而无法全部显示在一行中，则会换行显示。下面的实时例子包含已给出宽度的项目，对于 flex 容器，项目的子元素总宽度大于容器最大宽度。由于 flex-wrap 的值设置为 wrap ，所以项目的子元素换行显示。若将其设置为 nowrap ，这也是初始值，它们将会缩小以适应容器，因为它们使用的是允许缩小的初始 Flexbox 值。如果项目的子元素无法缩小，使用 nowrap 会导致溢出，或者缩小程度还不够小。\n.item &#123; \tdisplay: flex; \tflex-wrap: wrap;\t/*flex-wrap: nowrap;*/&#125;\n\n一些Flex的属性这些flex的属性是用来控制弹性项在主轴上空间大小的。这三个属性是：\n\nflex-grow\nflex-shrink\nflex-basis\n\n通常可以使用它们的简写形式：flex 。第一个值代表 flex-grow ，第二个是 flex-shrink ，而第三个则是 flex-basis 。\n.item &#123; flex: 1 1 200px; &#125;\n\nflex-basis 会为弹性项设置未拉伸和压缩时的初始大小。在上面的例子中，大小是200px，因此我们会给每个项200px的空间大小。但是大多数情况下容器元素大小不会正好被分为许多200px大小的项，而是可能有一些不足或剩余空间。 flex-grow 和 flow-shrink 属性允许我们在容器大小不足或有空余时控制各个弹性项的大小。\n如果 flex-grow 的值是任意的正数，那么弹性项会被允许拉伸来占据更多的空间。因此，在上面的例子中，当各项被设为200px后，所有多余的空间会被每个弹性项平分并填满。\n如果 flex-shrink 的值为任意的正数，那么当弹性项被设置了 flex-basis 后，元素溢出容器时会进行收缩。在上面这个CSS的例子中，如果容器空间不足，每个弹性项会等比例缩放以适应容器的大小。\nflex-grow 和 flex-shrink 的值可以是任意的正数。一个具有较大 flex-grow 值的弹性项会在容器有剩余空间时拉伸更大的比例；而一个具有更大 flex-shrink 值的项则会在容器空间不足时被压缩的更多。\n大多数情况下可以用预定义的简写形式。在这个教程中你可能经常会看到这种写法，许多情况下你都可以这么使用。下面是几种预定义的值：\n\nflex: initial\nflex: auto\nflex: none\nflex: &lt;positive-number&gt;\n\nflex: initial 是把 flex 元素重置为 Flexbox 的初始值，它相当于 flex: 0 1 auto。在这里 flex-grow 的值为 0，所以 flex 元素不会超过它们 flex-basis 的尺寸。flex-shrink 的值为 1, 所以可以缩小 flex 元素来防止它们溢出。flex-basis 的值为 auto. Flex 元素尺寸可以是在主维度上设置的，也可以是根据内容自动得到的。\nflex: auto 等同于 flex: 1 1 auto；和上面的 flex:initial 基本相同，但是这种情况下，flex 元素在需要的时候既可以拉伸也可以收缩。\nflex: none 可以把 flex 元素设置为不可伸缩。它和设置为 flex: 0 0 auto 是一样的。元素既不能拉伸或者收缩，但是元素会按具有 flex-basis: auto 属性的 flexbox 进行布局。\n你在教程中常看到的 flex: 1 或者 flex: 2 等等。它相当于flex: 1 1 0。元素可以在flex-basis为 0 的基础上伸缩。\n网格布局（grid layout）内容主要来源：最强大的 CSS 布局 —— Grid 布局\nCSS网格布局（grid layout）是一种用来进行二维布局的技术。二维（two-dimesional）意味着你希望按照行和列来排布你的内容。和弹性盒子类似，网格布局也需要设置一个 display 值。你可以为容器元素设置 display: grid ，并且使用 grid-template-columns 和 grid-template-rows 属性来控制网格中的行与列。\nGrid 布局是将容器划分成了“行”和“列”，产生了一个个的网格，我们可以将网格元素放在与这些行和列相关的位置上，从而达到我们布局的目的。\n.container &#123; \tdisplay: grid; \tgrid-template-columns: 200px 200px 200px; \tgrid-template-rows: 200px 200px; &#125;\n\ngrid-template-columns 属性和 grid-template-rows 属性grid-template-columns 属性设置列宽，grid-template-rows 属性设置行高，这两个属性在 Grid 布局中尤为重要，它们的值是有多种多样的，而且它们的设置是比较相似的。\n.wrapper &#123; \tdisplay: grid; \t/* 声明了三列，宽度分别为 200px 100px 200px */ \tgrid-template-columns: 200px 100px 200px; \t/* 声明了两行，行高分别为 50px 50px */ \tgrid-template-rows: 50px 50px; \tgrid-gap: 5px; &#125;\n\n以上表示固定列宽为 200px 100px 200px，行高为 50px 50px 。\n\nrepeat() 函数repeat() 函数可以简化重复的值。该函数接受两个参数，第一个参数是重复的次数，第二个参数是所要重复的值。比如上面行高都是一样的，我们可以这么去实现，实际效果是一模一样的。\n.wrapper &#123; display: grid; grid-template-columns: 200px 100px 200px; grid-gap: 5px; /* 2行，而且行高都为 50px */ grid-template-rows: repeat(2, 50px);&#125;\n\nauto-fill 关键字auto-fill 关键字表示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格。grid-template-columns: repeat(auto-fill, 200px) 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素\n.wrapper &#123; \tdisplay: grid; \tgrid-template-columns: repeat(auto-fill, 200px); \tgrid-gap: 5px; \tgrid-auto-rows: 50px;&#125;\n\n\nfr 关键字Grid 布局还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。fr 单位代表网格容器中可用空间的一等份。grid-template-columns: 200px 1fr 2fr 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1&#x2F;3 和 2&#x2F;3。\n.wrapper &#123; \tdisplay: grid; \tgrid-template-columns: 200px 1fr 2fr; \tgrid-gap: 5px; \tgrid-auto-rows: 50px; &#125;\n\n\nminmax() 函数minmax() 函数：我们有时候想给网格元素一个最小和最大的尺寸，minmax() 函数产生一个长度范围，表示长度就在这个范围之中都可以应用到网格项目中。它接受两个参数，分别为最小值和最大值。grid-template-columns: 1fr 1fr minmax(300px, 2fr) 的意思是，第三个列宽最少也是要 300px，但是最大不能大于第一第二列宽的两倍。\n.wrapper-4 &#123; \tdisplay: grid; \tgrid-template-columns: 1fr 1fr minmax(300px, 2fr); \tgrid-gap: 5px; \tgrid-auto-rows: 50px; &#125;\n\n\ngrid-row-gap 属性、grid-column-gap 属性以及 grid-gap 属性grid-row-gap 属性、grid-column-gap 属性分别设置行间距和列间距。grid-gap 属性是两者的简写形式。\ngrid-row-gap: 10px 表示行间距是 10px，grid-column-gap: 20px 表示列间距是 20px。grid-gap: 10px 20px 实现的效果是一样的\n.wrapper &#123; \tdisplay: grid; \tgrid-template-columns: 200px 100px 100px; \tgrid-gap: 10px 20px; \tgrid-auto-rows: 50px; &#125;.wrapper-1 &#123; \tdisplay: grid; \tgrid-template-columns: 200px 100px 100px; \tgrid-auto-rows: 50px; \tgrid-row-gap: 10px; \tgrid-column-gap: 20px; &#125;\n\n基于行&#x2F;列的基本定位方法定位网格元素最简单的方式是使用基于行&#x2F;列（line）的定位方法，只需告诉浏览器从哪一排到哪一排来进行合并。例如，如果你需要一个2*2的网格区域，你可以将指定元素从第一行开始到第三行、从第一列开始到第三列，这样就可以覆盖到四个单元格。\n.item &#123; \tgrid-column-start: 1; \tgrid-column-end: 3; \tgrid-row-start: 1; \tgrid-row-end: 3; &#125;\n\n这些属性可以用缩写来表示：grid-column和grid-row，其中起一个值代表起始值，第二个值代表结束值。\n.item &#123; \tgrid-column: 1 / 3; \tgrid-row: 1 / 3; &#125;\n\n你也可以让网格项（grid item）占据同一个单元格。支持一些内容间会覆盖的设计。网格项会像通常网页中的元素那样叠起来，在html源码中下面的网格项会叠在其他元素上面。你仍然可以用z-index来控制它的堆叠顺序。\n实例：\n&lt;div class=&quot;container&quot;&gt;\t&lt;div class=&quot;one&quot;&gt;1&lt;/div&gt;\t&lt;div class=&quot;two&quot;&gt;2&lt;/div&gt; \t&lt;div class=&quot;three&quot;&gt;3&lt;/div&gt; \t&lt;div class=&quot;four&quot;&gt;4&lt;/div&gt; \t&lt;div class=&quot;five&quot;&gt;5&lt;/div&gt; &lt;/div&gt;&lt;style&gt;\tbody &#123; \t\tpadding: 20px; \t\tfont: 1em Helvetica Neue, Helvetica, Arial, sans-serif; \t&#125; \t* &#123;\t\tbox-sizing: border-box;\t&#125; \tp &#123; \t\tmargin: 0 0 1em 0; \t&#125; \t.container &#123; \t\twidth: 500px; \t\tborder: 5px solid rgb(111,41,97); \t\tborder-radius: .5em; \t\tpadding: 10px; \t\tdisplay: grid; \t\tgrid-template-columns: 1fr 1fr 1fr; \t\tgrid-gap: 20px; \t&#125; \t.container &gt; div &#123; \t\tpadding: 10px; \t&#125; \t.one &#123; \t\tgrid-column: 1 / 4; \t\tgrid-row: 1; \t\tbackground-color: rgba(111,41,97,.3); \t\tborder: 2px solid rgba(111,41,97,.5); \t&#125; \t.two &#123; \t\tgrid-column: 1 / 3; \t\tgrid-row: 2; \t\tbackground-color: rgba(111,41,97,.3); \t\tborder: 2px solid rgba(111,41,97,.5); \t&#125; \t.three &#123; \t\tgrid-column: 2 / 4; \t\tgrid-row: 2 / 5; \t\tbackground-color: rgba(193,225,237,.3); \t\tborder: 2px solid rgba(193,225,237,.5); \t&#125; \t.four &#123; \t\tgrid-column: 1; \t\tgrid-row: 4 ; \t\tbackground-color: rgba(193,225,237,.3); \t\tborder: 2px solid rgba(193,225,237,.5); \t&#125; \t.five &#123; \t\tgrid-column: 3 ; \t\tgrid-row: 4 / 5; \t\tbackground-color: rgba(111,41,97,.3); \t\tborder: 2px solid rgba(111,41,97,.5); \t&#125;&lt;/style&gt;\n\n\n通过命名区域来定位元素你可以通过命名区域（named areas）来定位网格中的元素。要是用这种方式，你需要给每个元素一个名字，然后通过grid-template-areas属性的值来描述布局方式。\n.item1 &#123; grid-area: a; &#125; .item2 &#123; grid-area: b; &#125; .item3 &#123; grid-area: c; &#125; .container &#123; \tdisplay: grid; \tgrid-template-columns: 1fr 1fr 1fr 1fr; \tgrid-template-areas: &quot;a a b b&quot; \t\t\t\t\t\t &quot;a a c c&quot;; &#125;\n\n使用这种方式有几个需要注意的点。如果你想要合并一些单元格作为你的网格项，你需要重复元素的名字。网格区域需要能形成一个完整的矩形 —— 每个单元格都需要被填入一个值。如果你想要空出某些单元格，那就需要使用 . 这个值。\n.container &#123; \tdisplay: grid; \tgrid-template-columns: 1fr 1fr 1fr 1fr; \tgrid-template-areas: &quot;a a b b&quot; \t\t\t\t\t\t &quot;a a c .&quot;; &#125;\n\n实例：\n&lt;div class=&quot;container&quot;&gt;\t&lt;div class=&quot;one&quot;&gt;1&lt;/div&gt;\t&lt;div class=&quot;two&quot;&gt;2&lt;/div&gt; \t&lt;div class=&quot;three&quot;&gt;3&lt;/div&gt; \t&lt;div class=&quot;four&quot;&gt;4&lt;/div&gt; \t&lt;div class=&quot;five&quot;&gt;5&lt;/div&gt; &lt;/div&gt;&lt;style&gt;\tbody &#123; \t\tpadding: 20px; \t\tfont: 1em Helvetica Neue, Helvetica, Arial, sans-serif; \t&#125; \t* &#123;\t\tbox-sizing: border-box;\t&#125; \tp &#123; \t\tmargin: 0 0 1em 0; \t&#125; \t.container &#123; \t\twidth: 500px; \t\tborder: 5px solid rgb(111,41,97); \t\tborder-radius: .5em; \t\tpadding: 10px; \t\tdisplay: grid; \t\tgrid-template-columns: 1fr 1fr 1fr; \t\tgrid-auto-rows: minmax(50px, auto);\t\tgrid-gap: 20px; \t\tgrid-template-areas: &quot;a a a&quot; \t\t\t\t\t\t\t &quot;b c c&quot; \t\t\t\t\t\t\t &quot;. . d&quot; \t\t\t\t\t\t\t &quot;e e d&quot;;\t&#125; \t.container &gt; div &#123; \t\tpadding: 10px; \t\tbackground-color: rgba(111,41,97,.3); \t\tborder: 2px solid rgba(111,41,97,.5);\t&#125; \t.one &#123; \t\tgrid-area: a;\t&#125; \t.two &#123; \t\tgrid-area: b;\t&#125; \t.three &#123; \t\tgrid-area: c; \t&#125; \t.four &#123; \t\tgrid-area: d;\t&#125; \t.five &#123; \t\tgrid-area: e;\t&#125;&lt;/style&gt;\n\n\n排版上下文行级排版上下文\nInline Formatting Context (IFC)\n只包含行级盒子 的容器会创建一个IFC\nIFC 内的排版规则：\n盒子在同一行水平摆放\n一行放不下时，换行显示\ntext-align 决定一行内盒子的水平对齐\nvertical-align 决定一个盒子的水平对其\n避开浮动（float）元素*\n\n\n\n块级排版上下文\nBlock Formatting Context (BFC)\n某些元素会创建一个BFC：\n根元素\n浮动、绝对定位、inline-block\nFlex子项和Gird子项\noverflow 值不是 visible 的块盒\ndisplay:flow-root;\n\n\n\n网格布局格式化上下文\nGrid Formatting Context (GFC)\n声明display:grid&#x2F;inline-grid能创建一个网格容器，网格容器会为其内容产生GFC。\n网格布局引入了二维网格布局系统，通过一组相交的水平线和垂直线来定义网格的列和行，网格元素被布局到这些行和列相关的位置上。\n\n弹性格式化上下文\nFlex Formatting Context (FFC)\n声明display:flex&#x2F;inline-flex能创建一个弹性容器，弹性容器会为其内容产生FFC。\n\n颜色RGBrgb(#fff, #fff, #fff);/* rgba(#fff, #fff, #fff, 1); */\n\nHSLhsl(120, 66%, 50%);/* hsla(120, 66%, 50%, 1); */\n\n\n字体font-familyfont-family 可以把多个字体名称作为一个“回退”系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。也就是说，font-family 属性的值是用于某个元素的字体族名称或&#x2F;及类族名称的一个优先表。\nfont-family:&quot;Times New Roman&quot;,Georgia,Serif;\n\nfont-size用于设置 字体大小，辅以单位控制，实质上是控制 字符框 的高度。\nfont-stylefont-style属性指定文本的字体样式。\nfont-style:normal; /*默认值。浏览器显示一个标准的字体样式。*///font-style:italic; /*浏览器会显示一个斜体的字体样式。*///font-style:oblique; /*浏览器会显示一个倾斜的字体样式。*///font-style: inherit ; /*规定应该从父元素继承字体样式。*/\n\nfont-weightfont-weight 属性设置文本的粗细。\nfont-weight:normal; /*默认值，标准。*///font-weight:bold; /*加粗*///font-weight:900; /*自定义数值*/\n\nfont-variantfont-variant 属性设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小\nfont-variant 属性主要用于定义小型大写字母文本\nfont-variant:normal; /*默认值。浏览器会显示一个标准的字体。*///font-variant:normal; /*浏览器会显示小型大写字母的字体。*///font-variant:normal; /*规定应该从父元素继承 font-variant 属性的值。*/\n\nfontfont 简写属性在一个声明中设置所有字体属性。\n可设置的属性是（按顺序）： “font-style font-variant font-weight font-size&#x2F;line-height font-family”\nfont-size和font-family的值是必需的。如果缺少了其他值，默认值将被插入，如果有默认值的话。\nfont:15px arial,sans-serif;//font:italic bold 12px/30px Georgia, serif;\n\n文本格式line-height设置以百分比计的行高。\nline-height:90%//line-height:200%\n\n注意： 负值是不允许的\nwhite-space指定元素内的空白怎样处理。\nwhite-space:normal; /*默认。空白会被浏览器忽略。*///white-space:pre; /*空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。*///white-space:nowrap; /*文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。*///white-space:pre-wrap; /*保留空白符序列，但是正常地进行换行。*///white-space:pre-line; /*合并空白符序列，但是保留换行符。*///white-space:inherit; /*规定应该从父元素继承 white-space 属性的值。*/\n\n盒子模型块级Block Level Box 不和其他盒子并列摆放，适用所有的盒模型属性。\n块级元素生成块级盒子：body、article、div、main、section、h1-6、p、ul、li 等。\ndisplay:block;\n\n行级Inline Level Box 和其他行级盒子一起放在一行或拆开成多行，盒模型中的width、height不适用。\n行级元素生成行级盒子，内容分散在多个行盒（line box）中：span、em、strong、cite、code 等。\ndisplay:inline;\n\nFlex BoxFlex Box 是一种新的排版上下文，它可以控制子级盒子的：\n\n摆放的流向（→ ↑ ↓ ←）\n摆放顺序\n盒子宽度和高度\n水平和垂直方向的对齐\n是否允许折行\n\ndisplay:flex;/* 项目在主轴上的对齐方式 */justify-content: center;     /* 居中排列 */  //justify-content: start;      /* 从行首开始排列 */  //justify-content: end;        /* 从行尾开始排列 */  //justify-content: flex-start; /* 从行首起始位置开始排列 */  //justify-content: flex-end;   /* 从行尾位置开始排列 */  //justify-content: left;       /* 一个挨一个在对齐容器得左边缘 */  //justify-content: right;      /* 元素以容器右边缘为基准，一个挨着一个对齐, */    /* 基线对齐 */  //justify-content: baseline;  //justify-content: first baseline;  //justify-content: last baseline;    /* 分配弹性元素方式 */  //justify-content: space-between;  /* 均匀排列每个元素，首个元素放置于起点，末尾元素放置于终点 */  //justify-content: space-around;  /* 均匀排列每个元素，每个元素周围分配相同的空间 */  //justify-content: space-evenly;  /* 均匀排列每个元素，每个元素之间的间隔相等 */  //justify-content: stretch;       /* 均匀排列每个元素，auto-sized 的元素会被拉伸以适应容器的大小 */    /* 溢出对齐方式 */  //justify-content: safe center;  //justify-content: unsafe center;    /* 全局值 */  //justify-content: inherit;  //justify-content: initial;  //justify-content: unset;/* 项目在交叉轴上的对齐方式 *///align-items:...;/* 多行项目的排列方式 *///align-content:...;\n\ndisplay 属性display:block; /*块级盒子*///display:linine; /*行级盒子*///display:inline-block; /*本身是行级，可以放在行盒中；可以设置宽高；作为一个整体不会被拆散成多行*///display:flex; /*浮动布局*///display:none; /*排版时完全被忽略*/\n\n调试 CSS\n在chrome浏览器中，可以通过F12或菜单，打开“开发者工具”。\nctrl + shift + i\n\nCreate By Asuka24601","categories":["技术"],"tags":["前端","CSS","技术"]},{"title":"OpenGL的缓冲位","url":"/2022/05/01/OpenGL%E7%9A%84%E7%BC%93%E5%86%B2%E4%BD%8D/","content":"OpenGL有多个缓冲位（Buffer Bit），这些缓冲位又称缓冲区。\nGL_COLOR_BUFFER_BIT，颜色缓冲区OpenGL在绘制图元时，先是在一个缓冲区中完成渲染，然后再把渲染结果交换到屏幕上。我们把这两个缓冲区称为前颜色缓冲区（屏幕）和后颜色缓冲区。在默认情况下，OpenGL命令是在后颜色缓冲区进行渲染的。当然，也可以直接在前颜色缓冲区中进行渲染。\n若要在前颜色缓冲区中进行渲染，第一种方法是直接告诉OpenGL希望在前颜色缓冲区中进行绘图，可以调用下面这个函数来实现这个目的：\nvoid glDrawBuffer（Glenum mode）;\n\n如果参数 mode 指定为 GL_FRONT ，OpenGL就会在前颜色缓冲区中进行渲染；\n如果参数 mode 指定为 GL_BACK ，那么渲染将在后颜色缓冲区中进行。\n在前颜色缓冲区进行渲染的第二种方法是在OpenGL被初始化时简单地不要求进行双缓冲区渲染。进行单缓冲区渲染时，如果希望把渲染结果实际绘制到屏幕上，需要调用 glFlush() 或 glFinsh() ，这点非常重要。\nOpenGL实现除了支持单纯的前颜色缓冲区和后颜色缓冲区之外，还支持其他模式，如用于立体渲染的左和右缓冲区以及辅助缓冲区。\nGL_DEPTH_BUFFER_BIT，深度缓冲区与颜色缓冲区不同的是，深度缓冲区中所填充的是深度值而不是颜色值。\n为了启用深度缓冲区进行深度测试，只需要调用：\nglEnable（GL_DEPTH_TEST）;\n\n\n另外，即使深度缓冲区未被启用，如果深度缓冲区被创建，OpenGL也会把所有写入到颜色缓冲区的颜色片段对应的深度值写入到深度缓冲区中。但是，如果我们希望在进行深度测试时临时禁止把值写入到深度缓冲区，我们可以使用函数：\nvoid glDepthMask（GLboolean mask）;\n\n把 GL_FALSE 作为参数，经禁止写入深度值，但并不禁止用已经写入到深度缓冲区的值进行深度测试。\n把 GL_TRUE 作为参数，可以重新启用深度缓冲区的写入。同时，这也是默认的设置。\nGL_STENCIL_BUFFER_BIT，模板缓冲区与颜色缓冲区和深度缓冲区类似，模板缓冲区可以为屏幕上的每个像素点保存一个无符号整数值。这个值的具体意义视程序的具体应用而定。在渲染的过程中，可以用这个值与一个预先设定的参考值相比较，根据比较的结果来决定是否更新相应的像素点的颜色值。这个比较的过程被称为模板测试。\n模板测试发生在 透明度测试（alpha test） 之后， 深度测试（depth test） 之前。如果模板测试通过，则相应的像素点更新，否则不更新。就像使用纸板和喷漆一样精确的混图一样，当启动 模板测试（stencil test） 时，通过模板测试的片段像素点会被替换到颜色缓冲区中，从而显示出来，未通过的则不会保存到颜色缓冲区中，从而达到了过滤的功能。\n\n\n\n为了启用模板缓冲区进行模板测试，只需要调用：\nglEnable(GL_STENCIL_TEST);\n\nGL_ACCUM_BUFFER_BIT，积累缓冲区累积缓冲区允许你把渲染到颜色缓冲区的值，拷贝到累积缓冲区。在多次拷贝操作到累积缓冲区时，可以用不同方式的把颜色缓冲区内容和当前累积缓冲区的内容进行重复混合。当在累积缓冲区完成一幅图像之后，可以拷回颜色缓冲区，然后通过SwapBuffers显示到屏幕上。\n可以用 glClearAccum() 来设置红、绿和蓝色分量的清空值，按位顺序清空累积缓存或以 GL_ACCUM_BUFFER_BIT 调用 glClear() 命令。\nCreate By Asuka24601\n","categories":["计算机图形学"],"tags":["技术","openGL"]},{"title":"在Windows上配置轻量级的OpenGL开发环境","url":"/2022/04/28/%E5%9C%A8Windows%E4%B8%8A%E9%85%8D%E7%BD%AE%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84OpenGL%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","content":"前言得益于语言文字的多模糊性，对于 __OpenGL__，我们的第一感觉很容易就认为那是一个图形类库，一个API，一堆代码，但是事实并非如此。OpenGL 是一类规范，并非实打实的代码，它严苛的规范了每一个函数应该如何执行，以及它们的返回值、输出值。而它的内部实现，则是由各个 OpenGL 库开发者完成的，因此当今市面上有很多 OpenGL 库可供开发者选择。\n\n值得说的一点是，OpenGL 的大多数实现都是由显卡厂商编写的，但各个厂商对 OpenGL 的不同实现带来了的性能差异基本可以无视，所以玩游戏卡不卡主要还是得靠硬件。\n\n现在 OpenGL的最新版本为 OpenGL4.5，但是作为初学者来说，我们并不需要学习那么新的版本，而 OpengGL3.3 是一个不错的开始，所以请记住这一点，后文中的所有代码都是符合 OpenGL3.3 规范的。\n\n请确认你的系统支持OpenGL3.3或更高版本，如果不支持，这边建议换个显卡。\n\n关于更多详细信息，可以访问 LearnOpenGL 进行学习。\nGLFWGLFW 是一个专门针对 OpenGL 的 C 语言库，但我们的实际情况主要是用 C++ 调用此C库，二者兼容，所以使用起来没有问题。\nGLFW 提供了一些渲染物体所需的最低限度的接口。它允许用户创建 OpenGL上下文、定义窗口参数以及处理用户输入，对我们来说这就够了。\n首先访问 GLFW官网 下载源码包(Source package)到本地，之后再将其解压。\n\n此处，为了便于之后的代码文件查找和管理，我建议预先建立一个 文件夹 用于存放接下来要存在在本地的文件和代码，例如我建立了 D:&#x2F;DEV&#x2F; 用于存放之后的学习开发所需要的资源。\n\n获得源码之后，我们必须将其编译成适合我们开发环境的工程文件，为了完成这一点，我们需要下载安装 CMake ，它很适合完成这项工作。\n当 CMake 安装完成后，在它的GUI界面中我们能看到这之画面。\n\nWhere is the source code 填写你下载的源代码的根目录（例如我的是 D:&#x2F;DEV&#x2F;glfw-3.3.7）。\nWhere to build the binaries 填写你的目标目录（例如我选择在源代码目录新建一个build目录作为我的目标目录，则我的目标目录是D:&#x2F;DEV&#x2F;glfw-3.3.&#x2F;build）\n\n之后，点击 Tools 选项中的 Configure 按钮，让CMake 来读取 设置和源代码。\n接下来我们要完成工程文件选择设置，具体情况具体选择，这里我使用的是 Visual Studio 2022，所以我选择的是Visual Studio 17 2022。其他选项默认即可。\n\n然后点击 Finish 就可以让CMake读取项目文件的配置了！\n当CMake读取完成后你将可以看到配置的具体内容。\n\n最后点击 Generate(生成)  完成工作。然后你能在 build 文件夹中找到 GLFW.sln 工程文件了。\n使用 Visual Studio 2022 打开 GLFW.sln。由于CMake已经为我们完成了所有的配置工作，所以我们这里直接点击 生成解决方案 。\n\n待生成完成后，我们就能在 build&#x2F;src&#x2F;Debug 文件夹内找到编译出的库文件 glfw3.lib 。\n\n在 bulid 目录中还有 build&#x2F;examples 和 build&#x2F;tests 两个目录，这两个目录的 debug 文件夹内有一些官方提供的演示样例可供我们学习。\n\n至此，我们完成了对 GLFW 的获取以及编译。\n\n为了方便在后续的工程中链接我们的库文件，我可以在 DEV 目录下分别新建一个 include 文件夹 和 lib 文件夹来放置我们下载的库的头文件和运行库。\n\n这时我们将 glfw3.lib 复制粘贴到 DEV&#x2F;lib 目录中，之后再复制 glfw 根目录下的 include 文件夹内的一切粘贴到  DEV&#x2F;include 中。\nGLAD单单有 GLFW 还是不够的。因为 OpenGL 只是一个规范，具体的实现是由驱动开放商针对特定显卡实现的，由于市面上拥有众多 OpenGL 驱动版本，所以 OpenGL 的大多数函数地址都无法在编译时被确定下来，而需要在运行时查询， 所以开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。由于函数地址的获取方式因平台而异，并且有时会相对复杂，所以我们需要一个工具来帮我们解决这一问题 。\n// 获取函数地址的过程类似如下// 定义函数原型 typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*); // 找到正确的函数并赋值给函数指针 GL_GENBUFFERS glGenBuffers = (GL_GENBUFFERS)wglGetProcAddress(&quot;glGenBuffers&quot;); // 现在函数可以被正常调用了 GLuint buffer; glGenBuffers(1, &amp;buffer);\n\nGLAD 是一个开源的库，也是目前符合我们需求且最新最流行的库，它能帮助我们简化获取OpenGL函数地址的过程，所以我们需要它。\nGLAD 与其他很多库不同的是，它使用了一个在线服务 ，在这里我们要告诉 GLAD 我们需要定义的OpenGL的版本，并根据这个版本加载所有相关的OpenGL函数。\n在这里，我们选择 Language（语言） 为 C&#x2F;C++ ，Specification（规格） 为 OpenGL ， API 中选择选择 gl 的版本为 Version3.3 或以上，这里我们选择的是 Version3.3 ， Profile（模式）选择为 Core ，然后在底部的 Options 勾选上 Generate a loader （生成加载器）。至于其他其他的 Extensions （扩展）选项，我们暂时忽略就好。\n\n之后点击 GENERATE（生成），我们将打开一个界面。\n\n在这里我们点击 glad.zip ，就能将库文件下载到本地。在这个压缩包内有两个头文件目录，include 和 src ，其中 src 中只有一个 glad.c 文件。此时我们将压缩包内的 inlcud 文件夹内的两个文件夹 glad 和 KHR 解压到 DEV&#x2F;include 中，再将 glad.c 解压到 DEV&#x2F;include（或者 DEV&#x2F;include&#x2F;src） 中。 \n请记住这个 glad.c ，此时放入 DEV&#x2F;include （或者 DEV&#x2F;include&#x2F;src）只是为了方便查找，之后我们将要将它添加到我们的工程中。\n基本情况如下图所示：\n\n至此，我们完成了对 GLFW 和 GLAD 两个库基本配置，下一步我们将在工程中链接它们。 \n第一个工程你懂的，在 Visual Studio 2022 中新建一个 Empty Project ，为这个项目取个你喜欢的名字（建议取为 LearnOpenGL ），选个你喜欢的目录（建议选在 DEV&#x2F; ），我们就可以愉快的开始下一步了！\n\n注意，我们是在 64位 模式开展的工程，而新项目默认是 32位 的，所以我们要注意更改模式，即要将 Debug 模式更改为 x64。\n\n&gt; \n为了正常使用 GLFW ，我们需要将 GLFW库 链接到我们的工程中，即我们要通过 链接器 设置指定我们要使用 glfw3.lib。\n由于第三方库在 链接器 默认识别的目录之外，它在工作时并不知道第三方库在哪，也不知道寻找哪个文件夹，所以我们需要将第三方库所在的文件夹的位置添加进工程设置中。\n为了完成这一点，我们需要打开先前创建的第一个工程，右键项目，打开项目 属性 。\n\n在项目属性窗口中的 配置属性 中，我们选中 VC++目录 ，编辑 包含目录，将我们前面创建的 D:&#x2F;DEV&#x2F;include 添加进去。同理，我们再编辑 库目录 ，将 D:&#x2F;DEV&#x2F;lib 添加进去。\n\n\n在 包含目录 中所能添加的 include文件夹的路径是可以无限多的， 库目录 同理。只要我们在 包含目录 中添加了相应的 inlcude文件夹，我们便能在该项目的代码中使用这些第三方库，链接器也知道去哪里找到我们指定包含的第三方库。\n\n但是到此还是不够的，最后我们还需要告诉链接器我们要链接的那个库的名字，于是我们要在 链接器 的选项卡中选中 输入 这一选项，编辑 附加依赖项目 ，添加 glfw3.lib 这一字段，这样在编译的时候，链接器就知道把它链接进来了。\n但是除了 glfw3.lib 以外， 我们还需要额外链接一个库，在 Windows 上这个库为 opengl32.lib 。\n\nopengl32.lib 默认包含在 Microsoft SDK 里，这意味着我们在安装 Visual Studio 时就已经默认获得了这个库。如果你没有，请检查自己的 Visual Studio 安装程序 中是否勾选到 Microsoft SDK 。而且无论是 32位版本 还是 64位版本 ，这个库文件的名字都是 opengl32.lib 。\n\n\n完成这一步之后，我们便能在直接包含这些头文件，IDE也会自动识别这些头文件。\n// 形如以下操作// 注意，glad 要在 GLFW 之前进行包含#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;//...\n\n现在，让我们新建一个 test.cpp 源文件，输入如下代码（注意，glad 要在 GLFW 之前进行包含，因为 glad 已经包含了正确的OpenGL文件）：\n// 注意，glad 要在 GLFW 之前进行包含#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;int main()&#123;\tglfwInit(); \tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); \tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\tglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\t//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); return 0;\tstd::cout &lt;&lt; &quot;OK&quot;;\treturn 0;&#125;\n\n生成调试应该可以直接运行。如果有错误，请仔细检查自己是否打错了文件名或者遗漏了什么步骤，如果还有问题，这边建议去问问神奇的海螺。\nCreate By Asuka24601","categories":["计算机图形学"],"tags":["技术","OpenGL"]},{"title":"使用cout标准输出控制小数点后位数","url":"/2021/12/30/%E4%BD%BF%E7%94%A8cout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E4%BD%8D%E6%95%B0/","content":"范围float 和 double 的范围是由指数的位数来决定的。  \nfloat 的指数位有8位，而 double 的指数位有11位，分布如下:  \n\nfloat : 1bit（符号位） 8bits（指数位） 23bits（尾数位）double : 1bit（符号位） 11bits（指数位） 52bits（尾数位）  \n\n于是，float的指数范围为-127 ~ +128，而double的指数范围为-1023 ~ +1024，并且指数位是按补码的形式来划分的。  \n其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。  \nfloat 的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；\ndouble 的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。\n精度  float 和 double 的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。  \n  float : 2^23 &#x3D; 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字；  \n  double : 2^52 &#x3D; 4503599627370496，一共16位，同理，double的精度为15~16位。\n示例代码这属于冷门知识了。\n#include &lt;iostream&gt;#include &lt;iomanip&gt; //此头文件是输入/输出库的一部分。using namespace std;int main()&#123;    const double value = 12.3456789;    cout &lt;&lt; value &lt;&lt; endl; // 默认以6精度，所以输出为 12.3457    cout &lt;&lt; setprecision(4) &lt;&lt; value &lt;&lt; endl; // 改成4精度，所以输出为12.35    cout &lt;&lt; setprecision(8) &lt;&lt; value &lt;&lt; endl; // 改成8精度，所以输出为12.345679    cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; value &lt;&lt; endl; // 加了fixed意味着是固定点方式显示，所以这里的精度指的是小数位，输出为12.3457    cout &lt;&lt; value &lt;&lt; endl; // fixed和setprecision的作用还在，依然显示12.3457    cout.unsetf( ios::fixed ); // 去掉了fixed，所以精度恢复成整个数值的有效位数，显示为12.35    cout &lt;&lt; value &lt;&lt; endl;    cout.precision( 6 ); // 恢复成原来的样子，输出为12.3457    cout &lt;&lt; value &lt;&lt; endl;    return 0;&#125;\n\n\n\nCreate By Asuka24601","categories":["C/C++"],"tags":["技术","C++"]},{"title":"VSCode的json配置文件中各种变量的含义","url":"/2021/11/01/VSCode%E7%9A%84json%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%90%84%E7%A7%8D%E5%8F%98%E9%87%8F%E7%9A%84%E5%90%AB%E4%B9%89/","content":"前提&emsp;&emsp;在vscode中定义了一些变量,在配置任务脚本时,可能会用到。本文以 launch.json脚本为例，介绍各个变量的含义。&emsp;&emsp;假设当前workspace的路径为: “C:\\Users\\admin\\Desktop\\test”, workspace文件夹下的结构如下：  \n\nC:\\Users\\admin\\Desktop\\test  \n\n├ .vscode│&emsp; ├ tasks.json│&emsp; └ launch.json├ main.cpp  \n\n\n变量$&#123;workspaceFolder&#125; //表示当前workspace文件夹路径，也即 C:\\Users\\admin\\Desktop\\test$&#123;workspaceRootFolderName&#125; //表示workspace的文件夹名，也即 test$&#123;file&#125; //文件自身的绝对路径，也即 C:\\Users\\admin\\Desktop\\test\\.vscode\\launch.json$&#123;relativeFile&#125; //文件在workspace中的路径，也即 .vscode\\launch.json$&#123;fileBasenameNoExtension&#125; //当前文件的文件名，不带后缀，也即 launch$&#123;fileBasename&#125; //当前文件的文件名，也即 launch.json$&#123;fileDirname&#125; //文件所在的文件夹路径，也即 C:\\Users\\admin\\Desktop\\test\\.vscode$&#123;fileExtname&#125; //当前文件的后缀，也即 .json$&#123;lineNumber&#125; //当前文件光标所在的行号$&#123;env:PATH&#125; //系统中的环境变量\n\n\n\np align&#x3D;”center”&gt;Create By Asuka24601\n","categories":["技术"],"tags":["技术","VSCode","配置"]},{"title":"404","url":"/2022/04/09/404/","content":"\n\n\n\n\n\n这是一个空的页面\n\n这里还什么都没有\n\n这里只有虚无\n\n一切的开始都是虚无\n\n一切从虚无中脱生\n\n一切从虚无中成形\n\n我们幻想一切在森林中隐没的火苗\n\n我们见过一切在日出前摇曳的影子\n\n但我们并未拥有去拥有虚无的权利\n\n但我们拥有着这个世界唯一的权利\n\n去开始一切的权利\n\n我们开始看见，开始热爱，开始生活，开始追逐...\n\n于是，开始坠入更大的虚无...\n\n一切被放大的幸福\n\n一切被聚拢的孤独\n\n这是人类的特性\n\n也是我们所需要的努力\n\n因此你无需害怕，也无需担心\n\n因为我们选择了开始\n\n从一个 Empty Project 开始\n\n你好，404\n\n\n\nCreate By Asuka24601\n","categories":["诗歌"],"tags":["随想","现代诗"]}]